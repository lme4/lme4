<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Ross Boylan ross.boylan@ucsf.edu" />

<meta name="date" content="2024-06-18" />

<title>How lme4 simulates</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">How lme4 simulates</h1>
<h4 class="author">Ross Boylan <a href="mailto:ross.boylan@ucsf.edu" class="email">ross.boylan@ucsf.edu</a></h4>
<h4 class="date">2024-06-18</h4>


<div id="TOC">
<ul>
<li><a href="#how-to-modify" id="toc-how-to-modify">How to Modify</a>
<ul>
<li><a href="#the-problem" id="toc-the-problem">The Problem</a></li>
<li><a href="#solve-through-lme4-extension" id="toc-solve-through-lme4-extension">Solve through <code>lme4</code>
Extension?</a></li>
<li><a href="#analysis" id="toc-analysis">Analysis</a></li>
<li><a href="#alternate-designs" id="toc-alternate-designs">Alternate
Designs</a></li>
<li><a href="#elaborations-and-pitfalls" id="toc-elaborations-and-pitfalls">Elaborations and Pitfalls</a>
<ul>
<li><a href="#pass-in-dimensions-separately-to-random-generator" id="toc-pass-in-dimensions-separately-to-random-generator">Pass in
Dimensions Separately to Random Generator</a></li>
<li><a href="#pass-analysis-function-to-simulate" id="toc-pass-analysis-function-to-simulate">Pass Analysis Function to
<code>simulate()</code></a></li>
<li><a href="#pass-domain-to-simulate" id="toc-pass-domain-to-simulate">Pass Domain to
<code>simulate()</code></a></li>
<li><a href="#caution-random-generator-seed" id="toc-caution-random-generator-seed">Caution: Random Generator
Seed</a></li>
<li><a href="#caution-non-linear-or-multidimensional-random-effect" id="toc-caution-non-linear-or-multidimensional-random-effect">Caution:
Non-Linear or Multidimensional Random Effect</a></li>
</ul></li>
</ul></li>
<li><a href="#analysis-of-existing-code" id="toc-analysis-of-existing-code">Analysis of Existing Code</a>
<ul>
<li><a href="#top-level" id="toc-top-level">Top-Level</a>
<ul>
<li><a href="#puzzle" id="toc-puzzle">Puzzle</a></li>
</ul></li>
<li><a href="#random-effects-options" id="toc-random-effects-options">Random Effects Options</a></li>
<li><a href="#initial-processing" id="toc-initial-processing">Initial
Processing</a></li>
<li><a href="#construct-glmod-etc" id="toc-construct-glmod-etc">Construct <code>glmod</code> etc</a></li>
<li><a href="#mkmermod" id="toc-mkmermod"><code>mkMerMod()</code></a></li>
<li><a href="#random-effects-and-other-housekeeping" id="toc-random-effects-and-other-housekeeping">Random Effects and Other
Housekeeping</a></li>
<li><a href="#eta-finally-something-interesting" id="toc-eta-finally-something-interesting"><span class="math inline">\(\eta\)</span>: Finally Something
Interesting</a></li>
<li><a href="#predict.mermod" id="toc-predict.mermod"><code>predict.merMod()</code></a></li>
<li><a href="#add-random-effects" id="toc-add-random-effects">Add Random
Effects</a>
<ul>
<li><a href="#isre" id="toc-isre"><code>isRE()</code></a></li>
<li><a href="#random-effects-generation-core" id="toc-random-effects-generation-core">Random Effects generation
core</a></li>
<li><a href="#mknewretrms" id="toc-mknewretrms"><code>mkNewReTrms()</code></a></li>
<li><a href="#findbars" id="toc-findbars"><code>findbars()</code></a></li>
<li><a href="#expanddoubleverts" id="toc-expanddoubleverts"><code>expandDoubleVerts()</code></a></li>
<li><a href="#mkretrms" id="toc-mkretrms"><code>mkReTrms()</code></a></li>
<li><a href="#mkblist" id="toc-mkblist"><code>mkBlist()</code></a></li>
<li><a href="#mknewretrms-continued" id="toc-mknewretrms-continued"><code>mkNewReTrms()</code>
continued</a></li>
<li><a href="#adding-random-and-fixed-effects" id="toc-adding-random-and-fixed-effects">Adding Random and Fixed
Effects</a></li>
</ul></li>
<li><a href="#home-stretch" id="toc-home-stretch">Home Stretch</a></li>
<li><a href="#inner-simulation-functions" id="toc-inner-simulation-functions">Inner Simulation Functions</a></li>
</ul></li>
<li><a href="#entire-predict.r-in-lme4" id="toc-entire-predict.r-in-lme4">Entire <code>predict.R</code> in
<code>lme4</code></a></li>
</ul>
</div>

<p>This documents consists mostly of code from <code>lme4</code>’s
<code>predict.R</code> and <code>utilities.R</code> and my analysis of
how it performs simulation. I will need to modify the current behavior,
but I need to figure out where the current cluster random effects come
from in simulation.</p>
<p>Some of the code in <code>lme4</code> allows you to get conditional
or unconditional predictions based on some or all of the random
effects.</p>
<p>I traced through the action for <code>x &lt;- simulate(b)</code> in
the debugger, and emphasize the resulting flow of control. I think the
setup was based on <code>test-zpred.R</code> in <code>pimex</code>,
though it has scrolled off the buffer. I loaded the definition of
<code>realDate()</code> from that file and then</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>  <span class="co"># test script is run from the testthat dir; I add a path for these</span></span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="co"># purposes since in project root.</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>  PIPAe <span class="ot">&lt;-</span> <span class="fu">realData</span>(<span class="st">&quot;tests/testthat/PIPA_data.dta&quot;</span>) <span class="co"># e for early (months 1-6)</span></span>
<span id="cb1-4"><a href="#cb1-4" tabindex="-1"></a>  <span class="co"># STATA used ML, not our default ML</span></span>
<span id="cb1-5"><a href="#cb1-5" tabindex="-1"></a>  r <span class="ot">&lt;-</span> <span class="fu">lmz</span>(ln_los<span class="sc">~</span><span class="dv">1</span>, fid, <span class="fu">zSQ</span>(<span class="fl">0.25</span>), PIPAe, <span class="at">REML=</span><span class="cn">FALSE</span>)</span>
<span id="cb1-6"><a href="#cb1-6" tabindex="-1"></a>  b <span class="ot">&lt;-</span> r<span class="sc">@</span>blup  <span class="co"># so b is the vanilla lme4 result, returned by lmer()</span></span>
<span id="cb1-7"><a href="#cb1-7" tabindex="-1"></a>  x <span class="ot">&lt;-</span> <span class="fu">simulate</span>(b)</span></code></pre></div>
<div id="how-to-modify" class="section level1">
<h1>How to Modify</h1>
<div id="the-problem" class="section level2">
<h2>The Problem</h2>
<p>I posted a query to <code>r-sig-mixed-models</code> on
2022-06-13:</p>
<blockquote>
<p>I want to do simulations using GLMM’s from lme4, but not exactly what
the current simulate() offers. In particular I want to generate cluster
random effects that are limited to various subsets of the real line. So
in effect the simulation takes some extra arguments.</p>
<p>Does anyone have any thoughts about the best way to approach
this?</p>
<p>At the moment, it looks to me as if the simplest route is to copy the
code (from predict.R, I think) and modify it, placing the result in my
package. This wouldn’t track future changes in the lme4 code and
generally violates Don’t Repeat Yourself, but it doesn’t seem there are
good alternatives. The parts I’m interested in changing are sections of
the current code, including functions defined inside the main function,
as well as functions internal to lme4. These do not seem amenable to the
monkey-patching methods I’ve read about in R, which generally involve
inserting extra namespaces. Since the functions are in the package
namespace (or even have function scope), I can’t intercept them.</p>
<p>The current simulate(), or, more accurately, the .simulateFun() it
calls, does a large amount of bookkeeping getting everything in suitable
form, and I would like to use that.</p>
<p>My cases of interest only have random intercepts, which of course
means some of the code that deals with more complicated random effects
is not necessary, at least initially.</p>
</blockquote>
</div>
<div id="solve-through-lme4-extension" class="section level2">
<h2>Solve through <code>lme4</code> Extension?</h2>
<p>Ben Bolker suggested it might be possible to offer some hooks that
would make it easier to modify the existing behavior. It seems providing
an optional argument to provide a custom random number generator in
place of the current <code>rnorm()</code> might do the trick.</p>
<p>Such a drop-in would allow, at least, generating random terms that
fall only in certain regions of the real line. That’s my current
concern, for looking at true and false flagging rates. It would also
allow simulations of non-normal cluster random effects distributions,
e.g., ones with heavy tails, multiple modes, or mixture distributions.
This might be useful for those wishing to check the robustness of the
methods against violations of their assumptions.</p>
<p>Note the proposal would <em>only</em> affect <em>cluster</em> random
effects; other terms, including the observation specific random noise,
would proceed as before. One could also add an argument to replace
generation of observation-specific noise.</p>
</div>
<div id="analysis" class="section level2">
<h2>Analysis</h2>
<p>The <a href="#random-effects-generation-core">core</a> of generating
cluster random effects is simply a call to <code>rnorm</code> requesting
number of clusters (or, more generally, number of cluster random effects
values) times the number of simulations values. This suggests providing
an optional argument to drop another function in place of
<code>rnorm</code>. But the scaling is tricky.</p>
<p>The values generated by <code>rnorm</code> are multiplied by
<code>lambdat</code>, which in turn come from <code>theta</code>. In my
simple case this is the estimated value of the ratio of the between to
the within standard deviations, <span class="math inline">\(\sigma_u/\sigma_\epsilon\)</span>. Then in later
code it is multiplied by <span class="math inline">\(\sigma_\epsilon\)</span>. So it ends up with the
desired standard deviation of <span class="math inline">\(\sigma_u\)</span>.</p>
<p>In the generalized mixed model case I’m not sure what the
<code>lambdat</code> values are, though I suspect they may be 1. And
there is no post-multiplication by <span class="math inline">\(\sigma_\epsilon\)</span>, fortunately, since most
of the models don’t have that parameter.</p>
</div>
<div id="alternate-designs" class="section level2">
<h2>Alternate Designs</h2>
<p>The specific requirements for the replacement function, and the way
they would be handled, present several alternatives.</p>
<ol style="list-style-type: decimal">
<li>Simply allow a replacement function for the one call to
<code>rnorm()</code>, taking the same arguments, and document that it
should ordinarily generate results scaled like the standardized
residual, i.e., <span class="math inline">\(\sigma = 1\)</span>. This is
very convenient for us, because our truncated distributions operate on
exactly this scale.</li>
<li>Interpret the random values as being on the final scale. It seems
most natural to pass <span class="math inline">\(\sigma_u\)</span> in as
an argument to the replacement function. Since <span class="math inline">\(\sigma_u\)</span> is ordinarily an estimated
parameter, the replacement random function needs to know its value. The
easiest way to handle the results from that function would be immediate
division of the result by <span class="math inline">\(\sigma_u\)</span>,
allowing re-use of existing code paths. All of which seems a little
silly, as the replacement function is likely to multiply by <span class="math inline">\(\sigma_u\)</span> and we then immediately divide
by it.</li>
<li>If a replacement function is used we could use the results more
directly, e.g., instead of multiplying by <code>lambdat</code> multiply
only by the original design matrix (<code>Zt</code> I think). Something
must be done to move from the space of cluster effects to that of
individual observations, and it seems better not to make that the
responsibility of the replacement random function. Then, at the later
point in which we multiply by <span class="math inline">\(\sigma_\epsilon\)</span>, we could do so only if
we didn’t override the random function. Again, even now, only the linear
model does the second multiplication by <span class="math inline">\(\sigma_\epsilon\)</span>. Like 2, this says the
random effect replacement function should operate on the natural scale,
and like 2 it should probably pass in the scaling argument.</li>
<li>A plausible scenario is that someone wants a truncated distribution
on the natural scale. This could be handled like point 1 above, but it
would require passing <span class="math inline">\(\sigma_u\)</span> in
to the function, or else the constructor of the function would need to
get the value some other way.</li>
</ol>
<ol style="list-style-type: decimal">
<li>looks best.</li>
</ol>
</div>
<div id="elaborations-and-pitfalls" class="section level2">
<h2>Elaborations and Pitfalls</h2>
<div id="pass-in-dimensions-separately-to-random-generator" class="section level3">
<h3>Pass in Dimensions Separately to Random Generator</h3>
<p>It might be helpful for the random function to take the number of
observations, number of random effects levels, and number of simulations
as separate arguments. This would allow direct construction of
appropriate arrays, and it could support more elaborate kinds of
correlations. This fuller specification of dimensions moves toward
scenario 3) above, in which less processing is done on the results of
the random function. Currently, <code>rnorm()</code> simply gives a long
vector of values, which <code>simulate()</code> reshapes into the
necessary matrix form.</p>
</div>
<div id="pass-analysis-function-to-simulate" class="section level3">
<h3>Pass Analysis Function to <code>simulate()</code></h3>
<p>The current design of <code>simulate.merMod()</code> generates all
the data for <em>all</em> simulations at once. Even given the use of
sparse matrices (and not every matrix is sparse), this has the potential
to use a lot of memory. It might be better to pass in a function that
performs the analysis on each simulated data set, where they are
generated one at a time. This is a very big change in the interface.</p>
<p>Currently one can achieve roughly the same effect by simulating one
or a few data sets at a time, analyzing them, and repeating until there
are sufficient total simulations. That approach saves memory but puts
more burden on the calling program, and it pays the setup and teardown
costs of <code>simulate()</code> repeatedly. So inserting an analysis
function into the simulation offers some advantages.</p>
<p>However, the approach here could end up allocating and freeing memory
more often, albeit in smaller chunks, and the overhead from that could
hurt performance.</p>
</div>
<div id="pass-domain-to-simulate" class="section level3">
<h3>Pass Domain to <code>simulate()</code></h3>
<p>Suppose the desired simulation has all standardized cluster random
effects <span class="math inline">\(&lt;\tau\)</span>. The discussion
above assumes that will be achieved by constructing a function that only
generates such values, likely through a closure that captures <span class="math inline">\(\tau\)</span>. But one could supply <span class="math inline">\(\tau\)</span> as an argument to
<code>simulate()</code> and then pass it in to custom random generator
function. Although there may be some conceptual appeal to supplying the
value as an argument to <code>simulate()</code>, I can’t see that the
hassle of doing this is worth the trouble.</p>
<p>Further, each type of random generator function is likely to have its
own parameters. So naming each argument explicitly will always be
brittle, while constructing some general code to forward all unknown
parameters to the random generator is getting elaborate.</p>
<p>Even within the scope of my immediate problem, limiting the domain
from which random effects are drawn, there are a lot of different ways
to do it:</p>
<ol style="list-style-type: decimal">
<li>Pass in <span class="math inline">\(\tau\)</span> and a flag for
whether to consider above or below.</li>
<li>Pass in <code>start</code>, <code>end</code> pairs, e.g.,
<code>-Inf, tau</code>.</li>
<li>Allow multiple pairs, or sets of pairs to satisfy the two-tailed
case of <span class="math inline">\((-\infty, -\tau), (\tau,
\infty)\)</span>.</li>
<li>Use a domain or interval object.</li>
</ol>
<p>It seems easiest to leave this a matter for the random generator
function itself, without involving <code>simulate()</code> arguments.
I.e., <em>don’t</em> do the design described in this subsection.</p>
</div>
<div id="caution-random-generator-seed" class="section level3">
<h3>Caution: Random Generator Seed</h3>
<p>The random function passed in might rely on some random state outside
the standard one that the code below manipulates. It uses
<code>set.seed()</code> and reads <code>.Random.seed</code>.</p>
</div>
<div id="caution-non-linear-or-multidimensional-random-effect" class="section level3">
<h3>Caution: Non-Linear or Multidimensional Random Effect</h3>
<p>I haven’t traced through the simulation for generalized linear
models, or for multiple random effects; I’m not sure how well suited
this approach is to them.</p>
</div>
</div>
</div>
<div id="analysis-of-existing-code" class="section level1">
<h1>Analysis of Existing Code</h1>
<div id="top-level" class="section level2">
<h2>Top-Level</h2>
<p>All the top-level (user-visible) calls simply wrap
<code>.simulateFun()</code>. For reasons that are unclear to me, the
latter is also exported by this module.</p>
<p>Here’s the top-level function I’m most likely to call:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>simulate.merMod <span class="ot">&lt;-</span> <span class="cf">function</span>(object, <span class="at">nsim =</span> <span class="dv">1</span>, <span class="at">seed =</span> <span class="cn">NULL</span>, <span class="at">use.u =</span> <span class="cn">FALSE</span>,</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>                            <span class="at">re.form=</span><span class="cn">NA</span>, ReForm, REForm, REform,</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>                            <span class="at">newdata=</span><span class="cn">NULL</span>, <span class="at">newparams=</span><span class="cn">NULL</span>,</span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>                            <span class="at">family=</span><span class="cn">NULL</span>,</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>                            <span class="at">allow.new.levels=</span><span class="cn">FALSE</span>, <span class="at">na.action=</span>na.pass, ...) {</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>    <span class="do">## </span><span class="al">FIXME</span><span class="do">: is there a reason this can&#39;t be a copy of .simulateFun ... ?</span></span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    mc <span class="ot">&lt;-</span> <span class="fu">match.call</span>()</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>    mc[[<span class="dv">1</span>]] <span class="ot">&lt;-</span> <span class="fu">quote</span>(lme4<span class="sc">::</span>.simulateFun)</span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>    <span class="fu">eval</span>(mc, <span class="fu">parent.frame</span>(<span class="dv">1</span><span class="dt">L</span>))</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>}</span></code></pre></div>
<p>Overriding the <code>family</code> seems pretty wild, but you
can!</p>
<p>Although the package is called <code>lme4</code> and its central
classes are <code>S4</code> classes, there is heavy use of the
<code>S3</code> calling conventions. There are <code>simulate.xxx</code>
for other object types, mostly <code>lme4</code> variants of formula
formulae with different data types. I presume the generic
<code>simulate()</code> function it is extending is <code>S3</code>.</p>
<p>Because this calls <code>.simulateFun()</code> in explicit model
scope there is no easy way to override the inner call with a function of
my choosing.</p>
<p>There is no <code>Roxygen2</code> documentation attached to these
<code>simulate.*()</code> methods, which are piggy-backing on the
existing, generic documentation. However, these variants take arguments
which are not part of the standard (except as <code>...</code>). The
next subsection discusses them. There is user documentation on these
functions; I guess it was written by hand.</p>
<p>In case you’re wondering what this code is doing in
<code>predict.R</code>, one of the things the simulation does is to call
<code>predict()</code>. It then generates additional randomness around
that.</p>
<div id="puzzle" class="section level3">
<h3>Puzzle</h3>
<p>The function definition above includes some arguments without
defaults <strong>after</strong> arguments with defaults. I thought that
was illegal; is it <code>S3</code> specific? Seems unlikely since it
uses the general <code>R</code> function definition syntax. Maybe I have
it mixed up with another language.</p>
</div>
</div>
<div id="random-effects-options" class="section level2">
<h2>Random Effects Options</h2>
<p>To simplify, there are two ways to handle cluster random effects:
ignore the estimated values or use them. The default behavior, which can
be explicitly specified with <code>re.form = NULL</code>, is to
condition on all random effects. I think this means to use their mode
when generating the central value for the cluster. Alternatively, to
simulate fresh, use <code>re.form = ~0</code> or
<code>re.form = NA</code>. The latter is what <code>simulate()</code>
does.</p>
<p>I think if you request a simulation with a new dataset you always get
the “start at 0” behavior, but that may depend on whether the new data
shares ids with the old one. If you have new ids you must call with
<code>allow.new.levels = TRUE</code>, which is not the default.</p>
<p>One can condition on only some of the random effects by giving
<code>re.form</code> as a formula with only some of the random effects
terms in it. The the variables mentioned will be conditioned on. In that
case the formula may need to specify the random effects syntax
explicitly, like <code>b | id</code>; the documentation is unclear about
whether one can just mention the random effects variables, e.g.,
<code>~id</code> if <code>id</code> has random effects.</p>
<p><code>re.form</code> is the only non-deprecated way to specify
handling of the random effects choice for cluster means. Whether to
allow for sloppy typing or historical compatibility, there are
alternatives. One can use <code>ReForm</code>, <code>REForm</code>, and
<code>REform</code> instead. Or one can give the <code>use.u</code>
argument. If <code>use.u</code> is <code>FALSE</code>, the default,
generate new random effects values; if <code>TRUE</code> use current
estimates. So <code>TRUE</code> is equivalent to
<code>re.form = NULL</code>, and <code>FALSE</code> to
<code>re.form = ~0</code>.</p>
<p>With all these alternatives one wonders what happens if one uses
several of them, perhaps with contradictory settings. For
<code>re.form</code> this is mostly delegated to the following:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>reFormHack <span class="ot">&lt;-</span> <span class="cf">function</span>(re.form,ReForm,REForm,REform) {</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>    warnDeprec <span class="ot">&lt;-</span> <span class="cf">function</span>(name)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>        <span class="fu">warning</span>(<span class="fu">gettextf</span>(<span class="st">&quot;&#39;%s&#39; is deprecated; use &#39;%s&#39; instead&quot;</span>, name, <span class="st">&quot;re.form&quot;</span>),</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>                <span class="at">call.=</span><span class="cn">FALSE</span>, <span class="at">domain=</span><span class="cn">NA</span>)</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">missing</span>(ReForm)) {</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>        <span class="fu">warnDeprec</span>(<span class="st">&quot;ReForm&quot;</span>)</span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>        <span class="fu">return</span>(ReForm)</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>    }</span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">missing</span>(REForm)) {</span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a>        <span class="fu">warnDeprec</span>(<span class="st">&quot;REForm&quot;</span>)</span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a>        <span class="fu">return</span>(REForm)</span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a>    }</span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">missing</span>(REform)) {</span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a>        <span class="fu">warnDeprec</span>(<span class="st">&quot;REform&quot;</span>)</span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a>        <span class="fu">return</span>(REform)</span>
<span id="cb3-16"><a href="#cb3-16" tabindex="-1"></a>    }</span>
<span id="cb3-17"><a href="#cb3-17" tabindex="-1"></a>    re.form</span>
<span id="cb3-18"><a href="#cb3-18" tabindex="-1"></a>}</span></code></pre></div>
<p>So <code>ReForm</code> controls if present, else <code>REForm</code>,
else <code>REform</code>, else <code>re.form</code>. Which seems odd
given that <code>re.form</code> is canonical … Also, there are
deprecation warnings for the alternate forms, but no warning if more
than one argument is supplied, or if contradictory arguments are
supplied.</p>
<p>The next fragment of <code>.simulateFun()</code> handles
<code>use.u</code>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>    re.form.miss <span class="ot">&lt;-</span> <span class="fu">missing</span>(re.form)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>    re.form <span class="ot">&lt;-</span> <span class="fu">reFormHack</span>(re.form,ReForm,REForm,REform)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">missing</span>(use.u)) {</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span>re.form.miss) {</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>            <span class="fu">stop</span>(<span class="st">&quot;should specify only one of &quot;</span>,<span class="fu">sQuote</span>(<span class="st">&quot;use.u&quot;</span>),</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>                 <span class="st">&quot; and &quot;</span>,<span class="fu">sQuote</span>(<span class="st">&quot;re.form&quot;</span>))</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>        }</span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a>        re.form <span class="ot">&lt;-</span> <span class="cf">if</span> (use.u) <span class="cn">NULL</span> <span class="cf">else</span> <span class="sc">~</span><span class="dv">0</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a>    }</span></code></pre></div>
<p>So it is an error to use both <code>re.form</code> and
<code>use.u</code> arguments (though apparently <code>ReForm</code> and
other variants could be specified and will be ignored if
<code>use.u</code> is present). <code>use.u</code> is translated to
<code>re.form</code> of <code>NULL</code> or <code>~0</code> for later
processing.</p>
</div>
<div id="initial-processing" class="section level2">
<h2>Initial Processing</h2>
<p>This gives the signature of the “inner” function that does the actual
work. As noted above, this function is exported despite a name
suggesting it shouldn’t be used by outsiders!</p>
<p>The initial processing checks some argument consistency, and extracts
the weights.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>.simulateFun <span class="ot">&lt;-</span> <span class="cf">function</span>(object, <span class="at">nsim =</span> <span class="dv">1</span>, <span class="at">seed =</span> <span class="cn">NULL</span>, <span class="at">use.u =</span> <span class="cn">FALSE</span>,</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>                         <span class="at">re.form=</span><span class="cn">NA</span>, ReForm, REForm, REform,</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>                         <span class="at">newdata=</span><span class="cn">NULL</span>, <span class="at">newparams=</span><span class="cn">NULL</span>,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>                         <span class="at">formula=</span><span class="cn">NULL</span>,<span class="at">family=</span><span class="cn">NULL</span>,</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>                         <span class="at">weights=</span><span class="cn">NULL</span>,</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>                         <span class="at">offset=</span><span class="cn">NULL</span>,</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>                         <span class="at">allow.new.levels=</span><span class="cn">FALSE</span>,</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>                         <span class="at">na.action=</span>na.pass,</span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>                         <span class="at">cond.sim=</span><span class="cn">TRUE</span>,</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>                         ...) {</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a></span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">...length</span>() <span class="sc">&gt;</span> <span class="dv">0</span>) <span class="fu">warning</span>(<span class="st">&quot;unused arguments ignored&quot;</span>)</span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">missing</span>(object) <span class="sc">&amp;&amp;</span> (<span class="fu">is.null</span>(formula) <span class="sc">||</span> <span class="fu">is.null</span>(newdata) <span class="sc">||</span> <span class="fu">is.null</span>(newparams))) {</span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a>        <span class="fu">stop</span>(<span class="st">&quot;if &quot;</span>,<span class="fu">sQuote</span>(<span class="st">&quot;object&quot;</span>),<span class="st">&quot; is missing, must specify all of &quot;</span>,</span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>             <span class="fu">sQuote</span>(<span class="st">&quot;formula&quot;</span>),<span class="st">&quot;, &quot;</span>,<span class="fu">sQuote</span>(<span class="st">&quot;newdata&quot;</span>),<span class="st">&quot;, and &quot;</span>,</span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>             <span class="fu">sQuote</span>(<span class="st">&quot;newparams&quot;</span>))</span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>    }</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a></span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>    nullWts <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(weights)) {</span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.null</span>(newdata)) {</span>
<span id="cb5-23"><a href="#cb5-23" tabindex="-1"></a>            weights <span class="ot">&lt;-</span> <span class="fu">weights</span>(object)</span>
<span id="cb5-24"><a href="#cb5-24" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb5-25"><a href="#cb5-25" tabindex="-1"></a>            nullWts <span class="ot">&lt;-</span> <span class="cn">TRUE</span> <span class="co"># this flags that &#39;weights&#39; wasn&#39;t supplied by the user</span></span>
<span id="cb5-26"><a href="#cb5-26" tabindex="-1"></a>            weights <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">1</span>,<span class="fu">nrow</span>(newdata))</span>
<span id="cb5-27"><a href="#cb5-27" tabindex="-1"></a>        }</span>
<span id="cb5-28"><a href="#cb5-28" tabindex="-1"></a>    }</span></code></pre></div>
<p>Yes, the initial <code>{</code> is unclosed; a lot remains.</p>
</div>
<div id="construct-glmod-etc" class="section level2">
<h2>Construct <code>glmod</code> etc</h2>
<p>The next block of code has a branch we don’t care about:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">missing</span>(object)) {</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>        <span class="do">## construct fake-fitted object from data, params</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>        <span class="do">## copied from glm(): DRY; this all stems from the</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>        <span class="do">## original sin of handling family=gaussian as a special</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>        <span class="do">## case</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.character</span>(family))</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>            family <span class="ot">&lt;-</span> <span class="fu">get</span>(family, <span class="at">mode =</span> <span class="st">&quot;function&quot;</span>, <span class="at">envir =</span> <span class="fu">parent.frame</span>())</span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.function</span>(family))</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>            family <span class="ot">&lt;-</span> <span class="fu">family</span>()</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.null</span>(family) <span class="sc">||</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>            (family<span class="sc">$</span>family<span class="sc">==</span><span class="st">&quot;gaussian&quot;</span> <span class="sc">&amp;&amp;</span> family<span class="sc">$</span>link<span class="sc">==</span><span class="st">&quot;identity&quot;</span>)) {</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>            lmod <span class="ot">&lt;-</span> <span class="fu">lFormula</span>(formula,newdata,</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>                             <span class="at">weights=</span>weights,</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>                             <span class="at">offset=</span>offset,</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>                             <span class="at">control=</span><span class="fu">lmerControl</span>(<span class="at">check.formula.LHS=</span><span class="st">&quot;ignore&quot;</span>))</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>            devfun <span class="ot">&lt;-</span> <span class="fu">do.call</span>(mkLmerDevfun, lmod)</span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a>            object <span class="ot">&lt;-</span> <span class="fu">mkMerMod</span>(<span class="fu">environment</span>(devfun),</span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a>                               <span class="do">## (real parameters will be filled in later)</span></span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a>                               <span class="at">opt =</span> <span class="fu">list</span>(<span class="at">par=</span><span class="cn">NA</span>,<span class="at">fval=</span><span class="cn">NA</span>,<span class="at">conv=</span><span class="cn">NA</span>),</span>
<span id="cb6-21"><a href="#cb6-21" tabindex="-1"></a>                               lmod<span class="sc">$</span>reTrms, <span class="at">fr =</span> lmod<span class="sc">$</span>fr)</span>
<span id="cb6-22"><a href="#cb6-22" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb6-23"><a href="#cb6-23" tabindex="-1"></a>            glmod <span class="ot">&lt;-</span> <span class="fu">glFormula</span>(formula,newdata,<span class="at">family=</span>family,</span>
<span id="cb6-24"><a href="#cb6-24" tabindex="-1"></a>                               <span class="at">weights=</span>weights,</span>
<span id="cb6-25"><a href="#cb6-25" tabindex="-1"></a>                               <span class="at">offset=</span>offset,</span>
<span id="cb6-26"><a href="#cb6-26" tabindex="-1"></a>                               <span class="at">control=</span><span class="fu">glmerControl</span>(<span class="at">check.formula.LHS=</span><span class="st">&quot;ignore&quot;</span>))</span>
<span id="cb6-27"><a href="#cb6-27" tabindex="-1"></a>            devfun <span class="ot">&lt;-</span> <span class="fu">do.call</span>(mkGlmerDevfun, glmod)</span>
<span id="cb6-28"><a href="#cb6-28" tabindex="-1"></a>            object <span class="ot">&lt;-</span> <span class="fu">mkMerMod</span>(<span class="fu">environment</span>(devfun),</span>
<span id="cb6-29"><a href="#cb6-29" tabindex="-1"></a>                               <span class="do">## (real parameters will be filled in later)</span></span>
<span id="cb6-30"><a href="#cb6-30" tabindex="-1"></a>                               <span class="at">opt =</span> <span class="fu">list</span>(<span class="at">par=</span><span class="cn">NA</span>,<span class="at">fval=</span><span class="cn">NA</span>,<span class="at">conv=</span><span class="cn">NA</span>),</span>
<span id="cb6-31"><a href="#cb6-31" tabindex="-1"></a>                               glmod<span class="sc">$</span>reTrms, <span class="at">fr =</span> glmod<span class="sc">$</span>fr)</span>
<span id="cb6-32"><a href="#cb6-32" tabindex="-1"></a>        }</span>
<span id="cb6-33"><a href="#cb6-33" tabindex="-1"></a>        <span class="do">## would like to do this:</span></span>
<span id="cb6-34"><a href="#cb6-34" tabindex="-1"></a>        <span class="do">## so predict() -&gt; fitted() -&gt; set default names will work</span></span>
<span id="cb6-35"><a href="#cb6-35" tabindex="-1"></a>        <span class="do">## instead we have a special case in fitted()</span></span>
<span id="cb6-36"><a href="#cb6-36" tabindex="-1"></a>        <span class="do">## object@resp$mu &lt;- rep(NA_real_,nrow(model.frame(object)))</span></span>
<span id="cb6-37"><a href="#cb6-37" tabindex="-1"></a>    }</span></code></pre></div>
<p>For reference, the next section has <code>mkMerMod()</code>, even
though it looks as if we don’t go through either path that calls it.
Those are the only 2 calls to it in <code>predict.R</code>.</p>
</div>
<div id="mkmermod" class="section level2">
<h2><code>mkMerMod()</code></h2>
<p>This function is defined in <code>utilities.R</code>. The code path
above that calls it is not active for our typical use.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="do">##--&gt; ../man/mkMerMod.Rd ---Create a merMod object</span></span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="do">##&#39; @param rho the environment of the objective function</span></span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="do">##&#39; @param opt the value returned by the optimizer</span></span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a><span class="do">##&#39; @param reTrms reTrms list from the calling function</span></span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>mkMerMod <span class="ot">&lt;-</span> <span class="cf">function</span>(rho, opt, reTrms, fr, mc, <span class="at">lme4conv=</span><span class="cn">NULL</span>) {</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">missing</span>(mc)) mc <span class="ot">&lt;-</span> <span class="fu">match.call</span>()</span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a>    <span class="fu">stopifnot</span>(<span class="fu">is.environment</span>(rho),</span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a>              <span class="fu">is</span>(pp <span class="ot">&lt;-</span> rho<span class="sc">$</span>pp, <span class="st">&quot;merPredD&quot;</span>),</span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a>              <span class="fu">is</span>(resp <span class="ot">&lt;-</span> rho<span class="sc">$</span>resp, <span class="st">&quot;lmResp&quot;</span>),</span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a>              <span class="fu">is.list</span>(opt), <span class="st">&quot;par&quot;</span> <span class="sc">%in%</span> <span class="fu">names</span>(opt),</span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a>              <span class="fu">c</span>(<span class="st">&quot;conv&quot;</span>, <span class="st">&quot;fval&quot;</span>) <span class="sc">%in%</span> <span class="fu">substr</span>(<span class="fu">names</span>(opt),<span class="dv">1</span>,<span class="dv">4</span>), <span class="do">## &quot;conv[ergence]&quot;, &quot;fval[ues]&quot;</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a>              <span class="fu">is.list</span>(reTrms), <span class="fu">c</span>(<span class="st">&quot;flist&quot;</span>, <span class="st">&quot;cnms&quot;</span>, <span class="st">&quot;Gp&quot;</span>, <span class="st">&quot;lower&quot;</span>) <span class="sc">%in%</span> <span class="fu">names</span>(reTrms),</span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a>              <span class="fu">length</span>(rcl <span class="ot">&lt;-</span> <span class="fu">class</span>(resp)) <span class="sc">==</span> <span class="dv">1</span>)</span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a>    n    <span class="ot">&lt;-</span> <span class="fu">nrow</span>(pp<span class="sc">$</span>V)</span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a>    p    <span class="ot">&lt;-</span> <span class="fu">ncol</span>(pp<span class="sc">$</span>V)</span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a>    isGLMM <span class="ot">&lt;-</span> (rcl <span class="sc">==</span> <span class="st">&quot;glmResp&quot;</span>)</span>
<span id="cb7-17"><a href="#cb7-17" tabindex="-1"></a>    dims <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="at">N =</span> <span class="fu">nrow</span>(pp<span class="sc">$</span>X), <span class="at">n=</span>n, <span class="at">p=</span>p, <span class="at">nmp =</span> n<span class="sc">-</span>p, <span class="at">q =</span> <span class="fu">nrow</span>(pp<span class="sc">$</span>Zt),</span>
<span id="cb7-18"><a href="#cb7-18" tabindex="-1"></a>              <span class="at">nth =</span> <span class="fu">length</span>(pp<span class="sc">$</span>theta),</span>
<span id="cb7-19"><a href="#cb7-19" tabindex="-1"></a>              <span class="at">nAGQ=</span> rho<span class="sc">$</span>nAGQ,</span>
<span id="cb7-20"><a href="#cb7-20" tabindex="-1"></a>              <span class="at">compDev=</span>rho<span class="sc">$</span>compDev,</span>
<span id="cb7-21"><a href="#cb7-21" tabindex="-1"></a>              <span class="do">## &#39;use scale&#39; in the sense of whether dispersion parameter should</span></span>
<span id="cb7-22"><a href="#cb7-22" tabindex="-1"></a>              <span class="do">##  be reported/used (*not* whether theta should be scaled by sigma)</span></span>
<span id="cb7-23"><a href="#cb7-23" tabindex="-1"></a>              <span class="at">useSc =</span> <span class="sc">!</span>(isGLMM <span class="sc">&amp;&amp;</span> <span class="fu">hasNoScale</span>(resp<span class="sc">$</span>family)),</span>
<span id="cb7-24"><a href="#cb7-24" tabindex="-1"></a>              <span class="at">reTrms=</span><span class="fu">length</span>(reTrms<span class="sc">$</span>cnms),</span>
<span id="cb7-25"><a href="#cb7-25" tabindex="-1"></a>              <span class="at">spFe=</span> <span class="dv">0</span><span class="dt">L</span>,</span>
<span id="cb7-26"><a href="#cb7-26" tabindex="-1"></a>              <span class="at">REML =</span> <span class="cf">if</span> (rcl<span class="sc">==</span><span class="st">&quot;lmerResp&quot;</span>) resp<span class="sc">$</span>REML <span class="cf">else</span> <span class="dv">0</span><span class="dt">L</span>,</span>
<span id="cb7-27"><a href="#cb7-27" tabindex="-1"></a>              <span class="at">GLMM=</span> isGLMM,</span>
<span id="cb7-28"><a href="#cb7-28" tabindex="-1"></a>              <span class="at">NLMM=</span> (rcl<span class="sc">==</span><span class="st">&quot;nlsResp&quot;</span>))</span>
<span id="cb7-29"><a href="#cb7-29" tabindex="-1"></a>    <span class="fu">storage.mode</span>(dims) <span class="ot">&lt;-</span> <span class="st">&quot;integer&quot;</span></span>
<span id="cb7-30"><a href="#cb7-30" tabindex="-1"></a>    fac     <span class="ot">&lt;-</span> <span class="fu">as.numeric</span>(rcl <span class="sc">!=</span> <span class="st">&quot;nlsResp&quot;</span>)</span>
<span id="cb7-31"><a href="#cb7-31" tabindex="-1"></a>    <span class="cf">if</span> (trivial.y <span class="ot">&lt;-</span> (<span class="fu">length</span>(resp<span class="sc">$</span>y)<span class="sc">==</span><span class="dv">0</span>)) {</span>
<span id="cb7-32"><a href="#cb7-32" tabindex="-1"></a>        <span class="do">## trivial model</span></span>
<span id="cb7-33"><a href="#cb7-33" tabindex="-1"></a>        sqrLenU <span class="ot">&lt;-</span> wrss <span class="ot">&lt;-</span> pwrss <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb7-34"><a href="#cb7-34" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb7-35"><a href="#cb7-35" tabindex="-1"></a>        sqrLenU <span class="ot">&lt;-</span> pp<span class="sc">$</span><span class="fu">sqrL</span>(fac)</span>
<span id="cb7-36"><a href="#cb7-36" tabindex="-1"></a>        wrss    <span class="ot">&lt;-</span> resp<span class="sc">$</span><span class="fu">wrss</span>()</span>
<span id="cb7-37"><a href="#cb7-37" tabindex="-1"></a>        pwrss   <span class="ot">&lt;-</span> wrss <span class="sc">+</span> sqrLenU</span>
<span id="cb7-38"><a href="#cb7-38" tabindex="-1"></a>    }</span>
<span id="cb7-39"><a href="#cb7-39" tabindex="-1"></a>    <span class="do">## weights &lt;- resp$weights</span></span>
<span id="cb7-40"><a href="#cb7-40" tabindex="-1"></a>    beta    <span class="ot">&lt;-</span> pp<span class="sc">$</span><span class="fu">beta</span>(fac)</span>
<span id="cb7-41"><a href="#cb7-41" tabindex="-1"></a>    <span class="do">## rescale</span></span>
<span id="cb7-42"><a href="#cb7-42" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(sc <span class="ot">&lt;-</span> <span class="fu">attr</span>(pp<span class="sc">$</span>X, <span class="st">&quot;scaled:scale&quot;</span>))) {</span>
<span id="cb7-43"><a href="#cb7-43" tabindex="-1"></a>        <span class="fu">warning</span>(<span class="st">&quot;auto(un)scaling not yet finished/tested&quot;</span>)</span>
<span id="cb7-44"><a href="#cb7-44" tabindex="-1"></a>        <span class="do">## </span><span class="al">FIXME</span><span class="do">: test/handle no-intercept models</span></span>
<span id="cb7-45"><a href="#cb7-45" tabindex="-1"></a>        <span class="do">##   (only need to worry if we do centering as well as scaling)</span></span>
<span id="cb7-46"><a href="#cb7-46" tabindex="-1"></a>        <span class="do">## </span><span class="al">FIXME</span><span class="do">: adjust Hessian/vcov</span></span>
<span id="cb7-47"><a href="#cb7-47" tabindex="-1"></a>        <span class="do">## </span><span class="al">FIXME</span><span class="do">: where else will these changes propagate?</span></span>
<span id="cb7-48"><a href="#cb7-48" tabindex="-1"></a>        <span class="do">##        profiling?</span></span>
<span id="cb7-49"><a href="#cb7-49" tabindex="-1"></a>        beta2 <span class="ot">&lt;-</span> beta</span>
<span id="cb7-50"><a href="#cb7-50" tabindex="-1"></a>        beta2[<span class="fu">names</span>(sc)] <span class="ot">&lt;-</span> sc<span class="sc">*</span>beta2[<span class="fu">names</span>(sc)]</span>
<span id="cb7-51"><a href="#cb7-51" tabindex="-1"></a>        beta <span class="ot">&lt;-</span> beta2</span>
<span id="cb7-52"><a href="#cb7-52" tabindex="-1"></a>    }</span>
<span id="cb7-53"><a href="#cb7-53" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(<span class="fu">attr</span>(pp<span class="sc">$</span>X, <span class="st">&quot;scaled:center&quot;</span>))) {</span>
<span id="cb7-54"><a href="#cb7-54" tabindex="-1"></a>        <span class="fu">warning</span>(<span class="st">&quot;auto(un)centering not yet implemented&quot;</span>)</span>
<span id="cb7-55"><a href="#cb7-55" tabindex="-1"></a>    }</span>
<span id="cb7-56"><a href="#cb7-56" tabindex="-1"></a>    <span class="co">#sigmaML &lt;- pwrss/sum(weights)</span></span>
<span id="cb7-57"><a href="#cb7-57" tabindex="-1"></a>    sigmaML <span class="ot">&lt;-</span> pwrss<span class="sc">/</span>n</span>
<span id="cb7-58"><a href="#cb7-58" tabindex="-1"></a>    <span class="cf">if</span> (rcl <span class="sc">!=</span> <span class="st">&quot;lmerResp&quot;</span>) {</span>
<span id="cb7-59"><a href="#cb7-59" tabindex="-1"></a>        pars <span class="ot">&lt;-</span> opt<span class="sc">$</span>par</span>
<span id="cb7-60"><a href="#cb7-60" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">length</span>(pars) <span class="sc">&gt;</span> <span class="fu">length</span>(pp<span class="sc">$</span>theta)) beta <span class="ot">&lt;-</span> pars[<span class="sc">-</span>(<span class="fu">seq_along</span>(pp<span class="sc">$</span>theta))]</span>
<span id="cb7-61"><a href="#cb7-61" tabindex="-1"></a>    }</span>
<span id="cb7-62"><a href="#cb7-62" tabindex="-1"></a>    cmp <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="at">ldL2=</span>pp<span class="sc">$</span><span class="fu">ldL2</span>(), <span class="at">ldRX2=</span>pp<span class="sc">$</span><span class="fu">ldRX2</span>(), <span class="at">wrss=</span>wrss,</span>
<span id="cb7-63"><a href="#cb7-63" tabindex="-1"></a>             <span class="at">ussq=</span>sqrLenU, <span class="at">pwrss=</span>pwrss,</span>
<span id="cb7-64"><a href="#cb7-64" tabindex="-1"></a>             <span class="at">drsum=</span><span class="cf">if</span> (rcl<span class="sc">==</span><span class="st">&quot;glmResp&quot;</span> <span class="sc">&amp;&amp;</span> <span class="sc">!</span>trivial.y) resp<span class="sc">$</span><span class="fu">resDev</span>() <span class="cf">else</span> <span class="cn">NA</span>,</span>
<span id="cb7-65"><a href="#cb7-65" tabindex="-1"></a>             <span class="at">REML=</span><span class="cf">if</span> (rcl<span class="sc">==</span><span class="st">&quot;lmerResp&quot;</span> <span class="sc">&amp;&amp;</span> resp<span class="sc">$</span>REML <span class="sc">!=</span> <span class="dv">0</span><span class="dt">L</span> <span class="sc">&amp;&amp;</span> <span class="sc">!</span>trivial.y)</span>
<span id="cb7-66"><a href="#cb7-66" tabindex="-1"></a>                  opt<span class="sc">$</span>fval <span class="cf">else</span> <span class="cn">NA</span>,</span>
<span id="cb7-67"><a href="#cb7-67" tabindex="-1"></a>             <span class="do">## </span><span class="al">FIXME</span><span class="do">: construct &#39;REML deviance&#39; here?</span></span>
<span id="cb7-68"><a href="#cb7-68" tabindex="-1"></a>             <span class="at">dev=</span><span class="cf">if</span> (rcl<span class="sc">==</span><span class="st">&quot;lmerResp&quot;</span> <span class="sc">&amp;&amp;</span> resp<span class="sc">$</span>REML <span class="sc">!=</span> <span class="dv">0</span><span class="dt">L</span> <span class="sc">||</span> trivial.y) <span class="cn">NA</span> <span class="cf">else</span> opt<span class="sc">$</span>fval,</span>
<span id="cb7-69"><a href="#cb7-69" tabindex="-1"></a>             <span class="at">sigmaML=</span><span class="fu">sqrt</span>(<span class="fu">unname</span>(<span class="cf">if</span> (<span class="sc">!</span>dims[<span class="st">&quot;useSc&quot;</span>] <span class="sc">||</span> trivial.y) <span class="cn">NA</span> <span class="cf">else</span> sigmaML)),</span>
<span id="cb7-70"><a href="#cb7-70" tabindex="-1"></a>             <span class="at">sigmaREML=</span><span class="fu">sqrt</span>(<span class="fu">unname</span>(<span class="cf">if</span> (rcl<span class="sc">!=</span><span class="st">&quot;lmerResp&quot;</span> <span class="sc">||</span> trivial.y) <span class="cn">NA</span> <span class="cf">else</span></span>
<span id="cb7-71"><a href="#cb7-71" tabindex="-1"></a>                                   sigmaML<span class="sc">*</span>(dims[<span class="st">&#39;n&#39;</span>]<span class="sc">/</span>dims[<span class="st">&#39;nmp&#39;</span>]))),</span>
<span id="cb7-72"><a href="#cb7-72" tabindex="-1"></a>             <span class="at">tolPwrss=</span>rho<span class="sc">$</span>tolPwrss)</span>
<span id="cb7-73"><a href="#cb7-73" tabindex="-1"></a>    <span class="do">## </span><span class="al">TODO</span><span class="do">:  improve this hack to get something in frame slot (maybe need weights, etc...)</span></span>
<span id="cb7-74"><a href="#cb7-74" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">missing</span>(fr)) fr <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(resp<span class="sc">$</span>y)</span>
<span id="cb7-75"><a href="#cb7-75" tabindex="-1"></a>    <span class="fu">new</span>(<span class="cf">switch</span>(rcl, <span class="at">lmerResp =</span> <span class="st">&quot;lmerMod&quot;</span>, <span class="at">glmResp =</span> <span class="st">&quot;glmerMod&quot;</span>, <span class="at">nlsResp =</span> <span class="st">&quot;nlmerMod&quot;</span>),</span>
<span id="cb7-76"><a href="#cb7-76" tabindex="-1"></a>        <span class="at">call=</span>mc, <span class="at">frame=</span>fr, <span class="at">flist=</span>reTrms<span class="sc">$</span>flist, <span class="at">cnms=</span>reTrms<span class="sc">$</span>cnms,</span>
<span id="cb7-77"><a href="#cb7-77" tabindex="-1"></a>        <span class="at">Gp=</span>reTrms<span class="sc">$</span>Gp, <span class="at">theta=</span>pp<span class="sc">$</span>theta, <span class="at">beta=</span>beta,</span>
<span id="cb7-78"><a href="#cb7-78" tabindex="-1"></a>        <span class="at">u=</span><span class="cf">if</span> (trivial.y) <span class="fu">rep</span>(<span class="cn">NA_real_</span>,<span class="fu">nrow</span>(pp<span class="sc">$</span>Zt)) <span class="cf">else</span> pp<span class="sc">$</span><span class="fu">u</span>(fac),</span>
<span id="cb7-79"><a href="#cb7-79" tabindex="-1"></a>        <span class="at">lower=</span>reTrms<span class="sc">$</span>lower, <span class="at">devcomp=</span><span class="fu">list</span>(<span class="at">cmp=</span>cmp, <span class="at">dims=</span>dims),</span>
<span id="cb7-80"><a href="#cb7-80" tabindex="-1"></a>        <span class="at">pp=</span>pp, <span class="at">resp=</span>resp,</span>
<span id="cb7-81"><a href="#cb7-81" tabindex="-1"></a>        <span class="at">optinfo =</span> <span class="fu">.optinfo</span>(opt, lme4conv))</span>
<span id="cb7-82"><a href="#cb7-82" tabindex="-1"></a>}<span class="do">## {mkMerMod}</span></span></code></pre></div>
</div>
<div id="random-effects-and-other-housekeeping" class="section level2">
<h2>Random Effects and Other Housekeeping</h2>
<p>Most of this code was shown in the earlier discussion of random
effects specification. This also overrides the parameters in
<code>object</code> if we set new ones (we don’t).</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">stopifnot</span>((nsim <span class="ot">&lt;-</span> <span class="fu">as.integer</span>(nsim[<span class="dv">1</span>])) <span class="sc">&gt;</span> <span class="dv">0</span>,</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>              <span class="fu">is</span>(object, <span class="st">&quot;merMod&quot;</span>))</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(newparams)) {</span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a>        object <span class="ot">&lt;-</span> <span class="fu">setParams</span>(object,newparams)</span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a>    }</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a></span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>    <span class="do">## need to save this before we reset re.form</span></span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>    re.form.miss <span class="ot">&lt;-</span> <span class="fu">missing</span>(re.form)</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>    re.form <span class="ot">&lt;-</span> <span class="fu">reFormHack</span>(re.form,ReForm,REForm,REform)</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a></span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">missing</span>(use.u)) {</span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span>re.form.miss) {</span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a>            <span class="fu">stop</span>(<span class="st">&quot;should specify only one of &quot;</span>,<span class="fu">sQuote</span>(<span class="st">&quot;use.u&quot;</span>),</span>
<span id="cb8-14"><a href="#cb8-14" tabindex="-1"></a>                 <span class="st">&quot; and &quot;</span>,<span class="fu">sQuote</span>(<span class="st">&quot;re.form&quot;</span>))</span>
<span id="cb8-15"><a href="#cb8-15" tabindex="-1"></a>        }</span>
<span id="cb8-16"><a href="#cb8-16" tabindex="-1"></a>        re.form <span class="ot">&lt;-</span> <span class="cf">if</span> (use.u) <span class="cn">NULL</span> <span class="cf">else</span> <span class="sc">~</span><span class="dv">0</span></span>
<span id="cb8-17"><a href="#cb8-17" tabindex="-1"></a>    }</span>
<span id="cb8-18"><a href="#cb8-18" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(re.form)) { <span class="co"># formula w/o response</span></span>
<span id="cb8-19"><a href="#cb8-19" tabindex="-1"></a>        re.form <span class="ot">&lt;-</span> <span class="fu">reOnly</span>(<span class="fu">formula</span>(object))</span>
<span id="cb8-20"><a href="#cb8-20" tabindex="-1"></a>    }</span>
<span id="cb8-21"><a href="#cb8-21" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.null</span>(seed)) <span class="fu">set.seed</span>(seed)</span>
<span id="cb8-22"><a href="#cb8-22" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">exists</span>(<span class="st">&quot;.Random.seed&quot;</span>, <span class="at">envir =</span> .GlobalEnv))</span>
<span id="cb8-23"><a href="#cb8-23" tabindex="-1"></a>        <span class="fu">runif</span>(<span class="dv">1</span>) <span class="co"># initialize the RNG if necessary</span></span>
<span id="cb8-24"><a href="#cb8-24" tabindex="-1"></a>    RNGstate <span class="ot">&lt;-</span> .Random.seed</span>
<span id="cb8-25"><a href="#cb8-25" tabindex="-1"></a></span>
<span id="cb8-26"><a href="#cb8-26" tabindex="-1"></a>    sigma <span class="ot">&lt;-</span> <span class="fu">sigma</span>(object)</span>
<span id="cb8-27"><a href="#cb8-27" tabindex="-1"></a>    <span class="do">## OBSOLETE: no longer use X?</span></span>
<span id="cb8-28"><a href="#cb8-28" tabindex="-1"></a>    <span class="do">## n &lt;- nrow(X &lt;- getME(object, &quot;X&quot;))</span></span>
<span id="cb8-29"><a href="#cb8-29" tabindex="-1"></a>    <span class="do">## link &lt;- if (isGLMM(object)) &quot;response&quot;</span></span></code></pre></div>
<p>The final sigma is for the within cluster variability, <span class="math inline">\(\sigma_\epsilon\)</span>. On my default run,
<code>re.form == NA</code> at this point.
<code>re.form.miss == TRUE</code>.</p>
</div>
<div id="eta-finally-something-interesting" class="section level2">
<h2><span class="math inline">\(\eta\)</span>: Finally Something
Interesting</h2>
<p>Finally we are ready for our first cut at the <span class="math inline">\(\eta\)</span> values. These incorporate the fixed
effects <em>and</em> the cluster random effects in some way, depending
on options selected. This is basically a call to <code>predict</code> in
<code>lme4</code>.</p>
<p>Questions about <code>etapred</code>, the main output:</p>
<ol style="list-style-type: decimal">
<li>What class is it? “numeric” with names. I believe the names are the
factor levels as strings.</li>
<li>What dimension is it? Choices include number of clusters, number of
individuals in all clusters, or either of those values times the number
of simulations. It’s number of individual observations.</li>
<li>If there are results for multiple simulations, does any part vary
with simulated variation in the random effects? The premise is false:
one value for all simulations.</li>
<li>Does the “link scale” mean the results are in the linear space?
Yes.</li>
</ol>
<p>In my debug session <code>object</code> has class
<code>lmerMod</code>, <code>newData == NULL</code>,
<code>nsim == 1L</code> (not ideal for detecting if the code has a
replication for each simulation), <code>re.form == NA</code> and
<code>allow.new.levels == FALSE</code>. So <code>predict.merMod()</code>
is the exact function called. Since my simple example is intercept-only,
it has no covariates and each value in <code>etapred</code> is the same,
3.461.</p>
<p>Since <code>nsim</code> is not an argument to <code>predict()</code>
below, it appears the number of simulations doesn’t affect the result of
this part. The data have 2691 observations in 68 clusters.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>    <span class="do">## predictions, conditioned as specified, on link scale</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>    <span class="do">## previously: do **NOT** use na.action as specified here (inherit</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>    <span class="do">##     from object instead, for consistency)</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>    <span class="do">## now: use na.omit, because we have to match up</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>    <span class="do">##    with whatever is done in mkNewReTrms</span></span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a>    etapred <span class="ot">&lt;-</span> <span class="fu">predict</span>(object, <span class="at">newdata=</span>newdata, <span class="at">re.form=</span>re.form,</span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a>                       <span class="at">type=</span><span class="st">&quot;link&quot;</span>, <span class="at">na.action=</span>na.omit,</span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a>                       <span class="at">allow.new.levels=</span>allow.new.levels)</span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a>    n <span class="ot">&lt;-</span> <span class="fu">length</span>(etapred)</span></code></pre></div>
</div>
<div id="predict.mermod" class="section level2">
<h2><code>predict.merMod()</code></h2>
<p>Based on that limited testing, <code>predict()</code> simply gives
the fixed effects, with the random effects at 0 in this context. In case
I need details, here they are.</p>
<p>The code is just over 260 lines in the same file. Clearly it does, or
can do, more than give the fixed effects. In particular, it can use the
predicted random effect for each cluster if <code>re.form</code> has
some value other than <code>NA</code> (my case) or <code>~0</code>. It
can also produce crude standard errors for the estimates.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="do">##&#39;</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="do">##&#39; \code{\link{predict}} method for \code{\linkS4class{merMod}} objects</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a><span class="do">##&#39;</span></span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="do">##&#39; @title Predictions from a model at new data values</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="do">##&#39; @param object a fitted model object</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="do">##&#39; @param newdata data frame for which to evaluate predictions</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="do">##&#39; @param newparams new parameters to use in evaluating predictions</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="do">##&#39; @param re.form formula for random effects to condition on.  If \code{NULL},</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="do">##&#39; include all random effects; if \code{NA} or \code{~0},</span></span>
<span id="cb10-10"><a href="#cb10-10" tabindex="-1"></a><span class="do">##&#39; include no random effects</span></span>
<span id="cb10-11"><a href="#cb10-11" tabindex="-1"></a><span class="do">##&#39; @param terms a \code{\link{terms}} object - not used at present</span></span>
<span id="cb10-12"><a href="#cb10-12" tabindex="-1"></a><span class="do">##&#39; @param type character string - either \code{&quot;link&quot;}, the default,</span></span>
<span id="cb10-13"><a href="#cb10-13" tabindex="-1"></a><span class="do">##&#39;    or \code{&quot;response&quot;} indicating the type of prediction object returned</span></span>
<span id="cb10-14"><a href="#cb10-14" tabindex="-1"></a><span class="do">##&#39; @param allow.new.levels (logical) if FALSE (default), then any new levels</span></span>
<span id="cb10-15"><a href="#cb10-15" tabindex="-1"></a><span class="do">##&#39;    (or NA values) detected in \code{newdata} will trigger an error; if TRUE, then</span></span>
<span id="cb10-16"><a href="#cb10-16" tabindex="-1"></a><span class="do">##&#39;    the prediction will use the unconditional (population-level)</span></span>
<span id="cb10-17"><a href="#cb10-17" tabindex="-1"></a><span class="do">##&#39;    values for data with previously unobserved levels (or \code{NA}s)</span></span>
<span id="cb10-18"><a href="#cb10-18" tabindex="-1"></a><span class="do">##&#39; @param na.action function determining what should be done with missing values for fixed effects in \code{newdata}. The default is to predict \code{NA}: see \code{\link{na.pass}}.</span></span>
<span id="cb10-19"><a href="#cb10-19" tabindex="-1"></a><span class="do">##&#39; @param se.fit A logical value indicating whether the standard errors should be included or not. Default is FALSE.</span></span>
<span id="cb10-20"><a href="#cb10-20" tabindex="-1"></a><span class="do">##&#39; @param ... optional additional parameters.  None are used at present.</span></span>
<span id="cb10-21"><a href="#cb10-21" tabindex="-1"></a><span class="do">##&#39; @return a numeric vector of predicted values, unless \code{se.fit=TRUE} (in which case a list with elements \code{fit} (predicted values) and \code{se.fit} is returned)</span></span>
<span id="cb10-22"><a href="#cb10-22" tabindex="-1"></a><span class="do">##&#39; @note There is no option for computing standard errors of predictions because it is difficult to define an efficient method that incorporates uncertainty in the variance parameters; we recommend \code{\link{bootMer}} for this task.</span></span>
<span id="cb10-23"><a href="#cb10-23" tabindex="-1"></a><span class="do">##&#39; @examples</span></span>
<span id="cb10-24"><a href="#cb10-24" tabindex="-1"></a><span class="do">##&#39; (gm1 &lt;- glmer(cbind(incidence, size - incidence) ~ period + (1 |herd), cbpp, binomial))</span></span>
<span id="cb10-25"><a href="#cb10-25" tabindex="-1"></a><span class="do">##&#39; str(p0 &lt;- predict(gm1))            # fitted values</span></span>
<span id="cb10-26"><a href="#cb10-26" tabindex="-1"></a><span class="do">##&#39; str(p1 &lt;- predict(gm1,re.form=NA))  # fitted values, unconditional (level-0)</span></span>
<span id="cb10-27"><a href="#cb10-27" tabindex="-1"></a><span class="do">##&#39; newdata &lt;- with(cbpp, expand.grid(period=unique(period), herd=unique(herd)))</span></span>
<span id="cb10-28"><a href="#cb10-28" tabindex="-1"></a><span class="do">##&#39; str(p2 &lt;- predict(gm1,newdata))    # new data, all RE</span></span>
<span id="cb10-29"><a href="#cb10-29" tabindex="-1"></a><span class="do">##&#39; str(p3 &lt;- predict(gm1,newdata,re.form=NA)) # new data, level-0</span></span>
<span id="cb10-30"><a href="#cb10-30" tabindex="-1"></a><span class="do">##&#39; str(p4 &lt;- predict(gm1,newdata,re.form=~(1|herd))) # explicitly specify RE</span></span>
<span id="cb10-31"><a href="#cb10-31" tabindex="-1"></a><span class="do">##&#39; @method predict merMod</span></span>
<span id="cb10-32"><a href="#cb10-32" tabindex="-1"></a><span class="do">##&#39; @export</span></span>
<span id="cb10-33"><a href="#cb10-33" tabindex="-1"></a>predict.merMod <span class="ot">&lt;-</span> <span class="cf">function</span>(object, <span class="at">newdata=</span><span class="cn">NULL</span>, <span class="at">newparams=</span><span class="cn">NULL</span>,</span>
<span id="cb10-34"><a href="#cb10-34" tabindex="-1"></a>                           <span class="at">re.form=</span><span class="cn">NULL</span>,</span>
<span id="cb10-35"><a href="#cb10-35" tabindex="-1"></a>                           ReForm,</span>
<span id="cb10-36"><a href="#cb10-36" tabindex="-1"></a>                           REForm,</span>
<span id="cb10-37"><a href="#cb10-37" tabindex="-1"></a>                           REform,</span>
<span id="cb10-38"><a href="#cb10-38" tabindex="-1"></a>                           <span class="at">random.only=</span><span class="cn">FALSE</span>,</span>
<span id="cb10-39"><a href="#cb10-39" tabindex="-1"></a>                           <span class="at">terms=</span><span class="cn">NULL</span>, <span class="at">type=</span><span class="fu">c</span>(<span class="st">&quot;link&quot;</span>,<span class="st">&quot;response&quot;</span>),</span>
<span id="cb10-40"><a href="#cb10-40" tabindex="-1"></a>                           <span class="at">allow.new.levels=</span><span class="cn">FALSE</span>, <span class="at">na.action=</span>na.pass,</span>
<span id="cb10-41"><a href="#cb10-41" tabindex="-1"></a>                           <span class="at">se.fit =</span> <span class="cn">FALSE</span>, ...) {</span>
<span id="cb10-42"><a href="#cb10-42" tabindex="-1"></a>    <span class="do">## </span><span class="al">FIXME</span><span class="do">: appropriate names for result vector?</span></span>
<span id="cb10-43"><a href="#cb10-43" tabindex="-1"></a>    <span class="do">## </span><span class="al">FIXME</span><span class="do">: make sure behaviour is entirely well-defined for NA in grouping factors</span></span>
<span id="cb10-44"><a href="#cb10-44" tabindex="-1"></a></span>
<span id="cb10-45"><a href="#cb10-45" tabindex="-1"></a>    <span class="do">## Dealing with NAs:</span></span>
<span id="cb10-46"><a href="#cb10-46" tabindex="-1"></a>    <span class="do">## we might need to distinguish among</span></span>
<span id="cb10-47"><a href="#cb10-47" tabindex="-1"></a>    <span class="do">##  (i) NAs in original data and in new data</span></span>
<span id="cb10-48"><a href="#cb10-48" tabindex="-1"></a>    <span class="do">##  (ii) na.action possibilities (exclude, fail, omit, pass)</span></span>
<span id="cb10-49"><a href="#cb10-49" tabindex="-1"></a>    <span class="do">##  (iii) na.action setting in original fit and in predict()</span></span>
<span id="cb10-50"><a href="#cb10-50" tabindex="-1"></a>    <span class="do">##  (iii) NAs in (fixed effect) predictors vs RE grouping variables</span></span>
<span id="cb10-51"><a href="#cb10-51" tabindex="-1"></a>    <span class="do">##  (iv) setting of allow.new.level</span></span>
<span id="cb10-52"><a href="#cb10-52" tabindex="-1"></a></span>
<span id="cb10-53"><a href="#cb10-53" tabindex="-1"></a>    <span class="do">## NAs in original data (in the fixed or random effects)</span></span>
<span id="cb10-54"><a href="#cb10-54" tabindex="-1"></a>    <span class="do">## may lead to a model frame within the</span></span>
<span id="cb10-55"><a href="#cb10-55" tabindex="-1"></a>    <span class="do">## fitted object that is missing rows; if na.exclude was used,</span></span>
<span id="cb10-56"><a href="#cb10-56" tabindex="-1"></a>    <span class="do">## these will need to be reconstituted in the prediction.</span></span>
<span id="cb10-57"><a href="#cb10-57" tabindex="-1"></a>    <span class="do">##</span></span>
<span id="cb10-58"><a href="#cb10-58" tabindex="-1"></a>    <span class="do">## For the most part, &#39;na.action&#39;s used at the predict stage</span></span>
<span id="cb10-59"><a href="#cb10-59" tabindex="-1"></a>    <span class="do">## (i.e. for newdata) will work on NAs *in the fixed effects*</span></span>
<span id="cb10-60"><a href="#cb10-60" tabindex="-1"></a>    <span class="do">## without further intervention; &#39;na.pass&#39; will automatically</span></span>
<span id="cb10-61"><a href="#cb10-61" tabindex="-1"></a>    <span class="do">## produce NA values in the output, so &#39;na.exclude&#39; is not really</span></span>
<span id="cb10-62"><a href="#cb10-62" tabindex="-1"></a>    <span class="do">## necessary (but might get specified anyway)</span></span>
<span id="cb10-63"><a href="#cb10-63" tabindex="-1"></a>    <span class="do">##</span></span>
<span id="cb10-64"><a href="#cb10-64" tabindex="-1"></a>    <span class="do">## In the random effects, NAs in newdata will give a population-level</span></span>
<span id="cb10-65"><a href="#cb10-65" tabindex="-1"></a>    <span class="do">## prediction if allow.new.levels is TRUE; if it&#39;s FALSE they give</span></span>
<span id="cb10-66"><a href="#cb10-66" tabindex="-1"></a>    <span class="do">## an error (although it could be argued that in that case they</span></span>
<span id="cb10-67"><a href="#cb10-67" tabindex="-1"></a>    <span class="do">## should follow &#39;na.action&#39; instead ...)</span></span>
<span id="cb10-68"><a href="#cb10-68" tabindex="-1"></a></span>
<span id="cb10-69"><a href="#cb10-69" tabindex="-1"></a>    re.form <span class="ot">&lt;-</span> <span class="fu">reFormHack</span>(re.form,ReForm,REForm,REform)</span>
<span id="cb10-70"><a href="#cb10-70" tabindex="-1"></a></span>
<span id="cb10-71"><a href="#cb10-71" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">...length</span>() <span class="sc">&gt;</span> <span class="dv">0</span>) <span class="fu">warning</span>(<span class="st">&quot;unused arguments ignored&quot;</span>)</span>
<span id="cb10-72"><a href="#cb10-72" tabindex="-1"></a></span>
<span id="cb10-73"><a href="#cb10-73" tabindex="-1"></a>    type <span class="ot">&lt;-</span> <span class="fu">match.arg</span>(type)</span>
<span id="cb10-74"><a href="#cb10-74" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(terms))</span>
<span id="cb10-75"><a href="#cb10-75" tabindex="-1"></a>        <span class="fu">stop</span>(<span class="st">&quot;terms functionality for predict not yet implemented&quot;</span>)</span>
<span id="cb10-76"><a href="#cb10-76" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(newparams))</span>
<span id="cb10-77"><a href="#cb10-77" tabindex="-1"></a>        object <span class="ot">&lt;-</span> <span class="fu">setParams</span>(object,newparams)</span>
<span id="cb10-78"><a href="#cb10-78" tabindex="-1"></a></span>
<span id="cb10-79"><a href="#cb10-79" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(newdata) <span class="sc">&amp;&amp;</span> <span class="fu">is.null</span>(re.form) <span class="sc">&amp;&amp;</span></span>
<span id="cb10-80"><a href="#cb10-80" tabindex="-1"></a>        <span class="fu">is.null</span>(newparams) <span class="sc">&amp;&amp;</span> <span class="sc">!</span>random.only) {</span>
<span id="cb10-81"><a href="#cb10-81" tabindex="-1"></a>        <span class="do">## raw predict() call, just return fitted values</span></span>
<span id="cb10-82"><a href="#cb10-82" tabindex="-1"></a>        <span class="do">##   (inverse-link if appropriate)</span></span>
<span id="cb10-83"><a href="#cb10-83" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">isLMM</span>(object) <span class="sc">||</span> <span class="fu">isNLMM</span>(object)) {</span>
<span id="cb10-84"><a href="#cb10-84" tabindex="-1"></a>            <span class="do">## make sure we do *NOT* have NAs in fitted object</span></span>
<span id="cb10-85"><a href="#cb10-85" tabindex="-1"></a>            pred <span class="ot">&lt;-</span> <span class="fu">na.omit</span>(<span class="fu">fitted</span>(object))</span>
<span id="cb10-86"><a href="#cb10-86" tabindex="-1"></a>        } <span class="cf">else</span> { <span class="do">## inverse-link</span></span>
<span id="cb10-87"><a href="#cb10-87" tabindex="-1"></a>            pred <span class="ot">&lt;-</span>  <span class="cf">switch</span>(type,<span class="at">response=</span>object<span class="sc">@</span>resp<span class="sc">$</span>mu, <span class="do">## == fitted(object),</span></span>
<span id="cb10-88"><a href="#cb10-88" tabindex="-1"></a>                            <span class="at">link=</span>object<span class="sc">@</span>resp<span class="sc">$</span>eta)</span>
<span id="cb10-89"><a href="#cb10-89" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">is.null</span>(nm <span class="ot">&lt;-</span> <span class="fu">rownames</span>(<span class="fu">model.frame</span>(object))))</span>
<span id="cb10-90"><a href="#cb10-90" tabindex="-1"></a>                nm <span class="ot">&lt;-</span> <span class="fu">seq_along</span>(pred)</span>
<span id="cb10-91"><a href="#cb10-91" tabindex="-1"></a>            <span class="fu">names</span>(pred) <span class="ot">&lt;-</span> nm</span>
<span id="cb10-92"><a href="#cb10-92" tabindex="-1"></a>        }</span>
<span id="cb10-93"><a href="#cb10-93" tabindex="-1"></a>        fit.na.action <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb10-94"><a href="#cb10-94" tabindex="-1"></a>        <span class="do">## flow jumps to end for na.predict</span></span>
<span id="cb10-95"><a href="#cb10-95" tabindex="-1"></a>    } <span class="cf">else</span> { <span class="do">## newdata and/or re.form and/or newparams and/or random.only specified</span></span>
<span id="cb10-96"><a href="#cb10-96" tabindex="-1"></a>        fit.na.action <span class="ot">&lt;-</span> <span class="fu">attr</span>(object<span class="sc">@</span>frame,<span class="st">&quot;na.action&quot;</span>)  <span class="do">## original NA action</span></span>
<span id="cb10-97"><a href="#cb10-97" tabindex="-1"></a></span>
<span id="cb10-98"><a href="#cb10-98" tabindex="-1"></a>        nobs <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="fu">is.null</span>(newdata)) <span class="fu">nrow</span>(object<span class="sc">@</span>frame) <span class="cf">else</span> <span class="fu">nrow</span>(newdata)</span>
<span id="cb10-99"><a href="#cb10-99" tabindex="-1"></a>        pred <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>,nobs)</span>
<span id="cb10-100"><a href="#cb10-100" tabindex="-1"></a></span>
<span id="cb10-101"><a href="#cb10-101" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span>random.only) {</span>
<span id="cb10-102"><a href="#cb10-102" tabindex="-1"></a>            X <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;X&quot;</span>)</span>
<span id="cb10-103"><a href="#cb10-103" tabindex="-1"></a>            X.col.dropped <span class="ot">&lt;-</span> <span class="fu">attr</span>(X, <span class="st">&quot;col.dropped&quot;</span>)</span>
<span id="cb10-104"><a href="#cb10-104" tabindex="-1"></a>            <span class="do">## modified from predict.glm ...</span></span>
<span id="cb10-105"><a href="#cb10-105" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">is.null</span>(newdata)) {</span>
<span id="cb10-106"><a href="#cb10-106" tabindex="-1"></a>                <span class="do">## Use original model &#39;X&#39; matrix and offset</span></span>
<span id="cb10-107"><a href="#cb10-107" tabindex="-1"></a>                <span class="do">## orig. offset: will be zero if there are no matches ...</span></span>
<span id="cb10-108"><a href="#cb10-108" tabindex="-1"></a>                offset <span class="ot">&lt;-</span> <span class="fu">model.offset</span>(<span class="fu">model.frame</span>(object))</span>
<span id="cb10-109"><a href="#cb10-109" tabindex="-1"></a>                <span class="cf">if</span> (<span class="fu">is.null</span>(offset)) offset <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb10-110"><a href="#cb10-110" tabindex="-1"></a>            } <span class="cf">else</span> {  <span class="do">## new data specified</span></span>
<span id="cb10-111"><a href="#cb10-111" tabindex="-1"></a>                <span class="do">## evaluate new fixed effect</span></span>
<span id="cb10-112"><a href="#cb10-112" tabindex="-1"></a>                RHS <span class="ot">&lt;-</span> <span class="fu">formula</span>(<span class="fu">substitute</span>(<span class="sc">~</span>R,</span>
<span id="cb10-113"><a href="#cb10-113" tabindex="-1"></a>                         <span class="fu">list</span>(<span class="at">R=</span><span class="fu">RHSForm</span>(<span class="fu">formula</span>(object,<span class="at">fixed.only=</span><span class="cn">TRUE</span>)))))</span>
<span id="cb10-114"><a href="#cb10-114" tabindex="-1"></a>                <span class="do">## https://github.com/lme4/lme4/issues/414</span></span>
<span id="cb10-115"><a href="#cb10-115" tabindex="-1"></a>                <span class="do">## contrasts are not relevant in random effects;</span></span>
<span id="cb10-116"><a href="#cb10-116" tabindex="-1"></a>                <span class="do">##  model.frame.default warns about dropping contrasts</span></span>
<span id="cb10-117"><a href="#cb10-117" tabindex="-1"></a>                <span class="do">##  if (1) xlev is specified and (2) any factors in</span></span>
<span id="cb10-118"><a href="#cb10-118" tabindex="-1"></a>                <span class="do">##  original data frame had contrasts set</span></span>
<span id="cb10-119"><a href="#cb10-119" tabindex="-1"></a></span>
<span id="cb10-120"><a href="#cb10-120" tabindex="-1"></a>                <span class="do">## alternative solution: drop contrasts manually</span></span>
<span id="cb10-121"><a href="#cb10-121" tabindex="-1"></a>                <span class="do">## (could assign to a new variable newdata2 for safety,</span></span>
<span id="cb10-122"><a href="#cb10-122" tabindex="-1"></a>                <span class="do">## but I don&#39;t think newdata</span></span>
<span id="cb10-123"><a href="#cb10-123" tabindex="-1"></a>                <span class="do">##  is used downstream in this function?)</span></span>
<span id="cb10-124"><a href="#cb10-124" tabindex="-1"></a></span>
<span id="cb10-125"><a href="#cb10-125" tabindex="-1"></a>                <span class="do">## isFacND &lt;- which(vapply(newdata, is.factor, FUN.VALUE = TRUE))</span></span>
<span id="cb10-126"><a href="#cb10-126" tabindex="-1"></a>                <span class="do">## for (j in isFacND) {</span></span>
<span id="cb10-127"><a href="#cb10-127" tabindex="-1"></a>                <span class="do">##    attr(newdata[[j]], &quot;contrasts&quot;) &lt;- NULL</span></span>
<span id="cb10-128"><a href="#cb10-128" tabindex="-1"></a>                <span class="do">## }</span></span>
<span id="cb10-129"><a href="#cb10-129" tabindex="-1"></a></span>
<span id="cb10-130"><a href="#cb10-130" tabindex="-1"></a>              orig.fixed.levs <span class="ot">&lt;-</span> <span class="fu">get.orig.levs</span>(object, <span class="at">fixed.only=</span><span class="cn">TRUE</span>,</span>
<span id="cb10-131"><a href="#cb10-131" tabindex="-1"></a>                                               <span class="at">newdata =</span> newdata)</span>
<span id="cb10-132"><a href="#cb10-132" tabindex="-1"></a>                mfnew <span class="ot">&lt;-</span> <span class="fu">suppressWarnings</span>(</span>
<span id="cb10-133"><a href="#cb10-133" tabindex="-1"></a>                    <span class="fu">model.frame</span>(<span class="fu">delete.response</span>(<span class="fu">terms</span>(object, <span class="at">fixed.only=</span><span class="cn">TRUE</span>,</span>
<span id="cb10-134"><a href="#cb10-134" tabindex="-1"></a>                                                      <span class="at">data =</span> newdata)),</span>
<span id="cb10-135"><a href="#cb10-135" tabindex="-1"></a>                                newdata,</span>
<span id="cb10-136"><a href="#cb10-136" tabindex="-1"></a>                                <span class="at">na.action =</span> na.action, <span class="at">xlev =</span> orig.fixed.levs))</span>
<span id="cb10-137"><a href="#cb10-137" tabindex="-1"></a></span>
<span id="cb10-138"><a href="#cb10-138" tabindex="-1"></a>                X <span class="ot">&lt;-</span> <span class="fu">model.matrix</span>(RHS, <span class="at">data=</span>mfnew,</span>
<span id="cb10-139"><a href="#cb10-139" tabindex="-1"></a>                                  <span class="at">contrasts.arg=</span><span class="fu">attr</span>(X,<span class="st">&quot;contrasts&quot;</span>))</span>
<span id="cb10-140"><a href="#cb10-140" tabindex="-1"></a>                <span class="do">## hack to remove unused interaction levels?</span></span>
<span id="cb10-141"><a href="#cb10-141" tabindex="-1"></a>                <span class="do">## X &lt;- X[,colnames(X0)]</span></span>
<span id="cb10-142"><a href="#cb10-142" tabindex="-1"></a></span>
<span id="cb10-143"><a href="#cb10-143" tabindex="-1"></a>                offset <span class="ot">&lt;-</span> <span class="dv">0</span> <span class="co"># rep(0, nrow(X))</span></span>
<span id="cb10-144"><a href="#cb10-144" tabindex="-1"></a>                tt <span class="ot">&lt;-</span> <span class="fu">terms</span>(object, <span class="at">data  =</span> newdata)</span>
<span id="cb10-145"><a href="#cb10-145" tabindex="-1"></a>                <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(off.num <span class="ot">&lt;-</span> <span class="fu">attr</span>(tt, <span class="st">&quot;offset&quot;</span>))) {</span>
<span id="cb10-146"><a href="#cb10-146" tabindex="-1"></a>                    <span class="cf">for</span> (i <span class="cf">in</span> off.num)</span>
<span id="cb10-147"><a href="#cb10-147" tabindex="-1"></a>                        offset <span class="ot">&lt;-</span> offset <span class="sc">+</span> <span class="fu">eval</span>(<span class="fu">attr</span>(tt,<span class="st">&quot;variables&quot;</span>)[[i <span class="sc">+</span> <span class="dv">1</span>]], newdata)</span>
<span id="cb10-148"><a href="#cb10-148" tabindex="-1"></a>                }</span>
<span id="cb10-149"><a href="#cb10-149" tabindex="-1"></a>                <span class="do">## </span><span class="al">FIXME</span><span class="do">?: simplify(no need for &#39;mfnew&#39;): can this be different from &#39;na.action&#39;?</span></span>
<span id="cb10-150"><a href="#cb10-150" tabindex="-1"></a>                fit.na.action <span class="ot">&lt;-</span> <span class="fu">attr</span>(mfnew,<span class="st">&quot;na.action&quot;</span>)</span>
<span id="cb10-151"><a href="#cb10-151" tabindex="-1"></a>                <span class="do">## only need to drop if new data specified ...</span></span>
<span id="cb10-152"><a href="#cb10-152" tabindex="-1"></a>                <span class="cf">if</span>(<span class="fu">is.numeric</span>(X.col.dropped) <span class="sc">&amp;&amp;</span> <span class="fu">length</span>(X.col.dropped) <span class="sc">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb10-153"><a href="#cb10-153" tabindex="-1"></a>                    X <span class="ot">&lt;-</span> X[, <span class="sc">-</span>X.col.dropped, drop<span class="ot">=</span><span class="cn">FALSE</span>]</span>
<span id="cb10-154"><a href="#cb10-154" tabindex="-1"></a>            }</span>
<span id="cb10-155"><a href="#cb10-155" tabindex="-1"></a>            pred <span class="ot">&lt;-</span> <span class="fu">drop</span>(X <span class="sc">%*%</span> <span class="fu">fixef</span>(object))</span>
<span id="cb10-156"><a href="#cb10-156" tabindex="-1"></a></span>
<span id="cb10-157"><a href="#cb10-157" tabindex="-1"></a>            <span class="do">## </span><span class="al">FIXME</span><span class="do">:: need to unname()  ?</span></span>
<span id="cb10-158"><a href="#cb10-158" tabindex="-1"></a>            <span class="do">## </span><span class="al">FIXME</span><span class="do">: is this redundant??</span></span>
<span id="cb10-159"><a href="#cb10-159" tabindex="-1"></a>            <span class="do">## if (!is.null(frOffset &lt;- attr(object@frame,&quot;offset&quot;)))</span></span>
<span id="cb10-160"><a href="#cb10-160" tabindex="-1"></a>            <span class="do">##     offset &lt;- offset + eval(frOffset, newdata)</span></span>
<span id="cb10-161"><a href="#cb10-161" tabindex="-1"></a>            pred <span class="ot">&lt;-</span> pred<span class="sc">+</span>offset</span>
<span id="cb10-162"><a href="#cb10-162" tabindex="-1"></a></span>
<span id="cb10-163"><a href="#cb10-163" tabindex="-1"></a>        } <span class="do">## end !(random.only)</span></span>
<span id="cb10-164"><a href="#cb10-164" tabindex="-1"></a></span>
<span id="cb10-165"><a href="#cb10-165" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">isRE</span>(re.form)) {</span>
<span id="cb10-166"><a href="#cb10-166" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">is.null</span>(re.form))</span>
<span id="cb10-167"><a href="#cb10-167" tabindex="-1"></a>                re.form <span class="ot">&lt;-</span> <span class="fu">reOnly</span>(<span class="fu">formula</span>(object)) <span class="co"># RE formula only</span></span>
<span id="cb10-168"><a href="#cb10-168" tabindex="-1"></a>            rfd <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="fu">is.null</span>(newdata)) {</span>
<span id="cb10-169"><a href="#cb10-169" tabindex="-1"></a>                       <span class="do">## try to retrieve original data ... fall back to model frame if necessary</span></span>
<span id="cb10-170"><a href="#cb10-170" tabindex="-1"></a>                       <span class="do">## </span><span class="al">FIXME</span><span class="do">: this doesn&#39;t solve the problem if columns of model frame and data</span></span>
<span id="cb10-171"><a href="#cb10-171" tabindex="-1"></a>                       <span class="do">## diverge (e.g. transformed objects [log(x)], offsets [offset(x)] ... will</span></span>
<span id="cb10-172"><a href="#cb10-172" tabindex="-1"></a>                       <span class="do">## fail farther along</span></span>
<span id="cb10-173"><a href="#cb10-173" tabindex="-1"></a>                       <span class="fu">tryCatch</span>(<span class="fu">getData</span>(object),</span>
<span id="cb10-174"><a href="#cb10-174" tabindex="-1"></a>                                <span class="at">error =</span> <span class="cf">function</span>(e) object<span class="sc">@</span>frame)</span>
<span id="cb10-175"><a href="#cb10-175" tabindex="-1"></a>                   } <span class="cf">else</span> newdata</span>
<span id="cb10-176"><a href="#cb10-176" tabindex="-1"></a>            newRE <span class="ot">&lt;-</span> <span class="fu">mkNewReTrms</span>(object, rfd, re.form, <span class="at">na.action=</span>na.action,</span>
<span id="cb10-177"><a href="#cb10-177" tabindex="-1"></a>                                 <span class="at">allow.new.levels=</span>allow.new.levels)</span>
<span id="cb10-178"><a href="#cb10-178" tabindex="-1"></a>            REvals <span class="ot">&lt;-</span> base<span class="sc">::</span><span class="fu">drop</span>(<span class="fu">as</span>(newRE<span class="sc">$</span>b <span class="sc">%*%</span> newRE<span class="sc">$</span>Zt, <span class="st">&quot;matrix&quot;</span>))</span>
<span id="cb10-179"><a href="#cb10-179" tabindex="-1"></a>            <span class="do">## only needed if called as simulation? NAs sometimes excluded within mkNewReTrms ...</span></span>
<span id="cb10-180"><a href="#cb10-180" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">length</span>(pred) <span class="sc">!=</span> <span class="fu">length</span>(REvals)) {</span>
<span id="cb10-181"><a href="#cb10-181" tabindex="-1"></a>                <span class="cf">if</span> (<span class="sc">!</span><span class="fu">class</span>(fit.na.action) <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">&quot;omit&quot;</span>, <span class="st">&quot;exclude&quot;</span>) <span class="sc">&amp;&amp;</span> <span class="fu">length</span>(fit.na.action)<span class="sc">&gt;</span><span class="dv">0</span>) {</span>
<span id="cb10-182"><a href="#cb10-182" tabindex="-1"></a>                    <span class="fu">stop</span>(<span class="st">&quot;fixed/RE pred length mismatch&quot;</span>)</span>
<span id="cb10-183"><a href="#cb10-183" tabindex="-1"></a>                }                    </span>
<span id="cb10-184"><a href="#cb10-184" tabindex="-1"></a>                 REvals <span class="ot">&lt;-</span> REvals[<span class="sc">-</span>fit.na.action]</span>
<span id="cb10-185"><a href="#cb10-185" tabindex="-1"></a>            }</span>
<span id="cb10-186"><a href="#cb10-186" tabindex="-1"></a>            pred <span class="ot">&lt;-</span> pred <span class="sc">+</span> REvals</span>
<span id="cb10-187"><a href="#cb10-187" tabindex="-1"></a>            <span class="cf">if</span> (random.only) {</span>
<span id="cb10-188"><a href="#cb10-188" tabindex="-1"></a>                fit.na.action <span class="ot">&lt;-</span> <span class="fu">attr</span>(newRE<span class="sc">$</span>Zt,<span class="st">&quot;na.action&quot;</span>)</span>
<span id="cb10-189"><a href="#cb10-189" tabindex="-1"></a>            }</span>
<span id="cb10-190"><a href="#cb10-190" tabindex="-1"></a>        }</span>
<span id="cb10-191"><a href="#cb10-191" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">isGLMM</span>(object) <span class="sc">&amp;&amp;</span> type<span class="sc">==</span><span class="st">&quot;response&quot;</span>) {</span>
<span id="cb10-192"><a href="#cb10-192" tabindex="-1"></a>            pred <span class="ot">&lt;-</span> object<span class="sc">@</span>resp<span class="sc">$</span>family<span class="sc">$</span><span class="fu">linkinv</span>(pred)</span>
<span id="cb10-193"><a href="#cb10-193" tabindex="-1"></a>        }</span>
<span id="cb10-194"><a href="#cb10-194" tabindex="-1"></a>    }  <span class="do">## newdata/newparams/re.form</span></span>
<span id="cb10-195"><a href="#cb10-195" tabindex="-1"></a></span>
<span id="cb10-196"><a href="#cb10-196" tabindex="-1"></a>    <span class="do">## fill in NAs as appropriate:</span></span>
<span id="cb10-197"><a href="#cb10-197" tabindex="-1"></a>    <span class="do">##   if NAs were detected in original model fit, OR in updated model frame construction</span></span>
<span id="cb10-198"><a href="#cb10-198" tabindex="-1"></a>    <span class="do">## but DON&#39;T double-NA if raw prediction in the first place</span></span>
<span id="cb10-199"><a href="#cb10-199" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(newdata)) {</span>
<span id="cb10-200"><a href="#cb10-200" tabindex="-1"></a>        fit.na.action <span class="ot">&lt;-</span> <span class="fu">attr</span>(<span class="fu">model.frame</span>(object),<span class="st">&quot;na.action&quot;</span>)</span>
<span id="cb10-201"><a href="#cb10-201" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span><span class="fu">missing</span>(na.action)) {</span>
<span id="cb10-202"><a href="#cb10-202" tabindex="-1"></a>            <span class="do">## hack to override action where explicitly specified</span></span>
<span id="cb10-203"><a href="#cb10-203" tabindex="-1"></a>            <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(fit.na.action))</span>
<span id="cb10-204"><a href="#cb10-204" tabindex="-1"></a>                <span class="fu">class</span>(fit.na.action) <span class="ot">&lt;-</span> <span class="fu">class</span>(<span class="fu">attr</span>(<span class="fu">na.action</span>(<span class="cn">NA</span>),<span class="st">&quot;na.action&quot;</span>))</span>
<span id="cb10-205"><a href="#cb10-205" tabindex="-1"></a>        }</span>
<span id="cb10-206"><a href="#cb10-206" tabindex="-1"></a>    }</span>
<span id="cb10-207"><a href="#cb10-207" tabindex="-1"></a>    pred <span class="ot">&lt;-</span> <span class="fu">napredict</span>(fit.na.action, pred)</span>
<span id="cb10-208"><a href="#cb10-208" tabindex="-1"></a></span>
<span id="cb10-209"><a href="#cb10-209" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span>se.fit) <span class="fu">return</span>(pred)</span>
<span id="cb10-210"><a href="#cb10-210" tabindex="-1"></a></span>
<span id="cb10-211"><a href="#cb10-211" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">isLMM</span>(object)) <span class="fu">warning</span>(<span class="st">&quot;se.fit computation uses an approximation to estimate the sampling distribution of the parameters&quot;</span>)</span>
<span id="cb10-212"><a href="#cb10-212" tabindex="-1"></a>    </span>
<span id="cb10-213"><a href="#cb10-213" tabindex="-1"></a>    s <span class="ot">&lt;-</span> <span class="fu">sigma</span>(object)</span>
<span id="cb10-214"><a href="#cb10-214" tabindex="-1"></a>    <span class="do">## need these below so can&#39;t getME(...) all at once</span></span>
<span id="cb10-215"><a href="#cb10-215" tabindex="-1"></a>    L <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;L&quot;</span>)</span>
<span id="cb10-216"><a href="#cb10-216" tabindex="-1"></a>    RX <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;RX&quot;</span>)</span>
<span id="cb10-217"><a href="#cb10-217" tabindex="-1"></a>    RZX <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;RZX&quot;</span>)</span>
<span id="cb10-218"><a href="#cb10-218" tabindex="-1"></a>    Lambdat <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;Lambdat&quot;</span>)</span>
<span id="cb10-219"><a href="#cb10-219" tabindex="-1"></a></span>
<span id="cb10-220"><a href="#cb10-220" tabindex="-1"></a>    RXtinv <span class="ot">&lt;-</span> <span class="fu">solve</span>(<span class="fu">t</span>(RX))</span>
<span id="cb10-221"><a href="#cb10-221" tabindex="-1"></a>    LinvLambdat <span class="ot">&lt;-</span> <span class="fu">solve</span>(L, Lambdat, <span class="at">system =</span> <span class="st">&quot;L&quot;</span>)</span>
<span id="cb10-222"><a href="#cb10-222" tabindex="-1"></a>    Minv <span class="ot">&lt;-</span> s <span class="sc">*</span> <span class="fu">rbind</span>(</span>
<span id="cb10-223"><a href="#cb10-223" tabindex="-1"></a>                    <span class="fu">cbind</span>(LinvLambdat,</span>
<span id="cb10-224"><a href="#cb10-224" tabindex="-1"></a>                          <span class="fu">Matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="fu">nrow</span>(L), <span class="at">ncol =</span> <span class="fu">ncol</span>(RX))),</span>
<span id="cb10-225"><a href="#cb10-225" tabindex="-1"></a>                    <span class="fu">cbind</span>(<span class="sc">-</span>RXtinv <span class="sc">%*%</span> <span class="fu">t</span>(RZX) <span class="sc">%*%</span> LinvLambdat, RXtinv)</span>
<span id="cb10-226"><a href="#cb10-226" tabindex="-1"></a>                )</span>
<span id="cb10-227"><a href="#cb10-227" tabindex="-1"></a>    Cmat <span class="ot">&lt;-</span> <span class="fu">crossprod</span>(Minv)</span>
<span id="cb10-228"><a href="#cb10-228" tabindex="-1"></a>        </span>
<span id="cb10-229"><a href="#cb10-229" tabindex="-1"></a>        </span>
<span id="cb10-230"><a href="#cb10-230" tabindex="-1"></a>    <span class="do">## </span><span class="al">FIXME</span><span class="do">: these need to be fixed</span></span>
<span id="cb10-231"><a href="#cb10-231" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">is.null</span>(newdata)) {</span>
<span id="cb10-232"><a href="#cb10-232" tabindex="-1"></a>        X <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;X&quot;</span>)</span>
<span id="cb10-233"><a href="#cb10-233" tabindex="-1"></a>        <span class="cf">if</span>(<span class="fu">is.null</span>(re.form)) {</span>
<span id="cb10-234"><a href="#cb10-234" tabindex="-1"></a>            Z <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;Z&quot;</span>)</span>
<span id="cb10-235"><a href="#cb10-235" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb10-236"><a href="#cb10-236" tabindex="-1"></a>            <span class="cf">if</span>(<span class="fu">isRE</span>(re.form)) {</span>
<span id="cb10-237"><a href="#cb10-237" tabindex="-1"></a>                <span class="do">## </span><span class="al">FIXME</span><span class="do">: newRE is not computed here</span></span>
<span id="cb10-238"><a href="#cb10-238" tabindex="-1"></a>                Z <span class="ot">&lt;-</span> <span class="fu">t</span>(newRE<span class="sc">$</span>Zt)</span>
<span id="cb10-239"><a href="#cb10-239" tabindex="-1"></a>            } <span class="cf">else</span> {</span>
<span id="cb10-240"><a href="#cb10-240" tabindex="-1"></a>                Z <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="fu">nrow</span>(X), <span class="at">ncol =</span> <span class="fu">ncol</span>(L))</span>
<span id="cb10-241"><a href="#cb10-241" tabindex="-1"></a>            }</span>
<span id="cb10-242"><a href="#cb10-242" tabindex="-1"></a>        }</span>
<span id="cb10-243"><a href="#cb10-243" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb10-244"><a href="#cb10-244" tabindex="-1"></a>        <span class="cf">if</span>(<span class="fu">isRE</span>(re.form)) {</span>
<span id="cb10-245"><a href="#cb10-245" tabindex="-1"></a>            Z <span class="ot">&lt;-</span> <span class="fu">t</span>(newRE<span class="sc">$</span>Zt)</span>
<span id="cb10-246"><a href="#cb10-246" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb10-247"><a href="#cb10-247" tabindex="-1"></a>            <span class="do">## this is inefficient and we could just calculate </span></span>
<span id="cb10-248"><a href="#cb10-248" tabindex="-1"></a>            <span class="do">## X %*% Cmat[X part only] t(X) instead</span></span>
<span id="cb10-249"><a href="#cb10-249" tabindex="-1"></a>            Z <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="fu">nrow</span>(X), <span class="at">ncol =</span> <span class="fu">ncol</span>(L))</span>
<span id="cb10-250"><a href="#cb10-250" tabindex="-1"></a>        }</span>
<span id="cb10-251"><a href="#cb10-251" tabindex="-1"></a>    }</span>
<span id="cb10-252"><a href="#cb10-252" tabindex="-1"></a>        </span>
<span id="cb10-253"><a href="#cb10-253" tabindex="-1"></a>    <span class="cf">if</span>(random.only) X <span class="ot">&lt;-</span> <span class="fu">Matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> <span class="fu">nrow</span>(Z), <span class="at">ncol =</span> <span class="fu">nrow</span>(RX))</span>
<span id="cb10-254"><a href="#cb10-254" tabindex="-1"></a>        </span>
<span id="cb10-255"><a href="#cb10-255" tabindex="-1"></a>    ZX <span class="ot">&lt;-</span> <span class="fu">cbind</span>(Z, X)</span>
<span id="cb10-256"><a href="#cb10-256" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">fit =</span> pred,</span>
<span id="cb10-257"><a href="#cb10-257" tabindex="-1"></a>         <span class="at">se.fit =</span> <span class="fu">sqrt</span>(<span class="fu">quad.tdiag</span>(Cmat, ZX))</span>
<span id="cb10-258"><a href="#cb10-258" tabindex="-1"></a>         )</span>
<span id="cb10-259"><a href="#cb10-259" tabindex="-1"></a>    </span>
<span id="cb10-260"><a href="#cb10-260" tabindex="-1"></a>} <span class="co"># end {predict.merMod}</span></span></code></pre></div>
</div>
<div id="add-random-effects" class="section level2">
<h2>Add Random Effects</h2>
<p>I think this part generates the cluster random effects, though of
course the random draw from the distribution is another reading of
“random components”.</p>
<p>This has lots of twisty logic because of the need to exclude the
random effects that the previous step might have incorporated already.
In my case, there are none.</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>    <span class="do">## now add random components:</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>    <span class="do">##  only the ones we did *not* condition on</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>    <span class="do">## compre.form &lt;- noLHSform(formula(object))</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>    <span class="do">## construct RE formula ONLY: leave out fixed terms,</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>    <span class="do">##   which might have loose terms like offsets in them ...</span></span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a></span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>    <span class="do">##&#39; combine unary or binary operator + arguments (sugar for &#39;substitute&#39;)</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    makeOp <span class="ot">&lt;-</span> <span class="cf">function</span>(x,y,<span class="at">op=</span><span class="cn">NULL</span>) {</span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.null</span>(op)) {  <span class="do">## unary</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>            <span class="fu">substitute</span>(<span class="fu">OP</span>(X),<span class="fu">list</span>(<span class="at">X=</span>x,<span class="at">OP=</span>y))</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>        } <span class="cf">else</span> <span class="fu">substitute</span>(<span class="fu">OP</span>(X,Y), <span class="fu">list</span>(<span class="at">X=</span>x,<span class="at">OP=</span>op,<span class="at">Y=</span>y))</span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>    }</span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>    compReForm <span class="ot">&lt;-</span> <span class="fu">reOnly</span>(<span class="fu">formula</span>(object))</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">isRE</span>(re.form)) {</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>        rr <span class="ot">&lt;-</span> <span class="fu">reOnly</span>(re.form)[[<span class="dv">2</span>]] <span class="do">## expand RE and strip ~</span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>        ftemplate <span class="ot">&lt;-</span> <span class="fu">substitute</span>(.<span class="sc">~</span>.<span class="sc">-</span>XX, <span class="fu">list</span>(<span class="at">XX=</span>rr))</span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a>        compReForm <span class="ot">&lt;-</span> <span class="fu">update.formula</span>(compReForm,ftemplate)[<span class="sc">-</span><span class="dv">2</span>]</span>
<span id="cb11-20"><a href="#cb11-20" tabindex="-1"></a>        <span class="do">## update, then delete LHS</span></span>
<span id="cb11-21"><a href="#cb11-21" tabindex="-1"></a>    }</span></code></pre></div>
<p>In this trace, <code>compReForm == ~(1 | fid)</code> and
<code>isRE(re.form)</code> is <code>FALSE</code>.</p>
<div id="isre" class="section level3">
<h3><code>isRE()</code></h3>
<p>For reference, the start of the file defines</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="do">##&#39; test for no-random-effect specification: TRUE if NA or ~0, other</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a><span class="do">##&#39; possibilities are NULL or a non-trivial formula</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>isRE <span class="ot">&lt;-</span> <span class="cf">function</span>(re.form) {</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>    isForm <span class="ot">&lt;-</span> <span class="fu">inherits</span>(re.form, <span class="st">&quot;formula&quot;</span>)</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>    (<span class="fu">is.null</span>(re.form) <span class="sc">||</span> isForm <span class="sc">||</span> <span class="sc">!</span><span class="fu">is.na</span>(re.form)) <span class="sc">&amp;&amp;</span></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>    (<span class="sc">!</span>isForm <span class="sc">||</span> <span class="fu">length</span>(re.form) <span class="sc">!=</span> <span class="dv">2</span><span class="dt">L</span> <span class="sc">||</span> <span class="sc">!</span><span class="fu">identical</span>(re.form[[<span class="dv">2</span><span class="dt">L</span>]], <span class="dv">0</span>))</span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="random-effects-generation-core" class="section level3">
<h3>Random Effects generation core</h3>
<p>The <code>findbars()</code> test immediately below is
<code>TRUE</code>.</p>
<p><em><code>u &lt;- rnorm(ncol(U)*nsim)</code> generates actual random
values for each cluster and each simulation.</em> <code>Lambdat</code>
is 68 x 68 diagonal of 0.413’s; <code>Zt</code> is 68 x 2691 design
matrix for the random effects, so <code>U</code> is 2691 x 68 like
<code>t(Zt)</code> except with 0.413’s in place of the 1’s.</p>
<p>My <code>u</code> values begin 1.591, 1.074, -0.065.</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a>    <span class="do">## (1) random effect(s)</span></span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a>    sim.reff <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(<span class="fu">findbars</span>(compReForm))) {</span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>        newRE <span class="ot">&lt;-</span> <span class="fu">mkNewReTrms</span>(object, newdata, compReForm,</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>                             <span class="at">na.action=</span>na.action,</span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>                             <span class="at">allow.new.levels=</span>allow.new.levels)</span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>        <span class="do">## this *can* justifiably happen, if we are using mkNewReTrms</span></span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>        <span class="do">## in the context of predicting/simulating with a non-trivial</span></span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>        <span class="do">## re.form ...</span></span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>        <span class="do">## &lt;obsolete&gt; paranoia ...</span></span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>        <span class="do">## &lt;obsolete&gt; stopifnot(!is.null(newdata) ||</span></span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>        <span class="do">##       isTRUE(all.equal(newRE$Lambdat,getME(object,&quot;Lambdat&quot;))))</span></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a>        U <span class="ot">&lt;-</span> <span class="fu">t</span>(newRE<span class="sc">$</span>Lambdat <span class="sc">%*%</span> newRE<span class="sc">$</span>Zt) <span class="co"># == Z Lambda</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a>        u <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="fu">ncol</span>(U)<span class="sc">*</span>nsim)</span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>        <span class="do">## UNSCALED random-effects contribution:</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>        <span class="fu">as</span>(U <span class="sc">%*%</span> <span class="fu">matrix</span>(u, <span class="at">ncol =</span> nsim), <span class="st">&quot;matrix&quot;</span>)</span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a>    } <span class="cf">else</span> <span class="dv">0</span></span></code></pre></div>
<p><code>sim.reff</code> ends up as a 2691 x 1 matrix (each column is a
simulation) with values 0.657, 0.657, 0.657, 0.444, …. So 0.413 times
the original standard normal, effectively changing their standard
deviation.</p>
<p>I have 2 problems. First, figuring out how the actual scale of the
random effects (recall that 0.413 is the scale relative to <span class="math inline">\(\sigma_\epsilon\)</span>) is recovered later.
Second, I want to generated <em>normalized</em> random numbers, often on
a subset of the real line. So I need to figure out how to scale
those.</p>
<p>Before proceeding with the main code, we take an excursion into the
calls made, directly and indirectly, from the code above.</p>
</div>
<div id="mknewretrms" class="section level3">
<h3><code>mkNewReTrms()</code></h3>
<p>This function is lengthy, yet the opening <code>Roxygen2</code> docs
do not disclose the return value, which the code just above shows is a
complex object. The return value at the end of the function is
<code>list(Zt=Zt, b=re_new, Lambdat = ReTrms$Lambdat)</code>.
<code>b</code> is a named numeric array of the random effects estimates,
I think (68 observations: 0.328, -0.232, -0.054, …). The values are
ultimately from
<code>re &lt;- ranef(object, condVar = FALSE)</code>.</p>
<p>Called with <code>re.form = ~(1 | fid)</code>. <code>rfd</code> has
2691 observations with 2 variables, <code>ln_los</code> and
<code>fid</code>. <code>re.form[[2] == (1 | fid)</code> without the
<code>~</code>; it is a language construct reporting a class of
<code>(</code> (?).</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="do">##&#39; Make new random effect terms from specified object and new data,</span></span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a><span class="do">##&#39; possibly omitting some random effect terms</span></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="do">##&#39; @param object fitted model object</span></span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a><span class="do">##&#39; @param newdata (optional) data frame containing new data</span></span>
<span id="cb14-5"><a href="#cb14-5" tabindex="-1"></a><span class="do">##&#39; @param re.form formula specifying random effect terms to include (NULL=all, ~0)</span></span>
<span id="cb14-6"><a href="#cb14-6" tabindex="-1"></a><span class="do">##&#39; @param na.action</span></span>
<span id="cb14-7"><a href="#cb14-7" tabindex="-1"></a><span class="do">##&#39;</span></span>
<span id="cb14-8"><a href="#cb14-8" tabindex="-1"></a><span class="do">##&#39; @note Hidden; _only_ used (twice) in this file</span></span>
<span id="cb14-9"><a href="#cb14-9" tabindex="-1"></a>mkNewReTrms <span class="ot">&lt;-</span> <span class="cf">function</span>(object, newdata, <span class="at">re.form=</span><span class="cn">NULL</span>, <span class="at">na.action=</span>na.pass,</span>
<span id="cb14-10"><a href="#cb14-10" tabindex="-1"></a>                        <span class="at">allow.new.levels=</span><span class="cn">FALSE</span>,</span>
<span id="cb14-11"><a href="#cb14-11" tabindex="-1"></a>                        <span class="at">sparse =</span> <span class="fu">max</span>(<span class="fu">lengths</span>(orig.random.levs)) <span class="sc">&gt;</span> <span class="dv">100</span>)</span>
<span id="cb14-12"><a href="#cb14-12" tabindex="-1"></a>{</span>
<span id="cb14-13"><a href="#cb14-13" tabindex="-1"></a>    <span class="do">## construct (fixed) model frame in order to find out whether there are</span></span>
<span id="cb14-14"><a href="#cb14-14" tabindex="-1"></a>    <span class="do">## missing data/what to do about them</span></span>
<span id="cb14-15"><a href="#cb14-15" tabindex="-1"></a>    <span class="do">## need rfd to inherit appropriate na.action; need grouping</span></span>
<span id="cb14-16"><a href="#cb14-16" tabindex="-1"></a>    <span class="do">## variables as well as any covariates that are included</span></span>
<span id="cb14-17"><a href="#cb14-17" tabindex="-1"></a>    <span class="do">## in RE terms</span></span>
<span id="cb14-18"><a href="#cb14-18" tabindex="-1"></a>    <span class="do">## </span><span class="al">FIXME</span><span class="do">: mfnew is new data frame, rfd is processed new data</span></span>
<span id="cb14-19"><a href="#cb14-19" tabindex="-1"></a>    <span class="do">##        why do we need both/what is each doing/how do they differ?</span></span>
<span id="cb14-20"><a href="#cb14-20" tabindex="-1"></a>    <span class="do">##        rfd is *only* used in mkReTrms</span></span>
<span id="cb14-21"><a href="#cb14-21" tabindex="-1"></a>    <span class="do">##        mfnew is *only* used for its na.action attribute (!) [fixed only]</span></span>
<span id="cb14-22"><a href="#cb14-22" tabindex="-1"></a>    <span class="do">##        using model.frame would mess up matrix-valued predictors (GH #201)</span></span>
<span id="cb14-23"><a href="#cb14-23" tabindex="-1"></a>    fixed.na.action <span class="ot">&lt;-</span> <span class="cn">NULL</span></span>
<span id="cb14-24"><a href="#cb14-24" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">is.null</span>(newdata)) {</span>
<span id="cb14-25"><a href="#cb14-25" tabindex="-1"></a>        rfd <span class="ot">&lt;-</span> mfnew <span class="ot">&lt;-</span> <span class="fu">model.frame</span>(object)</span>
<span id="cb14-26"><a href="#cb14-26" tabindex="-1"></a>        fixed.na.action <span class="ot">&lt;-</span> <span class="fu">attr</span>(mfnew,<span class="st">&quot;na.action&quot;</span>)</span>
<span id="cb14-27"><a href="#cb14-27" tabindex="-1"></a>    } <span class="cf">else</span> {</span></code></pre></div>
<p>Execution bypasses the next block.</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>      <span class="cf">if</span> (<span class="sc">!</span><span class="fu">identical</span>(na.action,na.pass)) {</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>          <span class="do">## only need to re-evaluate for NAs if na.action != na.pass</span></span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>          mfnew <span class="ot">&lt;-</span> <span class="fu">model.frame</span>(<span class="fu">delete.response</span>(<span class="fu">terms</span>(object, <span class="at">fixed.only=</span><span class="cn">TRUE</span>)),</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>                               newdata, <span class="at">na.action=</span>na.action)</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>          fixed.na.action <span class="ot">&lt;-</span> <span class="fu">attr</span>(mfnew,<span class="st">&quot;na.action&quot;</span>)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>      }</span>
<span id="cb15-7"><a href="#cb15-7" tabindex="-1"></a>      <span class="do">## make sure we pass na.action with new data</span></span>
<span id="cb15-8"><a href="#cb15-8" tabindex="-1"></a>      <span class="do">## it would be nice to do something more principled like</span></span>
<span id="cb15-9"><a href="#cb15-9" tabindex="-1"></a>      <span class="do">## rfd &lt;- model.frame(~.,newdata,na.action=na.action)</span></span>
<span id="cb15-10"><a href="#cb15-10" tabindex="-1"></a>      <span class="do">## but this adds complexities (stored terms, formula, etc.)</span></span>
<span id="cb15-11"><a href="#cb15-11" tabindex="-1"></a>      <span class="do">## that mess things up later on ...</span></span>
<span id="cb15-12"><a href="#cb15-12" tabindex="-1"></a>      <span class="do">## rfd &lt;- na.action(get_all_vars(delete.response(terms(object,fixed.only=FALSE)), newdata))</span></span>
<span id="cb15-13"><a href="#cb15-13" tabindex="-1"></a>      newdata.NA <span class="ot">&lt;-</span> newdata</span>
<span id="cb15-14"><a href="#cb15-14" tabindex="-1"></a>      <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(fixed.na.action)) {</span>
<span id="cb15-15"><a href="#cb15-15" tabindex="-1"></a>          newdata.NA <span class="ot">&lt;-</span> newdata.NA[<span class="sc">-</span>fixed.na.action,]</span>
<span id="cb15-16"><a href="#cb15-16" tabindex="-1"></a>      }</span>
<span id="cb15-17"><a href="#cb15-17" tabindex="-1"></a>      tt <span class="ot">&lt;-</span> <span class="fu">delete.response</span>(<span class="fu">terms</span>(object,<span class="at">random.only=</span><span class="cn">TRUE</span>))</span>
<span id="cb15-18"><a href="#cb15-18" tabindex="-1"></a>      orig.random.levs <span class="ot">&lt;-</span> <span class="fu">get.orig.levs</span>(object, <span class="at">random.only=</span><span class="cn">TRUE</span>, <span class="at">newdata=</span>newdata.NA)</span>
<span id="cb15-19"><a href="#cb15-19" tabindex="-1"></a>      orig.random.cntr <span class="ot">&lt;-</span> <span class="fu">get.orig.levs</span>(object, <span class="at">random.only=</span><span class="cn">TRUE</span>,</span>
<span id="cb15-20"><a href="#cb15-20" tabindex="-1"></a>                                        <span class="at">FUN=</span>contrasts, <span class="at">sparse=</span>sparse)</span>
<span id="cb15-21"><a href="#cb15-21" tabindex="-1"></a>      <span class="do">## need to let NAs in RE components go through -- they&#39;re handled downstream</span></span>
<span id="cb15-22"><a href="#cb15-22" tabindex="-1"></a>      <span class="cf">if</span> (<span class="fu">inherits</span>(re.form,<span class="st">&quot;formula&quot;</span>)) {</span>
<span id="cb15-23"><a href="#cb15-23" tabindex="-1"></a>          <span class="do">## We use the RE terms *from the original model fit* to construct</span></span>
<span id="cb15-24"><a href="#cb15-24" tabindex="-1"></a>          <span class="do">##  the model frame. This is good for preserving predvars information,</span></span>
<span id="cb15-25"><a href="#cb15-25" tabindex="-1"></a>          <span class="do">##  getting interactions constructed correctly, etc etc etc,</span></span>
<span id="cb15-26"><a href="#cb15-26" tabindex="-1"></a>          <span class="do">##  but can fail if a partial RE specification is used and some of the variables</span></span>
<span id="cb15-27"><a href="#cb15-27" tabindex="-1"></a>          <span class="do">##  in the original RE form are missing from &#39;newdata&#39; ...</span></span>
<span id="cb15-28"><a href="#cb15-28" tabindex="-1"></a>          <span class="do">##  Fill them in as necessary. Filling in NA is OK - these vars won&#39;t actually</span></span>
<span id="cb15-29"><a href="#cb15-29" tabindex="-1"></a>          <span class="do">##  be used later ...</span></span>
<span id="cb15-30"><a href="#cb15-30" tabindex="-1"></a>          pv <span class="ot">&lt;-</span> <span class="fu">attr</span>(tt,<span class="st">&quot;predvars&quot;</span>)</span>
<span id="cb15-31"><a href="#cb15-31" tabindex="-1"></a>          <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>(<span class="fu">length</span>(pv))) {</span>
<span id="cb15-32"><a href="#cb15-32" tabindex="-1"></a>              missvars <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(<span class="fu">all.vars</span>(pv[[i]]), <span class="fu">all.vars</span>(re.form))</span>
<span id="cb15-33"><a href="#cb15-33" tabindex="-1"></a>              <span class="cf">for</span> (mv <span class="cf">in</span> missvars) {</span>
<span id="cb15-34"><a href="#cb15-34" tabindex="-1"></a>                  newdata.NA[[mv]] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb15-35"><a href="#cb15-35" tabindex="-1"></a>              }</span>
<span id="cb15-36"><a href="#cb15-36" tabindex="-1"></a>          }</span>
<span id="cb15-37"><a href="#cb15-37" tabindex="-1"></a>      }</span>
<span id="cb15-38"><a href="#cb15-38" tabindex="-1"></a></span>
<span id="cb15-39"><a href="#cb15-39" tabindex="-1"></a>      <span class="do">## see comments about why suppressWarnings() is needed below ...</span></span>
<span id="cb15-40"><a href="#cb15-40" tabindex="-1"></a>      rfd <span class="ot">&lt;-</span> <span class="fu">suppressWarnings</span>(</span>
<span id="cb15-41"><a href="#cb15-41" tabindex="-1"></a>          <span class="fu">model.frame</span>(tt, newdata.NA, <span class="at">na.action=</span>na.pass, <span class="at">xlev=</span>orig.random.levs))</span>
<span id="cb15-42"><a href="#cb15-42" tabindex="-1"></a>      <span class="do">## restore contrasts (why???)</span></span>
<span id="cb15-43"><a href="#cb15-43" tabindex="-1"></a>      <span class="do">## find *factor* variables involved in terms (left-hand side of RE formula): reset their contrasts</span></span>
<span id="cb15-44"><a href="#cb15-44" tabindex="-1"></a>      <span class="do">## only interested in components in re.form, not al REs</span></span>
<span id="cb15-45"><a href="#cb15-45" tabindex="-1"></a>      ff <span class="ot">&lt;-</span> re.form  <span class="do">## was: formula(object,random.only=TRUE)</span></span>
<span id="cb15-46"><a href="#cb15-46" tabindex="-1"></a>      termvars <span class="ot">&lt;-</span> <span class="fu">unique</span>(<span class="fu">unlist</span>(<span class="fu">lapply</span>(<span class="fu">findbars</span>(ff), <span class="cf">function</span>(x) <span class="fu">all.vars</span>(x[[<span class="dv">2</span>]]))))</span>
<span id="cb15-47"><a href="#cb15-47" tabindex="-1"></a>      <span class="cf">for</span> (fn <span class="cf">in</span> <span class="fu">Reduce</span>(intersect, <span class="fu">list</span>(</span>
<span id="cb15-48"><a href="#cb15-48" tabindex="-1"></a>                            <span class="fu">names</span>(orig.random.cntr), termvars, <span class="fu">names</span>(rfd)))) {</span>
<span id="cb15-49"><a href="#cb15-49" tabindex="-1"></a>          <span class="do">## a non-factor grouping variable *may* sneak in here via simulate(...)</span></span>
<span id="cb15-50"><a href="#cb15-50" tabindex="-1"></a>          <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.factor</span>(rfd[[fn]])) rfd[[fn]] <span class="ot">&lt;-</span> <span class="fu">factor</span>(rfd[[fn]])</span>
<span id="cb15-51"><a href="#cb15-51" tabindex="-1"></a>          <span class="fu">contrasts</span>(rfd[[fn]]) <span class="ot">&lt;-</span> orig.random.cntr[[fn]]</span>
<span id="cb15-52"><a href="#cb15-52" tabindex="-1"></a>      }</span>
<span id="cb15-53"><a href="#cb15-53" tabindex="-1"></a></span>
<span id="cb15-54"><a href="#cb15-54" tabindex="-1"></a>      <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(fixed.na.action))</span>
<span id="cb15-55"><a href="#cb15-55" tabindex="-1"></a>          <span class="fu">attr</span>(rfd,<span class="st">&quot;na.action&quot;</span>) <span class="ot">&lt;-</span> fixed.na.action</span>
<span id="cb15-56"><a href="#cb15-56" tabindex="-1"></a>      <span class="do">##</span></span>
<span id="cb15-57"><a href="#cb15-57" tabindex="-1"></a>      <span class="do">## ## need terms to preserve info about spline/orthog polynomial bases</span></span>
<span id="cb15-58"><a href="#cb15-58" tabindex="-1"></a>      <span class="do">## attr(rfd,&quot;terms&quot;) &lt;- terms(object)</span></span>
<span id="cb15-59"><a href="#cb15-59" tabindex="-1"></a>      <span class="do">## ## ... but variables list messes things up; can we fix it?</span></span>
<span id="cb15-60"><a href="#cb15-60" tabindex="-1"></a>      <span class="do">## vlist &lt;- lapply(all.vars(terms(object)), as.name)</span></span>
<span id="cb15-61"><a href="#cb15-61" tabindex="-1"></a>      <span class="do">## attr(attr(rfd,&quot;terms&quot;),&quot;variables&quot;) &lt;-  as.call(c(quote(list), vlist))</span></span>
<span id="cb15-62"><a href="#cb15-62" tabindex="-1"></a>      <span class="do">##</span></span>
<span id="cb15-63"><a href="#cb15-63" tabindex="-1"></a>      <span class="do">## take out variables that appear *only* in fixed effects</span></span>
<span id="cb15-64"><a href="#cb15-64" tabindex="-1"></a>      <span class="do">## all.v &lt;- all.vars(delete.response(terms(object,fixed.only=FALSE)))</span></span>
<span id="cb15-65"><a href="#cb15-65" tabindex="-1"></a>      <span class="do">## ran.v &lt;- vapply(findbars(formula(object)),all.vars,&quot;&quot;)</span></span>
<span id="cb15-66"><a href="#cb15-66" tabindex="-1"></a>      <span class="do">## fix.v &lt;- all.vars(delete.response(terms(object,fixed.only=TRUE)))</span></span>
<span id="cb15-67"><a href="#cb15-67" tabindex="-1"></a>      <span class="do">## rfd &lt;- model.frame(delete.response(terms(object,fixed.only=FALSE)),</span></span>
<span id="cb15-68"><a href="#cb15-68" tabindex="-1"></a>      <span class="do">## newdata,na.action=na.action)</span></span>
<span id="cb15-69"><a href="#cb15-69" tabindex="-1"></a>  <span class="er">}</span></span></code></pre></div>
<p>and then does execute the following:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">inherits</span>(re.form, <span class="st">&quot;formula&quot;</span>)) {</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>        <span class="do">## DROP values with NAs in fixed effects</span></span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">length</span>(fixed.na.action) <span class="sc">&gt;</span> <span class="dv">0</span>) {</span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>            newdata <span class="ot">&lt;-</span> newdata[<span class="sc">-</span>fixed.na.action,]</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>        }</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a>        <span class="do">## note: mkReTrms automatically *drops* unused levels</span></span>
<span id="cb16-7"><a href="#cb16-7" tabindex="-1"></a>        ReTrms <span class="ot">&lt;-</span> <span class="fu">mkReTrms</span>(<span class="fu">findbars</span>(re.form[[<span class="dv">2</span>]]), rfd)</span>
<span id="cb16-8"><a href="#cb16-8" tabindex="-1"></a>        <span class="do">## update Lambdat (ugh, better way to do this?)</span></span>
<span id="cb16-9"><a href="#cb16-9" tabindex="-1"></a>        ReTrms <span class="ot">&lt;-</span> <span class="fu">within</span>(ReTrms,Lambdat<span class="sc">@</span>x <span class="ot">&lt;-</span> <span class="fu">unname</span>(<span class="fu">getME</span>(object,<span class="st">&quot;theta&quot;</span>)[Lind]))</span></code></pre></div>
<p><code>getME(object, &quot;theta&quot;)</code> gives “random-effects parameter
estimates: these are parameterized as the relative Cholesky factors of
each random effect term” per the docs. It is 0.4132. Since the dimension
is 1, I think this implies the variance of the random effect is <span class="math inline">\(0.4132^2=0.1707\)</span>. So “relative” must be
important, but relative to what?</p>
<p>The model estimates are</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" tabindex="-1"></a>Linear mixed model fit by maximum likelihood  [<span class="st">&#39;lmerMod&#39;</span>]</span>
<span id="cb17-2"><a href="#cb17-2" tabindex="-1"></a>Formula<span class="sc">:</span> ln_los <span class="sc">~</span> (<span class="dv">1</span> <span class="sc">|</span> fid)</span>
<span id="cb17-3"><a href="#cb17-3" tabindex="-1"></a>   Data<span class="sc">:</span> ..<span class="dv">1</span></span>
<span id="cb17-4"><a href="#cb17-4" tabindex="-1"></a>      AIC       BIC    logLik  deviance  df.resid </span>
<span id="cb17-5"><a href="#cb17-5" tabindex="-1"></a> <span class="fl">4891.434</span>  <span class="fl">4909.127</span> <span class="sc">-</span><span class="fl">2442.717</span>  <span class="fl">4885.434</span>      <span class="dv">2688</span> </span>
<span id="cb17-6"><a href="#cb17-6" tabindex="-1"></a>Random effects<span class="sc">:</span></span>
<span id="cb17-7"><a href="#cb17-7" tabindex="-1"></a> Groups   Name        Std.Dev.</span>
<span id="cb17-8"><a href="#cb17-8" tabindex="-1"></a> <span class="fu">fid</span>      (Intercept) <span class="fl">0.2423</span>  </span>
<span id="cb17-9"><a href="#cb17-9" tabindex="-1"></a> Residual             <span class="fl">0.5865</span>  </span>
<span id="cb17-10"><a href="#cb17-10" tabindex="-1"></a>Number of obs<span class="sc">:</span> <span class="dv">2691</span>, groups<span class="sc">:</span>  fid, <span class="dv">68</span></span>
<span id="cb17-11"><a href="#cb17-11" tabindex="-1"></a>Fixed Effects<span class="sc">:</span></span>
<span id="cb17-12"><a href="#cb17-12" tabindex="-1"></a>(Intercept)  </span>
<span id="cb17-13"><a href="#cb17-13" tabindex="-1"></a>      <span class="fl">3.461</span> </span></code></pre></div>
<p><span class="math inline">\(\frac{\sigma_u}{\sigma_\epsilon} =
\frac{0.2423}{0.5865}=0.41313\)</span>, which is probably where the
0.4132 comes from.</p>
<p>We dive into some of the calls made above to understand them. First,
we’ve seen it before, but not the code:</p>
</div>
<div id="findbars" class="section level3">
<h3><code>findbars()</code></h3>
<p>Defined in <code>utilities.R</code> and publicly exported.</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="do">##&#39; From the right hand side of a formula for a mixed-effects model,</span></span>
<span id="cb18-2"><a href="#cb18-2" tabindex="-1"></a><span class="do">##&#39; determine the pairs of expressions that are separated by the</span></span>
<span id="cb18-3"><a href="#cb18-3" tabindex="-1"></a><span class="do">##&#39; vertical bar operator.  Also expand the slash operator in grouping</span></span>
<span id="cb18-4"><a href="#cb18-4" tabindex="-1"></a><span class="do">##&#39; factor expressions and expand terms with the double vertical bar operator</span></span>
<span id="cb18-5"><a href="#cb18-5" tabindex="-1"></a><span class="do">##&#39; into separate, independent random effect terms.</span></span>
<span id="cb18-6"><a href="#cb18-6" tabindex="-1"></a><span class="do">##&#39;</span></span>
<span id="cb18-7"><a href="#cb18-7" tabindex="-1"></a><span class="do">##&#39; @title Determine random-effects expressions from a formula</span></span>
<span id="cb18-8"><a href="#cb18-8" tabindex="-1"></a><span class="do">##&#39; @seealso \code{\link{formula}}, \code{\link{model.frame}}, \code{\link{model.matrix}}.</span></span>
<span id="cb18-9"><a href="#cb18-9" tabindex="-1"></a><span class="do">##&#39; @param term a mixed-model formula</span></span>
<span id="cb18-10"><a href="#cb18-10" tabindex="-1"></a><span class="do">##&#39; @return pairs of expressions that were separated by vertical bars</span></span>
<span id="cb18-11"><a href="#cb18-11" tabindex="-1"></a><span class="do">##&#39; @section Note: This function is called recursively on individual</span></span>
<span id="cb18-12"><a href="#cb18-12" tabindex="-1"></a><span class="do">##&#39; terms in the model, which is why the argument is called \code{term} and not</span></span>
<span id="cb18-13"><a href="#cb18-13" tabindex="-1"></a><span class="do">##&#39; a name like \code{form}, indicating a formula.</span></span>
<span id="cb18-14"><a href="#cb18-14" tabindex="-1"></a><span class="do">##&#39; @example</span></span>
<span id="cb18-15"><a href="#cb18-15" tabindex="-1"></a><span class="do">##&#39; findbars(f1 &lt;- Reaction ~ Days + (Days|Subject))</span></span>
<span id="cb18-16"><a href="#cb18-16" tabindex="-1"></a><span class="do">##&#39; ## =&gt; list( Days | Subject )</span></span>
<span id="cb18-17"><a href="#cb18-17" tabindex="-1"></a><span class="do">##&#39; findbars(y ~ Days + (1|Subject) + (0+Days|Subject))</span></span>
<span id="cb18-18"><a href="#cb18-18" tabindex="-1"></a><span class="do">##&#39; ## =&gt; list of length 2:  list ( 1 | Subject ,  0+Days|Subject)</span></span>
<span id="cb18-19"><a href="#cb18-19" tabindex="-1"></a><span class="do">##&#39; findbars(~ 1 + (1|batch/cask))</span></span>
<span id="cb18-20"><a href="#cb18-20" tabindex="-1"></a><span class="do">##&#39; ## =&gt; list of length 2:  list ( 1 | cask:batch ,  1 | batch)</span></span>
<span id="cb18-21"><a href="#cb18-21" tabindex="-1"></a><span class="do">##&#39; identical(findbars(~ 1 + (Days || Subject)),</span></span>
<span id="cb18-22"><a href="#cb18-22" tabindex="-1"></a><span class="do">##&#39;     findbars(~ 1 + (1|Subject) + (0+Days|Subject)))</span></span>
<span id="cb18-23"><a href="#cb18-23" tabindex="-1"></a><span class="do">##&#39; \dontshow{</span></span>
<span id="cb18-24"><a href="#cb18-24" tabindex="-1"></a><span class="do">##&#39; stopifnot(identical(findbars(f1),</span></span>
<span id="cb18-25"><a href="#cb18-25" tabindex="-1"></a><span class="do">##&#39;                     list(expression(Days | Subject)[[1]])))</span></span>
<span id="cb18-26"><a href="#cb18-26" tabindex="-1"></a><span class="do">##&#39; }</span></span>
<span id="cb18-27"><a href="#cb18-27" tabindex="-1"></a><span class="do">##&#39; @family utilities</span></span>
<span id="cb18-28"><a href="#cb18-28" tabindex="-1"></a><span class="do">##&#39; @keywords models utilities</span></span>
<span id="cb18-29"><a href="#cb18-29" tabindex="-1"></a><span class="do">##&#39; @export</span></span>
<span id="cb18-30"><a href="#cb18-30" tabindex="-1"></a>findbars <span class="ot">&lt;-</span> <span class="cf">function</span>(term)</span>
<span id="cb18-31"><a href="#cb18-31" tabindex="-1"></a>{</span>
<span id="cb18-32"><a href="#cb18-32" tabindex="-1"></a>    <span class="do">## Recursive function applied to individual terms</span></span>
<span id="cb18-33"><a href="#cb18-33" tabindex="-1"></a>    fb <span class="ot">&lt;-</span> <span class="cf">function</span>(term)</span>
<span id="cb18-34"><a href="#cb18-34" tabindex="-1"></a>    {</span>
<span id="cb18-35"><a href="#cb18-35" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.name</span>(term) <span class="sc">||</span> <span class="sc">!</span><span class="fu">is.language</span>(term)) <span class="fu">return</span>(<span class="cn">NULL</span>)</span>
<span id="cb18-36"><a href="#cb18-36" tabindex="-1"></a>        <span class="cf">if</span> (term[[<span class="dv">1</span>]] <span class="sc">==</span> <span class="fu">as.name</span>(<span class="st">&quot;(&quot;</span>)) <span class="fu">return</span>(<span class="fu">fb</span>(term[[<span class="dv">2</span>]]))</span>
<span id="cb18-37"><a href="#cb18-37" tabindex="-1"></a>        <span class="fu">stopifnot</span>(<span class="fu">is.call</span>(term))</span>
<span id="cb18-38"><a href="#cb18-38" tabindex="-1"></a>        <span class="cf">if</span> (term[[<span class="dv">1</span>]] <span class="sc">==</span> <span class="fu">as.name</span>(<span class="st">&#39;|&#39;</span>)) <span class="fu">return</span>(term)</span>
<span id="cb18-39"><a href="#cb18-39" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">length</span>(term) <span class="sc">==</span> <span class="dv">2</span>) <span class="fu">return</span>(<span class="fu">fb</span>(term[[<span class="dv">2</span>]]))</span>
<span id="cb18-40"><a href="#cb18-40" tabindex="-1"></a>        <span class="fu">c</span>(<span class="fu">fb</span>(term[[<span class="dv">2</span>]]), <span class="fu">fb</span>(term[[<span class="dv">3</span>]]))</span>
<span id="cb18-41"><a href="#cb18-41" tabindex="-1"></a>    }</span>
<span id="cb18-42"><a href="#cb18-42" tabindex="-1"></a>    <span class="do">## Expand any slashes in the grouping factors returned by fb</span></span>
<span id="cb18-43"><a href="#cb18-43" tabindex="-1"></a>    expandSlash <span class="ot">&lt;-</span> <span class="cf">function</span>(bb)</span>
<span id="cb18-44"><a href="#cb18-44" tabindex="-1"></a>    {</span>
<span id="cb18-45"><a href="#cb18-45" tabindex="-1"></a>        <span class="do">## Create the interaction terms for nested effects</span></span>
<span id="cb18-46"><a href="#cb18-46" tabindex="-1"></a>        makeInteraction <span class="ot">&lt;-</span> <span class="cf">function</span>(x)</span>
<span id="cb18-47"><a href="#cb18-47" tabindex="-1"></a>        {</span>
<span id="cb18-48"><a href="#cb18-48" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">length</span>(x) <span class="sc">&lt;</span> <span class="dv">2</span>) <span class="fu">return</span>(x)</span>
<span id="cb18-49"><a href="#cb18-49" tabindex="-1"></a>            trm1 <span class="ot">&lt;-</span> <span class="fu">makeInteraction</span>(x[[<span class="dv">1</span>]])</span>
<span id="cb18-50"><a href="#cb18-50" tabindex="-1"></a>            trm11 <span class="ot">&lt;-</span> <span class="cf">if</span>(<span class="fu">is.list</span>(trm1)) trm1[[<span class="dv">1</span>]] <span class="cf">else</span> trm1</span>
<span id="cb18-51"><a href="#cb18-51" tabindex="-1"></a>            <span class="fu">list</span>(<span class="fu">substitute</span>(foo<span class="sc">:</span>bar, <span class="fu">list</span>(<span class="at">foo=</span>x[[<span class="dv">2</span>]], <span class="at">bar =</span> trm11)), trm1)</span>
<span id="cb18-52"><a href="#cb18-52" tabindex="-1"></a>        }</span>
<span id="cb18-53"><a href="#cb18-53" tabindex="-1"></a>        <span class="do">## Return the list of &#39;/&#39;-separated terms</span></span>
<span id="cb18-54"><a href="#cb18-54" tabindex="-1"></a>        slashTerms <span class="ot">&lt;-</span> <span class="cf">function</span>(x)</span>
<span id="cb18-55"><a href="#cb18-55" tabindex="-1"></a>        {</span>
<span id="cb18-56"><a href="#cb18-56" tabindex="-1"></a>            <span class="cf">if</span> (<span class="sc">!</span>(<span class="st">&quot;/&quot;</span> <span class="sc">%in%</span> <span class="fu">all.names</span>(x))) <span class="fu">return</span>(x)</span>
<span id="cb18-57"><a href="#cb18-57" tabindex="-1"></a>            <span class="cf">if</span> (x[[<span class="dv">1</span>]] <span class="sc">!=</span> <span class="fu">as.name</span>(<span class="st">&quot;/&quot;</span>))</span>
<span id="cb18-58"><a href="#cb18-58" tabindex="-1"></a>                <span class="fu">stop</span>(<span class="st">&quot;unparseable formula for grouping factor&quot;</span>,<span class="at">call.=</span><span class="cn">FALSE</span>)</span>
<span id="cb18-59"><a href="#cb18-59" tabindex="-1"></a>            <span class="fu">list</span>(<span class="fu">slashTerms</span>(x[[<span class="dv">2</span>]]), <span class="fu">slashTerms</span>(x[[<span class="dv">3</span>]]))</span>
<span id="cb18-60"><a href="#cb18-60" tabindex="-1"></a>        }</span>
<span id="cb18-61"><a href="#cb18-61" tabindex="-1"></a></span>
<span id="cb18-62"><a href="#cb18-62" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.list</span>(bb))</span>
<span id="cb18-63"><a href="#cb18-63" tabindex="-1"></a>            <span class="fu">expandSlash</span>(<span class="fu">list</span>(bb))</span>
<span id="cb18-64"><a href="#cb18-64" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb18-65"><a href="#cb18-65" tabindex="-1"></a>            <span class="fu">unlist</span>(<span class="fu">lapply</span>(bb, <span class="cf">function</span>(x) {</span>
<span id="cb18-66"><a href="#cb18-66" tabindex="-1"></a>                <span class="cf">if</span> (<span class="fu">length</span>(x) <span class="sc">&gt;</span> <span class="dv">2</span> <span class="sc">&amp;&amp;</span> <span class="fu">is.list</span>(trms <span class="ot">&lt;-</span> <span class="fu">slashTerms</span>(x[[<span class="dv">3</span>]])))</span>
<span id="cb18-67"><a href="#cb18-67" tabindex="-1"></a>                    <span class="do">## lapply(unlist(...)) - unlist returns a flattened list</span></span>
<span id="cb18-68"><a href="#cb18-68" tabindex="-1"></a>                    <span class="fu">lapply</span>(<span class="fu">unlist</span>(<span class="fu">makeInteraction</span>(trms)),</span>
<span id="cb18-69"><a href="#cb18-69" tabindex="-1"></a>                           <span class="cf">function</span>(trm) <span class="fu">substitute</span>(foo<span class="sc">|</span>bar, <span class="fu">list</span>(<span class="at">foo =</span> x[[<span class="dv">2</span>]], <span class="at">bar =</span> trm)))</span>
<span id="cb18-70"><a href="#cb18-70" tabindex="-1"></a>                <span class="cf">else</span> x</span>
<span id="cb18-71"><a href="#cb18-71" tabindex="-1"></a>            }))</span>
<span id="cb18-72"><a href="#cb18-72" tabindex="-1"></a>    }<span class="do">## {expandSlash}</span></span>
<span id="cb18-73"><a href="#cb18-73" tabindex="-1"></a></span>
<span id="cb18-74"><a href="#cb18-74" tabindex="-1"></a>    modterm <span class="ot">&lt;-</span> <span class="fu">expandDoubleVerts</span>(</span>
<span id="cb18-75"><a href="#cb18-75" tabindex="-1"></a>        <span class="cf">if</span>(<span class="fu">is</span>(term, <span class="st">&quot;formula&quot;</span>)) term[[<span class="fu">length</span>(term)]] <span class="cf">else</span> term)</span>
<span id="cb18-76"><a href="#cb18-76" tabindex="-1"></a>    <span class="fu">expandSlash</span>(<span class="fu">fb</span>(modterm))</span>
<span id="cb18-77"><a href="#cb18-77" tabindex="-1"></a>}</span></code></pre></div>
<p>Here’s the function it calls.</p>
</div>
<div id="expanddoubleverts" class="section level3">
<h3><code>expandDoubleVerts()</code></h3>
<p>Defined in <code>utilities.R</code> and publicly exported.</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" tabindex="-1"></a><span class="do">##&#39; From the right hand side of a formula for a mixed-effects model,</span></span>
<span id="cb19-2"><a href="#cb19-2" tabindex="-1"></a><span class="do">##&#39; expand terms with the double vertical bar operator</span></span>
<span id="cb19-3"><a href="#cb19-3" tabindex="-1"></a><span class="do">##&#39; into separate, independent random effect terms.</span></span>
<span id="cb19-4"><a href="#cb19-4" tabindex="-1"></a><span class="do">##&#39;</span></span>
<span id="cb19-5"><a href="#cb19-5" tabindex="-1"></a><span class="do">##&#39; @title Expand terms with \code{&#39;||&#39;} notation into separate \code{&#39;|&#39;} terms</span></span>
<span id="cb19-6"><a href="#cb19-6" tabindex="-1"></a><span class="do">##&#39; @seealso \code{\link{formula}}, \code{\link{model.frame}}, \code{\link{model.matrix}}.</span></span>
<span id="cb19-7"><a href="#cb19-7" tabindex="-1"></a><span class="do">##&#39; @param term a mixed-model formula</span></span>
<span id="cb19-8"><a href="#cb19-8" tabindex="-1"></a><span class="do">##&#39; @return the modified term</span></span>
<span id="cb19-9"><a href="#cb19-9" tabindex="-1"></a><span class="do">##&#39; @family utilities</span></span>
<span id="cb19-10"><a href="#cb19-10" tabindex="-1"></a><span class="do">##&#39; @keywords models utilities</span></span>
<span id="cb19-11"><a href="#cb19-11" tabindex="-1"></a><span class="do">##&#39; @export</span></span>
<span id="cb19-12"><a href="#cb19-12" tabindex="-1"></a>expandDoubleVerts <span class="ot">&lt;-</span> <span class="cf">function</span>(term)</span>
<span id="cb19-13"><a href="#cb19-13" tabindex="-1"></a>{</span>
<span id="cb19-14"><a href="#cb19-14" tabindex="-1"></a>    expandDoubleVert <span class="ot">&lt;-</span> <span class="cf">function</span>(term) {</span>
<span id="cb19-15"><a href="#cb19-15" tabindex="-1"></a>        frml <span class="ot">&lt;-</span> <span class="fu">formula</span>(<span class="fu">substitute</span>(<span class="sc">~</span>x,<span class="fu">list</span>(<span class="at">x=</span>term[[<span class="dv">2</span>]])))</span>
<span id="cb19-16"><a href="#cb19-16" tabindex="-1"></a>        <span class="do">## </span><span class="al">FIXME</span><span class="do">: do this without paste and deparse if possible!</span></span>
<span id="cb19-17"><a href="#cb19-17" tabindex="-1"></a>        <span class="do">## need term.labels not all.vars to capture interactions too:</span></span>
<span id="cb19-18"><a href="#cb19-18" tabindex="-1"></a>        newtrms <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">&quot;0+&quot;</span>, <span class="fu">attr</span>(<span class="fu">terms</span>(frml), <span class="st">&quot;term.labels&quot;</span>))</span>
<span id="cb19-19"><a href="#cb19-19" tabindex="-1"></a>        <span class="cf">if</span>(<span class="fu">attr</span>(<span class="fu">terms</span>(frml), <span class="st">&quot;intercept&quot;</span>)<span class="sc">!=</span><span class="dv">0</span>)</span>
<span id="cb19-20"><a href="#cb19-20" tabindex="-1"></a>            newtrms <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="st">&quot;1&quot;</span>, newtrms)</span>
<span id="cb19-21"><a href="#cb19-21" tabindex="-1"></a></span>
<span id="cb19-22"><a href="#cb19-22" tabindex="-1"></a>        <span class="fu">as.formula</span>(<span class="fu">paste</span>(<span class="st">&quot;~(&quot;</span>,</span>
<span id="cb19-23"><a href="#cb19-23" tabindex="-1"></a>                         <span class="fu">paste</span>(<span class="fu">vapply</span>(newtrms, <span class="cf">function</span>(trm)</span>
<span id="cb19-24"><a href="#cb19-24" tabindex="-1"></a>                                      <span class="fu">paste0</span>(trm, <span class="st">&quot;|&quot;</span>, <span class="fu">deparse</span>(term[[<span class="dv">3</span>]])), <span class="st">&quot;&quot;</span>),</span>
<span id="cb19-25"><a href="#cb19-25" tabindex="-1"></a>                               <span class="at">collapse=</span><span class="st">&quot;)+(&quot;</span>), <span class="st">&quot;)&quot;</span>))[[<span class="dv">2</span>]]</span>
<span id="cb19-26"><a href="#cb19-26" tabindex="-1"></a>    }</span>
<span id="cb19-27"><a href="#cb19-27" tabindex="-1"></a></span>
<span id="cb19-28"><a href="#cb19-28" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.name</span>(term) <span class="sc">&amp;&amp;</span> <span class="fu">is.language</span>(term)) {</span>
<span id="cb19-29"><a href="#cb19-29" tabindex="-1"></a>        <span class="cf">if</span> (term[[<span class="dv">1</span>]] <span class="sc">==</span> <span class="fu">as.name</span>(<span class="st">&quot;(&quot;</span>)) {</span>
<span id="cb19-30"><a href="#cb19-30" tabindex="-1"></a>            term[[<span class="dv">2</span>]] <span class="ot">&lt;-</span> <span class="fu">expandDoubleVerts</span>(term[[<span class="dv">2</span>]])</span>
<span id="cb19-31"><a href="#cb19-31" tabindex="-1"></a>        }</span>
<span id="cb19-32"><a href="#cb19-32" tabindex="-1"></a>        <span class="fu">stopifnot</span>(<span class="fu">is.call</span>(term))</span>
<span id="cb19-33"><a href="#cb19-33" tabindex="-1"></a>        <span class="cf">if</span> (term[[<span class="dv">1</span>]] <span class="sc">==</span> <span class="fu">as.name</span>(<span class="st">&#39;||&#39;</span>))</span>
<span id="cb19-34"><a href="#cb19-34" tabindex="-1"></a>            <span class="fu">return</span>( <span class="fu">expandDoubleVert</span>(term) )</span>
<span id="cb19-35"><a href="#cb19-35" tabindex="-1"></a>        <span class="do">## else :</span></span>
<span id="cb19-36"><a href="#cb19-36" tabindex="-1"></a>        term[[<span class="dv">2</span>]] <span class="ot">&lt;-</span> <span class="fu">expandDoubleVerts</span>(term[[<span class="dv">2</span>]])</span>
<span id="cb19-37"><a href="#cb19-37" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">length</span>(term) <span class="sc">!=</span> <span class="dv">2</span>) {</span>
<span id="cb19-38"><a href="#cb19-38" tabindex="-1"></a>            <span class="cf">if</span>(<span class="fu">length</span>(term) <span class="sc">==</span> <span class="dv">3</span>)</span>
<span id="cb19-39"><a href="#cb19-39" tabindex="-1"></a>                term[[<span class="dv">3</span>]] <span class="ot">&lt;-</span> <span class="fu">expandDoubleVerts</span>(term[[<span class="dv">3</span>]])</span>
<span id="cb19-40"><a href="#cb19-40" tabindex="-1"></a>        }</span>
<span id="cb19-41"><a href="#cb19-41" tabindex="-1"></a>    }</span>
<span id="cb19-42"><a href="#cb19-42" tabindex="-1"></a>    term</span>
<span id="cb19-43"><a href="#cb19-43" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="mkretrms" class="section level3">
<h3><code>mkReTrms()</code></h3>
<p>The sections immediately above here are called while processing the
arguments to pass to <code>mkReTrms()</code>. Here is the function
itself, defined in <code>utilities.R</code> and exported.</p>
<p>This creates a model matrix for the random effects terms, along with
covariance information.</p>
<p>The documentation on the return type describes various important
variables like <code>Zt</code> and <code>Lambdat</code> that are used by
higher-level routines without much explanation (though see user docs on
<code>?getME</code>).</p>
<p><code>Lambdat</code> ends up 68 x 68 diagonal matrix of 1’s. However,
<code>mkNewReTrms()</code> changes them to 0.413 based on
<code>getME(,&quot;theta&quot;)</code>.</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="do">##&#39; From the result of \code{\link{findbars}} applied to a model formula and</span></span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a><span class="do">##&#39; and the evaluation frame, create the model matrix, etc. associated with</span></span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a><span class="do">##&#39; random-effects terms.  See the description of the returned value for a</span></span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a><span class="do">##&#39; detailed list.</span></span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="do">##&#39;</span></span>
<span id="cb20-6"><a href="#cb20-6" tabindex="-1"></a><span class="do">##&#39; @title Create Z, Lambda, Lind, etc.</span></span>
<span id="cb20-7"><a href="#cb20-7" tabindex="-1"></a><span class="do">##&#39; @param bars a list of parsed random-effects terms</span></span>
<span id="cb20-8"><a href="#cb20-8" tabindex="-1"></a><span class="do">##&#39; @param fr a model frame in which to evaluate these terms</span></span>
<span id="cb20-9"><a href="#cb20-9" tabindex="-1"></a><span class="do">##&#39; @return a list with components</span></span>
<span id="cb20-10"><a href="#cb20-10" tabindex="-1"></a><span class="do">##&#39; \item{Zt}{transpose of the sparse model matrix for the random effects}</span></span>
<span id="cb20-11"><a href="#cb20-11" tabindex="-1"></a><span class="do">##&#39; \item{Lambdat}{transpose of the sparse relative covariance factor}</span></span>
<span id="cb20-12"><a href="#cb20-12" tabindex="-1"></a><span class="do">##&#39; \item{Lind}{an integer vector of indices determining the mapping of the</span></span>
<span id="cb20-13"><a href="#cb20-13" tabindex="-1"></a><span class="do">##&#39;     elements of the \code{theta} to the \code{&quot;x&quot;} slot of \code{Lambdat}}</span></span>
<span id="cb20-14"><a href="#cb20-14" tabindex="-1"></a><span class="do">##&#39; \item{theta}{initial values of the covariance parameters}</span></span>
<span id="cb20-15"><a href="#cb20-15" tabindex="-1"></a><span class="do">##&#39; \item{lower}{lower bounds on the covariance parameters}</span></span>
<span id="cb20-16"><a href="#cb20-16" tabindex="-1"></a><span class="do">##&#39; \item{flist}{list of grouping factors used in the random-effects terms}</span></span>
<span id="cb20-17"><a href="#cb20-17" tabindex="-1"></a><span class="do">##&#39; \item{cnms}{a list of column names of the random effects according to</span></span>
<span id="cb20-18"><a href="#cb20-18" tabindex="-1"></a><span class="do">##&#39;     the grouping factors}</span></span>
<span id="cb20-19"><a href="#cb20-19" tabindex="-1"></a><span class="do">##&#39; @importFrom Matrix sparseMatrix drop0</span></span>
<span id="cb20-20"><a href="#cb20-20" tabindex="-1"></a><span class="do">##&#39; @importMethodsFrom Matrix coerce rbind</span></span>
<span id="cb20-21"><a href="#cb20-21" tabindex="-1"></a><span class="do">##&#39; @family utilities</span></span>
<span id="cb20-22"><a href="#cb20-22" tabindex="-1"></a><span class="do">##&#39; @export</span></span>
<span id="cb20-23"><a href="#cb20-23" tabindex="-1"></a>mkReTrms <span class="ot">&lt;-</span> <span class="cf">function</span>(bars, fr, <span class="at">drop.unused.levels=</span><span class="cn">TRUE</span>,</span>
<span id="cb20-24"><a href="#cb20-24" tabindex="-1"></a>                     <span class="at">reorder.terms=</span><span class="cn">TRUE</span>,</span>
<span id="cb20-25"><a href="#cb20-25" tabindex="-1"></a>                     <span class="at">reorder.vars=</span><span class="cn">FALSE</span>) {</span>
<span id="cb20-26"><a href="#cb20-26" tabindex="-1"></a>  <span class="cf">if</span> (<span class="sc">!</span><span class="fu">length</span>(bars))</span>
<span id="cb20-27"><a href="#cb20-27" tabindex="-1"></a>    <span class="fu">stop</span>(<span class="st">&quot;No random effects terms specified in formula&quot;</span>,<span class="at">call.=</span><span class="cn">FALSE</span>)</span>
<span id="cb20-28"><a href="#cb20-28" tabindex="-1"></a>  <span class="fu">stopifnot</span>(<span class="fu">is.list</span>(bars), <span class="fu">vapply</span>(bars, is.language, <span class="cn">NA</span>),</span>
<span id="cb20-29"><a href="#cb20-29" tabindex="-1"></a>            <span class="fu">inherits</span>(fr, <span class="st">&quot;data.frame&quot;</span>))</span>
<span id="cb20-30"><a href="#cb20-30" tabindex="-1"></a>  <span class="fu">names</span>(bars) <span class="ot">&lt;-</span> <span class="fu">barnames</span>(bars)</span>
<span id="cb20-31"><a href="#cb20-31" tabindex="-1"></a>  term.names <span class="ot">&lt;-</span> <span class="fu">vapply</span>(bars, deparse1, <span class="st">&quot;&quot;</span>)</span>
<span id="cb20-32"><a href="#cb20-32" tabindex="-1"></a>  <span class="do">## get component blocks</span></span>
<span id="cb20-33"><a href="#cb20-33" tabindex="-1"></a>  blist <span class="ot">&lt;-</span> <span class="fu">lapply</span>(bars, mkBlist, fr, drop.unused.levels,</span>
<span id="cb20-34"><a href="#cb20-34" tabindex="-1"></a>                  <span class="at">reorder.vars =</span> reorder.vars)</span>
<span id="cb20-35"><a href="#cb20-35" tabindex="-1"></a>  nl <span class="ot">&lt;-</span> <span class="fu">vapply</span>(blist, <span class="st">`</span><span class="at">[[</span><span class="st">`</span>, <span class="dv">0</span><span class="dt">L</span>, <span class="st">&quot;nl&quot;</span>)   <span class="co"># no. of levels per term</span></span>
<span id="cb20-36"><a href="#cb20-36" tabindex="-1"></a>                                        <span class="co"># (in lmer jss:  \ell_i)</span></span>
<span id="cb20-37"><a href="#cb20-37" tabindex="-1"></a></span>
<span id="cb20-38"><a href="#cb20-38" tabindex="-1"></a>  <span class="do">## order terms stably by decreasing number of levels in the factor</span></span>
<span id="cb20-39"><a href="#cb20-39" tabindex="-1"></a>  <span class="cf">if</span> (reorder.terms) {</span>
<span id="cb20-40"><a href="#cb20-40" tabindex="-1"></a>      <span class="cf">if</span> (<span class="fu">any</span>(<span class="fu">diff</span>(nl) <span class="sc">&gt;</span> <span class="dv">0</span>)) {</span>
<span id="cb20-41"><a href="#cb20-41" tabindex="-1"></a>          ord <span class="ot">&lt;-</span> <span class="fu">rev</span>(<span class="fu">order</span>(nl))</span>
<span id="cb20-42"><a href="#cb20-42" tabindex="-1"></a>          blist      <span class="ot">&lt;-</span> blist     [ord]</span>
<span id="cb20-43"><a href="#cb20-43" tabindex="-1"></a>          nl         <span class="ot">&lt;-</span> nl        [ord]</span>
<span id="cb20-44"><a href="#cb20-44" tabindex="-1"></a>          term.names <span class="ot">&lt;-</span> term.names[ord]</span>
<span id="cb20-45"><a href="#cb20-45" tabindex="-1"></a>      }</span>
<span id="cb20-46"><a href="#cb20-46" tabindex="-1"></a>  }</span>
<span id="cb20-47"><a href="#cb20-47" tabindex="-1"></a>  Ztlist <span class="ot">&lt;-</span> <span class="fu">lapply</span>(blist, <span class="st">`</span><span class="at">[[</span><span class="st">`</span>, <span class="st">&quot;sm&quot;</span>)</span>
<span id="cb20-48"><a href="#cb20-48" tabindex="-1"></a>  Zt <span class="ot">&lt;-</span> <span class="fu">do.call</span>(rbind, Ztlist)  <span class="do">## eq. 7, JSS lmer paper</span></span>
<span id="cb20-49"><a href="#cb20-49" tabindex="-1"></a>  <span class="fu">names</span>(Ztlist) <span class="ot">&lt;-</span> term.names</span>
<span id="cb20-50"><a href="#cb20-50" tabindex="-1"></a>  q <span class="ot">&lt;-</span> <span class="fu">nrow</span>(Zt)</span>
<span id="cb20-51"><a href="#cb20-51" tabindex="-1"></a></span>
<span id="cb20-52"><a href="#cb20-52" tabindex="-1"></a>  <span class="do">## Create and install Lambdat, Lind, etc.  This must be done after</span></span>
<span id="cb20-53"><a href="#cb20-53" tabindex="-1"></a>  <span class="do">## any potential reordering of the terms.</span></span>
<span id="cb20-54"><a href="#cb20-54" tabindex="-1"></a>  cnms <span class="ot">&lt;-</span> <span class="fu">lapply</span>(blist, <span class="st">`</span><span class="at">[[</span><span class="st">`</span>, <span class="st">&quot;cnms&quot;</span>)   <span class="co"># list of column names of the</span></span>
<span id="cb20-55"><a href="#cb20-55" tabindex="-1"></a>                                        <span class="co"># model matrix per term</span></span>
<span id="cb20-56"><a href="#cb20-56" tabindex="-1"></a>  nc <span class="ot">&lt;-</span> <span class="fu">lengths</span>(cnms)                   <span class="co"># no. of columns per term</span></span>
<span id="cb20-57"><a href="#cb20-57" tabindex="-1"></a>                                        <span class="co"># (in lmer jss:  p_i)</span></span>
<span id="cb20-58"><a href="#cb20-58" tabindex="-1"></a>  nth <span class="ot">&lt;-</span> <span class="fu">as.integer</span>((nc <span class="sc">*</span> (nc<span class="sc">+</span><span class="dv">1</span>))<span class="sc">/</span><span class="dv">2</span>)    <span class="co"># no. of parameters per term</span></span>
<span id="cb20-59"><a href="#cb20-59" tabindex="-1"></a>                                        <span class="co"># (in lmer jss:  ??)</span></span>
<span id="cb20-60"><a href="#cb20-60" tabindex="-1"></a>  nb <span class="ot">&lt;-</span> nc <span class="sc">*</span> nl                         <span class="co"># no. of random effects per term</span></span>
<span id="cb20-61"><a href="#cb20-61" tabindex="-1"></a>                                        <span class="co"># (in lmer jss:  q_i)</span></span>
<span id="cb20-62"><a href="#cb20-62" tabindex="-1"></a>  <span class="do">## eq. 5, JSS lmer paper</span></span>
<span id="cb20-63"><a href="#cb20-63" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">sum</span>(nb) <span class="sc">!=</span> q) {</span>
<span id="cb20-64"><a href="#cb20-64" tabindex="-1"></a>      <span class="fu">stop</span>(<span class="fu">sprintf</span>(<span class="st">&quot;total number of RE (%d) not equal to nrow(Zt) (%d)&quot;</span>,</span>
<span id="cb20-65"><a href="#cb20-65" tabindex="-1"></a>                   <span class="fu">sum</span>(nb),q))</span>
<span id="cb20-66"><a href="#cb20-66" tabindex="-1"></a>  }</span>
<span id="cb20-67"><a href="#cb20-67" tabindex="-1"></a>  boff <span class="ot">&lt;-</span> <span class="fu">cumsum</span>(<span class="fu">c</span>(<span class="dv">0</span><span class="dt">L</span>, nb))             <span class="co"># offsets into b</span></span>
<span id="cb20-68"><a href="#cb20-68" tabindex="-1"></a>  thoff <span class="ot">&lt;-</span> <span class="fu">cumsum</span>(<span class="fu">c</span>(<span class="dv">0</span><span class="dt">L</span>, nth))           <span class="co"># offsets into theta</span></span>
<span id="cb20-69"><a href="#cb20-69" tabindex="-1"></a>  <span class="do">### </span><span class="al">FIXME</span><span class="do">: should this be done with cBind and avoid the transpose</span></span>
<span id="cb20-70"><a href="#cb20-70" tabindex="-1"></a>  <span class="do">### operator?  In other words should Lambdat be generated directly</span></span>
<span id="cb20-71"><a href="#cb20-71" tabindex="-1"></a>  <span class="do">### instead of generating Lambda first then transposing?</span></span>
<span id="cb20-72"><a href="#cb20-72" tabindex="-1"></a>  Lambdat <span class="ot">&lt;-</span></span>
<span id="cb20-73"><a href="#cb20-73" tabindex="-1"></a>    <span class="fu">t</span>(<span class="fu">do.call</span>(sparseMatrix,</span>
<span id="cb20-74"><a href="#cb20-74" tabindex="-1"></a>              <span class="fu">do.call</span>(rbind,</span>
<span id="cb20-75"><a href="#cb20-75" tabindex="-1"></a>                      <span class="fu">lapply</span>(<span class="fu">seq_along</span>(blist), <span class="cf">function</span>(i)</span>
<span id="cb20-76"><a href="#cb20-76" tabindex="-1"></a>                      {</span>
<span id="cb20-77"><a href="#cb20-77" tabindex="-1"></a>                        mm <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">seq_len</span>(nb[i]), <span class="at">ncol =</span> nc[i],</span>
<span id="cb20-78"><a href="#cb20-78" tabindex="-1"></a>                                     <span class="at">byrow =</span> <span class="cn">TRUE</span>)</span>
<span id="cb20-79"><a href="#cb20-79" tabindex="-1"></a>                        dd <span class="ot">&lt;-</span> <span class="fu">diag</span>(nc[i])</span>
<span id="cb20-80"><a href="#cb20-80" tabindex="-1"></a>                        ltri <span class="ot">&lt;-</span> <span class="fu">lower.tri</span>(dd, <span class="at">diag =</span> <span class="cn">TRUE</span>)</span>
<span id="cb20-81"><a href="#cb20-81" tabindex="-1"></a>                        ii <span class="ot">&lt;-</span> <span class="fu">row</span>(dd)[ltri]</span>
<span id="cb20-82"><a href="#cb20-82" tabindex="-1"></a>                        jj <span class="ot">&lt;-</span> <span class="fu">col</span>(dd)[ltri]</span>
<span id="cb20-83"><a href="#cb20-83" tabindex="-1"></a>                        <span class="do">## unused: dd[cbind(ii, jj)] &lt;- seq_along(ii)</span></span>
<span id="cb20-84"><a href="#cb20-84" tabindex="-1"></a>                        <span class="fu">data.frame</span>(<span class="at">i =</span> <span class="fu">as.vector</span>(mm[, ii]) <span class="sc">+</span> boff[i],</span>
<span id="cb20-85"><a href="#cb20-85" tabindex="-1"></a>                                   <span class="at">j =</span> <span class="fu">as.vector</span>(mm[, jj]) <span class="sc">+</span> boff[i],</span>
<span id="cb20-86"><a href="#cb20-86" tabindex="-1"></a>                                   <span class="at">x =</span> <span class="fu">as.double</span>(<span class="fu">rep.int</span>(<span class="fu">seq_along</span>(ii),</span>
<span id="cb20-87"><a href="#cb20-87" tabindex="-1"></a>                                                         <span class="fu">rep.int</span>(nl[i], <span class="fu">length</span>(ii))) <span class="sc">+</span></span>
<span id="cb20-88"><a href="#cb20-88" tabindex="-1"></a>                                                   thoff[i]))</span>
<span id="cb20-89"><a href="#cb20-89" tabindex="-1"></a>                      }))))</span>
<span id="cb20-90"><a href="#cb20-90" tabindex="-1"></a>  thet <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="fu">sum</span>(nth))</span>
<span id="cb20-91"><a href="#cb20-91" tabindex="-1"></a>  ll <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">Zt =</span> <span class="fu">drop0</span>(Zt), <span class="at">theta =</span> thet, <span class="at">Lind =</span> <span class="fu">as.integer</span>(Lambdat<span class="sc">@</span>x),</span>
<span id="cb20-92"><a href="#cb20-92" tabindex="-1"></a>             <span class="at">Gp =</span> <span class="fu">unname</span>(<span class="fu">c</span>(<span class="dv">0</span><span class="dt">L</span>, <span class="fu">cumsum</span>(nb))))</span>
<span id="cb20-93"><a href="#cb20-93" tabindex="-1"></a>  <span class="do">## lower bounds on theta elements are 0 if on diagonal, else -Inf</span></span>
<span id="cb20-94"><a href="#cb20-94" tabindex="-1"></a>  ll<span class="sc">$</span>lower <span class="ot">&lt;-</span> <span class="sc">-</span><span class="cn">Inf</span> <span class="sc">*</span> (thet <span class="sc">+</span> <span class="dv">1</span>)</span>
<span id="cb20-95"><a href="#cb20-95" tabindex="-1"></a>  ll<span class="sc">$</span>lower[<span class="fu">unique</span>(<span class="fu">diag</span>(Lambdat))] <span class="ot">&lt;-</span> <span class="dv">0</span></span>
<span id="cb20-96"><a href="#cb20-96" tabindex="-1"></a>  ll<span class="sc">$</span>theta[] <span class="ot">&lt;-</span> <span class="fu">is.finite</span>(ll<span class="sc">$</span>lower) <span class="co"># initial values of theta are 0 off-diagonal, 1 on</span></span>
<span id="cb20-97"><a href="#cb20-97" tabindex="-1"></a>  Lambdat<span class="sc">@</span>x[] <span class="ot">&lt;-</span> ll<span class="sc">$</span>theta[ll<span class="sc">$</span>Lind]  <span class="co"># initialize elements of Lambdat</span></span>
<span id="cb20-98"><a href="#cb20-98" tabindex="-1"></a>  ll<span class="sc">$</span>Lambdat <span class="ot">&lt;-</span> Lambdat</span>
<span id="cb20-99"><a href="#cb20-99" tabindex="-1"></a>  <span class="co"># massage the factor list</span></span>
<span id="cb20-100"><a href="#cb20-100" tabindex="-1"></a>  fl <span class="ot">&lt;-</span> <span class="fu">lapply</span>(blist, <span class="st">`</span><span class="at">[[</span><span class="st">`</span>, <span class="st">&quot;ff&quot;</span>)</span>
<span id="cb20-101"><a href="#cb20-101" tabindex="-1"></a>  <span class="co"># check for repeated factors</span></span>
<span id="cb20-102"><a href="#cb20-102" tabindex="-1"></a>  fnms <span class="ot">&lt;-</span> <span class="fu">names</span>(fl)</span>
<span id="cb20-103"><a href="#cb20-103" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">length</span>(fnms) <span class="sc">&gt;</span> <span class="fu">length</span>(ufn <span class="ot">&lt;-</span> <span class="fu">unique</span>(fnms))) {</span>
<span id="cb20-104"><a href="#cb20-104" tabindex="-1"></a>    fl <span class="ot">&lt;-</span> fl[<span class="fu">match</span>(ufn, fnms)]</span>
<span id="cb20-105"><a href="#cb20-105" tabindex="-1"></a>    asgn <span class="ot">&lt;-</span> <span class="fu">match</span>(fnms, ufn)</span>
<span id="cb20-106"><a href="#cb20-106" tabindex="-1"></a>  } <span class="cf">else</span> asgn <span class="ot">&lt;-</span> <span class="fu">seq_along</span>(fl)</span>
<span id="cb20-107"><a href="#cb20-107" tabindex="-1"></a>  <span class="fu">names</span>(fl) <span class="ot">&lt;-</span> ufn</span>
<span id="cb20-108"><a href="#cb20-108" tabindex="-1"></a>  <span class="do">## DON&#39;T need fl to be a data.frame ...</span></span>
<span id="cb20-109"><a href="#cb20-109" tabindex="-1"></a>  <span class="do">## fl &lt;- do.call(data.frame, c(fl, check.names = FALSE))</span></span>
<span id="cb20-110"><a href="#cb20-110" tabindex="-1"></a>  <span class="fu">attr</span>(fl, <span class="st">&quot;assign&quot;</span>) <span class="ot">&lt;-</span> asgn</span>
<span id="cb20-111"><a href="#cb20-111" tabindex="-1"></a>  ll<span class="sc">$</span>flist <span class="ot">&lt;-</span> fl</span>
<span id="cb20-112"><a href="#cb20-112" tabindex="-1"></a>  ll<span class="sc">$</span>cnms <span class="ot">&lt;-</span> cnms</span>
<span id="cb20-113"><a href="#cb20-113" tabindex="-1"></a>  ll<span class="sc">$</span>Ztlist <span class="ot">&lt;-</span> Ztlist</span>
<span id="cb20-114"><a href="#cb20-114" tabindex="-1"></a>  ll<span class="sc">$</span>nl <span class="ot">&lt;-</span> nl</span>
<span id="cb20-115"><a href="#cb20-115" tabindex="-1"></a>  ll</span>
<span id="cb20-116"><a href="#cb20-116" tabindex="-1"></a>} <span class="do">## {mkReTrms}</span></span></code></pre></div>
</div>
<div id="mkblist" class="section level3">
<h3><code>mkBlist()</code></h3>
<p>Called from <code>mkReTrms()</code>, defined in
<code>utilities.R</code> but <em>not</em> exported.
<code>fac2sparse</code> makes a sparse matrix (68 x 2691) from the
random effects levels. The Khatri-Rao product is a column-wise Kronecker
product, which in my case seems simply to transpose the sparse
matrix.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" tabindex="-1"></a><span class="do">##&#39; @param x a language object of the form  effect | groupvar</span></span>
<span id="cb21-2"><a href="#cb21-2" tabindex="-1"></a><span class="do">##&#39; @param frloc model frame</span></span>
<span id="cb21-3"><a href="#cb21-3" tabindex="-1"></a><span class="do">##&#39; @param drop.unused.levels (logical)</span></span>
<span id="cb21-4"><a href="#cb21-4" tabindex="-1"></a><span class="do">##&#39; @return list containing grouping factor, sparse model matrix, number of levels, names</span></span>
<span id="cb21-5"><a href="#cb21-5" tabindex="-1"></a>mkBlist <span class="ot">&lt;-</span> <span class="cf">function</span>(x,frloc, <span class="at">drop.unused.levels=</span><span class="cn">TRUE</span>,</span>
<span id="cb21-6"><a href="#cb21-6" tabindex="-1"></a>                    <span class="at">reorder.vars=</span><span class="cn">FALSE</span>) {</span>
<span id="cb21-7"><a href="#cb21-7" tabindex="-1"></a>    frloc <span class="ot">&lt;-</span> <span class="fu">factorize</span>(x,frloc)</span>
<span id="cb21-8"><a href="#cb21-8" tabindex="-1"></a>    <span class="do">## try to evaluate grouping factor within model frame ...</span></span>
<span id="cb21-9"><a href="#cb21-9" tabindex="-1"></a>    ff0 <span class="ot">&lt;-</span> <span class="fu">replaceTerm</span>(x[[<span class="dv">3</span>]], <span class="fu">quote</span>(<span class="st">`</span><span class="at">:</span><span class="st">`</span>), <span class="fu">quote</span>(<span class="st">`</span><span class="at">%i%</span><span class="st">`</span>))</span>
<span id="cb21-10"><a href="#cb21-10" tabindex="-1"></a>    ff <span class="ot">&lt;-</span> <span class="fu">try</span>(<span class="fu">eval</span>(<span class="fu">substitute</span>(<span class="fu">makeFac</span>(fac),</span>
<span id="cb21-11"><a href="#cb21-11" tabindex="-1"></a>                              <span class="fu">list</span>(<span class="at">fac =</span> ff0)),</span>
<span id="cb21-12"><a href="#cb21-12" tabindex="-1"></a>                   frloc), <span class="at">silent =</span> <span class="cn">TRUE</span>)</span>
<span id="cb21-13"><a href="#cb21-13" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">inherits</span>(ff, <span class="st">&quot;try-error&quot;</span>)) {</span>
<span id="cb21-14"><a href="#cb21-14" tabindex="-1"></a>        <span class="fu">stop</span>(<span class="st">&quot;couldn&#39;t evaluate grouping factor &quot;</span>,</span>
<span id="cb21-15"><a href="#cb21-15" tabindex="-1"></a>             <span class="fu">deparse1</span>(x[[<span class="dv">3</span>]]),<span class="st">&quot; within model frame:&quot;</span>,</span>
<span id="cb21-16"><a href="#cb21-16" tabindex="-1"></a>             <span class="st">&quot;error =&quot;</span>,</span>
<span id="cb21-17"><a href="#cb21-17" tabindex="-1"></a>             <span class="fu">c</span>(ff),</span>
<span id="cb21-18"><a href="#cb21-18" tabindex="-1"></a>             <span class="st">&quot; Try adding grouping factor to data &quot;</span>,</span>
<span id="cb21-19"><a href="#cb21-19" tabindex="-1"></a>             <span class="st">&quot;frame explicitly if possible&quot;</span>,<span class="at">call.=</span><span class="cn">FALSE</span>)</span>
<span id="cb21-20"><a href="#cb21-20" tabindex="-1"></a>    }</span>
<span id="cb21-21"><a href="#cb21-21" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">all</span>(<span class="fu">is.na</span>(ff)))</span>
<span id="cb21-22"><a href="#cb21-22" tabindex="-1"></a>        <span class="fu">stop</span>(<span class="st">&quot;Invalid grouping factor specification, &quot;</span>,</span>
<span id="cb21-23"><a href="#cb21-23" tabindex="-1"></a>             <span class="fu">deparse1</span>(x[[<span class="dv">3</span>]]),<span class="at">call.=</span><span class="cn">FALSE</span>)</span>
<span id="cb21-24"><a href="#cb21-24" tabindex="-1"></a>    <span class="do">## NB: *also* silently drops &lt;NA&gt; levels - and mkReTrms() and hence</span></span>
<span id="cb21-25"><a href="#cb21-25" tabindex="-1"></a>    <span class="do">##     predict.merMod() have relied on that property  :</span></span>
<span id="cb21-26"><a href="#cb21-26" tabindex="-1"></a>    <span class="cf">if</span> (drop.unused.levels) ff <span class="ot">&lt;-</span> <span class="fu">factor</span>(ff, <span class="at">exclude=</span><span class="cn">NA</span>)</span>
<span id="cb21-27"><a href="#cb21-27" tabindex="-1"></a>    nl <span class="ot">&lt;-</span> <span class="fu">length</span>(<span class="fu">levels</span>(ff))</span>
<span id="cb21-28"><a href="#cb21-28" tabindex="-1"></a>    <span class="do">## this section implements eq. 6 of the JSS lmer paper</span></span>
<span id="cb21-29"><a href="#cb21-29" tabindex="-1"></a>    <span class="do">## model matrix based on LHS of random effect term (X_i)</span></span>
<span id="cb21-30"><a href="#cb21-30" tabindex="-1"></a>    <span class="do">##    x[[2]] is the LHS (terms) of the a|b formula</span></span>
<span id="cb21-31"><a href="#cb21-31" tabindex="-1"></a>    has.sparse.contrasts <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb21-32"><a href="#cb21-32" tabindex="-1"></a>      cc <span class="ot">&lt;-</span> <span class="fu">attr</span>(x, <span class="st">&quot;contrasts&quot;</span>)</span>
<span id="cb21-33"><a href="#cb21-33" tabindex="-1"></a>      <span class="sc">!</span><span class="fu">is.null</span>(cc) <span class="sc">&amp;&amp;</span> <span class="fu">is</span>(cc, <span class="st">&quot;sparseMatrix&quot;</span>)</span>
<span id="cb21-34"><a href="#cb21-34" tabindex="-1"></a>    }</span>
<span id="cb21-35"><a href="#cb21-35" tabindex="-1"></a>    any.sparse.contrasts <span class="ot">&lt;-</span> <span class="fu">any</span>(<span class="fu">vapply</span>(frloc, has.sparse.contrasts, <span class="at">FUN.VALUE =</span> <span class="cn">TRUE</span>))</span>
<span id="cb21-36"><a href="#cb21-36" tabindex="-1"></a>    mMatrix <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="sc">!</span>any.sparse.contrasts) model.matrix <span class="cf">else</span> sparse.model.matrix</span>
<span id="cb21-37"><a href="#cb21-37" tabindex="-1"></a>    mm <span class="ot">&lt;-</span> <span class="fu">mMatrix</span>(<span class="fu">eval</span>(<span class="fu">substitute</span>( <span class="sc">~</span> foo, <span class="fu">list</span>(<span class="at">foo =</span> x[[<span class="dv">2</span>]]))), frloc)</span>
<span id="cb21-38"><a href="#cb21-38" tabindex="-1"></a>    <span class="cf">if</span> (reorder.vars) {</span>
<span id="cb21-39"><a href="#cb21-39" tabindex="-1"></a>        mm <span class="ot">&lt;-</span> mm[<span class="fu">colSort</span>(<span class="fu">colnames</span>(mm)),]</span>
<span id="cb21-40"><a href="#cb21-40" tabindex="-1"></a>    }</span>
<span id="cb21-41"><a href="#cb21-41" tabindex="-1"></a>    <span class="do">## this is J^T (see p. 9 of JSS lmer paper)</span></span>
<span id="cb21-42"><a href="#cb21-42" tabindex="-1"></a>    <span class="do">## construct indicator matrix for groups by observations</span></span>
<span id="cb21-43"><a href="#cb21-43" tabindex="-1"></a>    <span class="do">## use fac2sparse() rather than as() to allow *not* dropping</span></span>
<span id="cb21-44"><a href="#cb21-44" tabindex="-1"></a>    <span class="do">## unused levels where desired</span></span>
<span id="cb21-45"><a href="#cb21-45" tabindex="-1"></a>    sm <span class="ot">&lt;-</span> <span class="fu">fac2sparse</span>(ff, <span class="at">to =</span> <span class="st">&quot;d&quot;</span>,</span>
<span id="cb21-46"><a href="#cb21-46" tabindex="-1"></a>                     <span class="at">drop.unused.levels =</span> drop.unused.levels)</span>
<span id="cb21-47"><a href="#cb21-47" tabindex="-1"></a>    sm <span class="ot">&lt;-</span> <span class="fu">KhatriRao</span>(sm, <span class="fu">t</span>(mm))</span>
<span id="cb21-48"><a href="#cb21-48" tabindex="-1"></a>    <span class="fu">dimnames</span>(sm) <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb21-49"><a href="#cb21-49" tabindex="-1"></a>        <span class="fu">rep</span>(<span class="fu">levels</span>(ff),<span class="at">each=</span><span class="fu">ncol</span>(mm)),</span>
<span id="cb21-50"><a href="#cb21-50" tabindex="-1"></a>        <span class="fu">rownames</span>(mm))</span>
<span id="cb21-51"><a href="#cb21-51" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">ff =</span> ff, <span class="at">sm =</span> sm, <span class="at">nl =</span> nl, <span class="at">cnms =</span> <span class="fu">colnames</span>(mm))</span>
<span id="cb21-52"><a href="#cb21-52" tabindex="-1"></a>}</span></code></pre></div>
</div>
<div id="mknewretrms-continued" class="section level3">
<h3><code>mkNewReTrms()</code> continued</h3>
<p>Some final cleanup, and the actual extraction of the random effects
values via <code>ranef()</code> a few lines below here, and the function
finally returns the results.</p>
<p>Since I will not be using the random effects estimates, there is some
wasted work here. But that work is likely only the retrieval of values
already computed.</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span>allow.new.levels <span class="sc">&amp;&amp;</span> <span class="fu">any</span>(<span class="fu">vapply</span>(ReTrms<span class="sc">$</span>flist, anyNA, <span class="cn">NA</span>)))</span>
<span id="cb22-2"><a href="#cb22-2" tabindex="-1"></a>            <span class="fu">stop</span>(<span class="st">&quot;NAs are not allowed in prediction data&quot;</span>,</span>
<span id="cb22-3"><a href="#cb22-3" tabindex="-1"></a>                 <span class="st">&quot; for grouping variables unless allow.new.levels is TRUE&quot;</span>)</span>
<span id="cb22-4"><a href="#cb22-4" tabindex="-1"></a>        ns.re <span class="ot">&lt;-</span> <span class="fu">names</span>(re <span class="ot">&lt;-</span> <span class="fu">ranef</span>(object, <span class="at">condVar =</span> <span class="cn">FALSE</span>))</span>
<span id="cb22-5"><a href="#cb22-5" tabindex="-1"></a>        nRnms <span class="ot">&lt;-</span> <span class="fu">names</span>(Rcnms <span class="ot">&lt;-</span> ReTrms<span class="sc">$</span>cnms)</span>
<span id="cb22-6"><a href="#cb22-6" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span><span class="fu">all</span>(nRnms <span class="sc">%in%</span> ns.re))</span>
<span id="cb22-7"><a href="#cb22-7" tabindex="-1"></a>            <span class="fu">stop</span>(<span class="st">&quot;grouping factors specified in re.form that were not present in original model&quot;</span>)</span>
<span id="cb22-8"><a href="#cb22-8" tabindex="-1"></a>        new_levels <span class="ot">&lt;-</span> <span class="fu">lapply</span>(ReTrms<span class="sc">$</span>flist, <span class="cf">function</span>(x) <span class="fu">levels</span>(<span class="fu">factor</span>(x)))</span>
<span id="cb22-9"><a href="#cb22-9" tabindex="-1"></a>        <span class="do">## fill in/delete levels as appropriate</span></span>
<span id="cb22-10"><a href="#cb22-10" tabindex="-1"></a>        re_x <span class="ot">&lt;-</span> <span class="fu">Map</span>(<span class="cf">function</span>(r,n) <span class="fu">levelfun</span>(r,n,</span>
<span id="cb22-11"><a href="#cb22-11" tabindex="-1"></a>                                           <span class="at">allow.new.levels=</span>allow.new.levels),</span>
<span id="cb22-12"><a href="#cb22-12" tabindex="-1"></a>                    re[<span class="fu">names</span>(new_levels)],</span>
<span id="cb22-13"><a href="#cb22-13" tabindex="-1"></a>                    new_levels)</span>
<span id="cb22-14"><a href="#cb22-14" tabindex="-1"></a>        <span class="do">## pick out random effects values that correspond to</span></span>
<span id="cb22-15"><a href="#cb22-15" tabindex="-1"></a>        <span class="do">##  random effects incorporated in re.form ...</span></span>
<span id="cb22-16"><a href="#cb22-16" tabindex="-1"></a>        <span class="do">## NB: Need integer indexing, as nRnms can be duplicated: (age|Subj) + (sex|Subj) :</span></span>
<span id="cb22-17"><a href="#cb22-17" tabindex="-1"></a>        hacked_names <span class="ot">&lt;-</span> <span class="cn">FALSE</span></span>
<span id="cb22-18"><a href="#cb22-18" tabindex="-1"></a>        get_re <span class="ot">&lt;-</span> <span class="cf">function</span>(rname, cnms) {</span>
<span id="cb22-19"><a href="#cb22-19" tabindex="-1"></a>            nms <span class="ot">&lt;-</span> <span class="fu">names</span>(re[[rname]])</span>
<span id="cb22-20"><a href="#cb22-20" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">identical</span>(cnms,<span class="st">&quot;(Intercept)&quot;</span>) <span class="sc">&amp;&amp;</span> <span class="fu">length</span>(nms)<span class="sc">==</span><span class="dv">1</span> <span class="sc">&amp;&amp;</span> <span class="fu">grepl</span>(<span class="st">&quot;^s(.*)$&quot;</span>,nms)) {</span>
<span id="cb22-21"><a href="#cb22-21" tabindex="-1"></a>                <span class="do">## </span><span class="al">HACK</span><span class="do"> to allow gamm4 prediction</span></span>
<span id="cb22-22"><a href="#cb22-22" tabindex="-1"></a>                hacked_names <span class="ot">&lt;&lt;-</span> <span class="cn">TRUE</span></span>
<span id="cb22-23"><a href="#cb22-23" tabindex="-1"></a>                cnms <span class="ot">&lt;-</span> nms</span>
<span id="cb22-24"><a href="#cb22-24" tabindex="-1"></a>            }</span>
<span id="cb22-25"><a href="#cb22-25" tabindex="-1"></a>            miss_names <span class="ot">&lt;-</span> <span class="fu">setdiff</span>(cnms, nms)</span>
<span id="cb22-26"><a href="#cb22-26" tabindex="-1"></a>            <span class="cf">if</span> (<span class="fu">length</span>(miss_names)<span class="sc">&gt;</span><span class="dv">0</span>) {</span>
<span id="cb22-27"><a href="#cb22-27" tabindex="-1"></a>                <span class="fu">stop</span>(<span class="st">&quot;random effects specified in re.form that were not present in original model &quot;</span>,</span>
<span id="cb22-28"><a href="#cb22-28" tabindex="-1"></a>                     <span class="fu">paste</span>(miss_names, <span class="at">collapse=</span><span class="st">&quot;, &quot;</span>))</span>
<span id="cb22-29"><a href="#cb22-29" tabindex="-1"></a>            }</span>
<span id="cb22-30"><a href="#cb22-30" tabindex="-1"></a>            <span class="fu">t</span>(re_x[[rname]][,cnms]) <span class="do">## transpose to make sure unlisting works</span></span>
<span id="cb22-31"><a href="#cb22-31" tabindex="-1"></a>        }</span>
<span id="cb22-32"><a href="#cb22-32" tabindex="-1"></a>        re_new <span class="ot">&lt;-</span> <span class="fu">unlist</span>(<span class="fu">Map</span>(get_re, nRnms, Rcnms))</span>
<span id="cb22-33"><a href="#cb22-33" tabindex="-1"></a>        <span class="do">## only issue warning once per prediction ...</span></span>
<span id="cb22-34"><a href="#cb22-34" tabindex="-1"></a>        <span class="cf">if</span> (hacked_names) <span class="fu">warning</span>(<span class="st">&quot;modified RE names for gamm4 prediction&quot;</span>)</span>
<span id="cb22-35"><a href="#cb22-35" tabindex="-1"></a>    <span class="er">}</span></span>
<span id="cb22-36"><a href="#cb22-36" tabindex="-1"></a>    Zt <span class="ot">&lt;-</span> ReTrms<span class="sc">$</span>Zt</span>
<span id="cb22-37"><a href="#cb22-37" tabindex="-1"></a>    <span class="fu">attr</span>(Zt, <span class="st">&quot;na.action&quot;</span>) <span class="ot">&lt;-</span> <span class="fu">attr</span>(re_new, <span class="st">&quot;na.action&quot;</span>) <span class="ot">&lt;-</span> fixed.na.action</span>
<span id="cb22-38"><a href="#cb22-38" tabindex="-1"></a>    <span class="fu">list</span>(<span class="at">Zt=</span>Zt, <span class="at">b=</span>re_new, <span class="at">Lambdat =</span> ReTrms<span class="sc">$</span>Lambdat)</span>
<span id="cb22-39"><a href="#cb22-39" tabindex="-1"></a><span class="er">}</span></span></code></pre></div>
<p>This concludes the excursion into functions called from
<code>simulate()</code>. We now return to the main code.</p>
</div>
<div id="adding-random-and-fixed-effects" class="section level3">
<h3>Adding Random and Fixed Effects</h3>
<p><code>sim.reff</code> now has some eccentrically scaled (<span class="math inline">\(\sigma=\frac{\sigma_u}{\sigma_\epsilon}\)</span>)
random effects in a number of observations x number of simulations
matrix. All observations in the same cluster will share the same random
effect (within a simulation, of course).</p>
<p>We previously computed <code>etapred</code> with the fixed effect
part of the linear predictor. We need to combine them, scale things
properly, generate additional <span class="math inline">\(\epsilon\)</span> for the normal model, and
convert to the outcome scale to have the right simulated data.</p>
<p>First, the linear/normal case, which is the active branch for us.
Notice that “sigma” below is <span class="math inline">\(\sigma_\epsilon\)</span>, so that
<code>sim.reff</code> after multiplication has <span class="math inline">\(\sigma_u\)</span>, and the standardized noise term
ends with <span class="math inline">\(\sigma_\epsilon\)</span>
<em>if</em> <code>cond.sim</code> is <code>TRUE</code>, which it is.</p>
<p>The help (which is not done via <code>Roxygen2</code>) says
<code>cond.sim</code> is</p>
<blockquote>
<p>(experimental) simulate the conditional distribution? if FALSE,
simulate only random effects; do not simulate from the conditional
distribution, rather return the predicted group-level values</p>
</blockquote>
<div class="sourceCode" id="cb23"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" tabindex="-1"></a>    val <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="fu">isLMM</span>(object)) {</span>
<span id="cb23-2"><a href="#cb23-2" tabindex="-1"></a>          <span class="do">## result will be matrix  n x nsim :</span></span>
<span id="cb23-3"><a href="#cb23-3" tabindex="-1"></a>          etapred <span class="sc">+</span> sigma <span class="sc">*</span> (sim.reff <span class="sc">+</span></span>
<span id="cb23-4"><a href="#cb23-4" tabindex="-1"></a>                               <span class="do">## residual contribution:</span></span>
<span id="cb23-5"><a href="#cb23-5" tabindex="-1"></a>                               <span class="cf">if</span> (cond.sim)</span>
<span id="cb23-6"><a href="#cb23-6" tabindex="-1"></a>                                   <span class="fu">matrix</span>(<span class="fu">rnorm</span>(n <span class="sc">*</span> nsim), <span class="at">ncol =</span> nsim)</span>
<span id="cb23-7"><a href="#cb23-7" tabindex="-1"></a>                               <span class="cf">else</span> <span class="dv">0</span>)</span></code></pre></div>
<p>The non-linear case follows. Not scaling the random effects looks
odd, but then again there is no <span class="math inline">\(\sigma_\epsilon\)</span> for most or all of these
models. Which of course raise the question of what the “relative”
covariance of the prior cases is; probably just the covariance.</p>
<p>The <code>nsim = 1</code> in</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a>             val <span class="ot">&lt;-</span> <span class="fu">sfun</span>(object, <span class="at">nsim=</span><span class="dv">1</span>, <span class="at">ftd =</span> <span class="fu">rep_len</span>(musim, n<span class="sc">*</span>nsim),</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>                         <span class="at">wts =</span> weights)</span></code></pre></div>
<p>below (in a branch that would be active since
<code>cond.sim == TRUE</code>) is also disturbing, although
<code>ftd</code> does incorporate all the simulation.</p>
<p>At any rate this must translate <span class="math inline">\(\eta\)</span> back to <span class="math inline">\(\mu\)</span> and then generate random draws from
the appropriate family. Each family has its own function, defined at the
bottom of <code>predict.R</code> along with <code>simfunList</code> that
collects them all. The appear at the <a href="#inner-simulation-functions">end</a> of these notes.</p>
<div class="sourceCode" id="cb25"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb25-1"><a href="#cb25-1" tabindex="-1"></a>    <span class="er">}</span> <span class="cf">else</span> <span class="cf">if</span> (<span class="fu">isGLMM</span>(object)) {</span>
<span id="cb25-2"><a href="#cb25-2" tabindex="-1"></a>        <span class="do">## GLMM</span></span>
<span id="cb25-3"><a href="#cb25-3" tabindex="-1"></a>        <span class="do">## n.b. DON&#39;T scale random-effects (???)</span></span>
<span id="cb25-4"><a href="#cb25-4" tabindex="-1"></a>        etasim <span class="ot">&lt;-</span> etapred<span class="sc">+</span>sim.reff</span>
<span id="cb25-5"><a href="#cb25-5" tabindex="-1"></a>        family <span class="ot">&lt;-</span> <span class="fu">normalizeFamilyName</span>(object<span class="sc">@</span>resp<span class="sc">$</span>family)</span>
<span id="cb25-6"><a href="#cb25-6" tabindex="-1"></a>        musim <span class="ot">&lt;-</span> family<span class="sc">$</span><span class="fu">linkinv</span>(etasim) <span class="co">#-&gt; family$family == &quot;negative.binomial&quot; if(NB)</span></span>
<span id="cb25-7"><a href="#cb25-7" tabindex="-1"></a>        <span class="do">## ntot &lt;- length(musim) ## </span><span class="al">FIXME</span><span class="do">: or could be dims[&quot;n&quot;]?</span></span>
<span id="cb25-8"><a href="#cb25-8" tabindex="-1"></a>        <span class="do">##</span></span>
<span id="cb25-9"><a href="#cb25-9" tabindex="-1"></a></span>
<span id="cb25-10"><a href="#cb25-10" tabindex="-1"></a>        <span class="cf">if</span> (family<span class="sc">$</span>family<span class="sc">==</span><span class="st">&quot;binomial&quot;</span> <span class="sc">&amp;&amp;</span> <span class="fu">is.matrix</span>(r <span class="ot">&lt;-</span> <span class="fu">model.response</span>(object<span class="sc">@</span>frame))) {</span>
<span id="cb25-11"><a href="#cb25-11" tabindex="-1"></a></span>
<span id="cb25-12"><a href="#cb25-12" tabindex="-1"></a>            <span class="co"># unless the user passed in new weights, take them from the response matrix</span></span>
<span id="cb25-13"><a href="#cb25-13" tabindex="-1"></a>            <span class="co"># e.g. cbind(incidence, size-incidence) ~ ...</span></span>
<span id="cb25-14"><a href="#cb25-14" tabindex="-1"></a>            <span class="cf">if</span>(nullWts) weights <span class="ot">&lt;-</span> <span class="fu">rowSums</span>(r)</span>
<span id="cb25-15"><a href="#cb25-15" tabindex="-1"></a>        }</span>
<span id="cb25-16"><a href="#cb25-16" tabindex="-1"></a></span>
<span id="cb25-17"><a href="#cb25-17" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.null</span>(sfun <span class="ot">&lt;-</span> simfunList[[family<span class="sc">$</span>family]])) {</span>
<span id="cb25-18"><a href="#cb25-18" tabindex="-1"></a>            <span class="do">## family$simulate just won&#39;t work ...</span></span>
<span id="cb25-19"><a href="#cb25-19" tabindex="-1"></a>            <span class="do">## sim funs must be hard-coded, see below</span></span>
<span id="cb25-20"><a href="#cb25-20" tabindex="-1"></a>            <span class="fu">stop</span>(<span class="st">&quot;simulation not implemented for family &quot;</span>,</span>
<span id="cb25-21"><a href="#cb25-21" tabindex="-1"></a>                 <span class="fu">sQuote</span>(family<span class="sc">$</span>family))</span>
<span id="cb25-22"><a href="#cb25-22" tabindex="-1"></a>        }</span>
<span id="cb25-23"><a href="#cb25-23" tabindex="-1"></a></span>
<span id="cb25-24"><a href="#cb25-24" tabindex="-1"></a>        <span class="do">## don&#39;t rely on automatic recycling</span></span>
<span id="cb25-25"><a href="#cb25-25" tabindex="-1"></a>        <span class="cf">if</span> (cond.sim) {</span>
<span id="cb25-26"><a href="#cb25-26" tabindex="-1"></a>             val <span class="ot">&lt;-</span> <span class="fu">sfun</span>(object, <span class="at">nsim=</span><span class="dv">1</span>, <span class="at">ftd =</span> <span class="fu">rep_len</span>(musim, n<span class="sc">*</span>nsim),</span>
<span id="cb25-27"><a href="#cb25-27" tabindex="-1"></a>                         <span class="at">wts =</span> weights)</span>
<span id="cb25-28"><a href="#cb25-28" tabindex="-1"></a>        } <span class="cf">else</span> {</span>
<span id="cb25-29"><a href="#cb25-29" tabindex="-1"></a>             val  <span class="ot">&lt;-</span> <span class="fu">rep_len</span>(musim, n<span class="sc">*</span>nsim)</span>
<span id="cb25-30"><a href="#cb25-30" tabindex="-1"></a>        }</span>
<span id="cb25-31"><a href="#cb25-31" tabindex="-1"></a>        <span class="do">## split results into nsims: need special case for binomial matrix/factor responses</span></span>
<span id="cb25-32"><a href="#cb25-32" tabindex="-1"></a>        <span class="cf">if</span> (family<span class="sc">$</span>family<span class="sc">==</span><span class="st">&quot;binomial&quot;</span> <span class="sc">&amp;&amp;</span> <span class="fu">is.matrix</span>(r <span class="ot">&lt;-</span> <span class="fu">model.response</span>(object<span class="sc">@</span>frame))) {</span>
<span id="cb25-33"><a href="#cb25-33" tabindex="-1"></a>            <span class="fu">lapply</span>(<span class="fu">split</span>(val[[<span class="dv">1</span>]], <span class="fu">gl</span>(nsim, n, <span class="dv">2</span> <span class="sc">*</span> nsim <span class="sc">*</span> n)), matrix,</span>
<span id="cb25-34"><a href="#cb25-34" tabindex="-1"></a>                          <span class="at">ncol =</span> <span class="dv">2</span>, <span class="at">dimnames =</span> <span class="fu">list</span>(<span class="cn">NULL</span>, <span class="fu">colnames</span>(r)))</span>
<span id="cb25-35"><a href="#cb25-35" tabindex="-1"></a>        } <span class="cf">else</span> <span class="cf">if</span> (family<span class="sc">$</span>family<span class="sc">==</span><span class="st">&quot;binomial&quot;</span> <span class="sc">&amp;&amp;</span> <span class="fu">is.factor</span>(val[[<span class="dv">1</span>]])) {</span>
<span id="cb25-36"><a href="#cb25-36" tabindex="-1"></a>            <span class="fu">split</span>(val[[<span class="dv">1</span>]], <span class="fu">gl</span>(nsim,n))</span>
<span id="cb25-37"><a href="#cb25-37" tabindex="-1"></a>        } <span class="cf">else</span> <span class="fu">split</span>(val, <span class="fu">gl</span>(nsim,n))</span>
<span id="cb25-38"><a href="#cb25-38" tabindex="-1"></a>    } <span class="cf">else</span></span>
<span id="cb25-39"><a href="#cb25-39" tabindex="-1"></a>        <span class="fu">stop</span>(<span class="st">&quot;simulate method for NLMMs not yet implemented&quot;</span>)</span></code></pre></div>
</div>
</div>
<div id="home-stretch" class="section level2">
<h2>Home Stretch</h2>
<p>A bit more housekeeping and we are ready to return the simulated
values as a <code>data.frame</code> with columns labelled by simulation
number and rows “labelled” in my case by consecutive integers as
strings.</p>
<p>The <code>!is.list()</code> test below is <code>TRUE</code>. Calling
<code>fitted()</code> seems a bit heavyweight, considering the result is
only used for names and <code>is.na</code> tests.</p>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a>    <span class="do">## from src/library/stats/R/lm.R</span></span>
<span id="cb26-2"><a href="#cb26-2" tabindex="-1"></a>    <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.list</span>(val)) {</span>
<span id="cb26-3"><a href="#cb26-3" tabindex="-1"></a>        <span class="fu">dim</span>(val) <span class="ot">&lt;-</span> <span class="fu">c</span>(n, nsim)</span>
<span id="cb26-4"><a href="#cb26-4" tabindex="-1"></a>        val <span class="ot">&lt;-</span> <span class="fu">as.data.frame</span>(val)</span>
<span id="cb26-5"><a href="#cb26-5" tabindex="-1"></a>    } <span class="cf">else</span> <span class="fu">class</span>(val) <span class="ot">&lt;-</span> <span class="st">&quot;data.frame&quot;</span></span>
<span id="cb26-6"><a href="#cb26-6" tabindex="-1"></a>    <span class="fu">names</span>(val) <span class="ot">&lt;-</span> <span class="fu">paste</span>(<span class="st">&quot;sim&quot;</span>, <span class="fu">seq_len</span>(nsim), <span class="at">sep=</span><span class="st">&quot;_&quot;</span>)</span>
<span id="cb26-7"><a href="#cb26-7" tabindex="-1"></a>    <span class="do">## have not yet filled in NAs, so need to use names of fitted</span></span>
<span id="cb26-8"><a href="#cb26-8" tabindex="-1"></a>    <span class="do">## object NOT including values with NAs</span></span>
<span id="cb26-9"><a href="#cb26-9" tabindex="-1"></a>    f <span class="ot">&lt;-</span> <span class="fu">fitted</span>(object)</span>
<span id="cb26-10"><a href="#cb26-10" tabindex="-1"></a>    nm <span class="ot">&lt;-</span> <span class="fu">names</span>(f)[<span class="sc">!</span><span class="fu">is.na</span>(f)]</span>
<span id="cb26-11"><a href="#cb26-11" tabindex="-1"></a>    <span class="do">## unnamed input, *or* simulation from new data ...</span></span>
<span id="cb26-12"><a href="#cb26-12" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">length</span>(nm) <span class="sc">==</span> <span class="dv">0</span>) {</span>
<span id="cb26-13"><a href="#cb26-13" tabindex="-1"></a>        nm <span class="ot">&lt;-</span> <span class="fu">as.character</span>(<span class="fu">seq</span>(n))</span>
<span id="cb26-14"><a href="#cb26-14" tabindex="-1"></a>    } <span class="cf">else</span> <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(newdata)) {</span>
<span id="cb26-15"><a href="#cb26-15" tabindex="-1"></a>        nm <span class="ot">&lt;-</span> <span class="fu">rownames</span>(newdata)</span>
<span id="cb26-16"><a href="#cb26-16" tabindex="-1"></a>    }</span>
<span id="cb26-17"><a href="#cb26-17" tabindex="-1"></a>    <span class="fu">row.names</span>(val) <span class="ot">&lt;-</span> nm</span>
<span id="cb26-18"><a href="#cb26-18" tabindex="-1"></a></span>
<span id="cb26-19"><a href="#cb26-19" tabindex="-1"></a>    fit.na.action <span class="ot">&lt;-</span> <span class="fu">attr</span>(<span class="fu">model.frame</span>(object), <span class="st">&quot;na.action&quot;</span>)</span>
<span id="cb26-20"><a href="#cb26-20" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">missing</span>(na.action) <span class="sc">&amp;&amp;</span>  <span class="sc">!</span><span class="fu">is.null</span>(fit.na.action)) {</span>
<span id="cb26-21"><a href="#cb26-21" tabindex="-1"></a>        <span class="do">## retrieve name of na.action type (&quot;omit&quot;, &quot;exclude&quot;, &quot;pass&quot;)</span></span>
<span id="cb26-22"><a href="#cb26-22" tabindex="-1"></a>        class.na.action <span class="ot">&lt;-</span> <span class="fu">class</span>(<span class="fu">attr</span>(<span class="fu">na.action</span>(<span class="cn">NA</span>), <span class="st">&quot;na.action&quot;</span>))</span>
<span id="cb26-23"><a href="#cb26-23" tabindex="-1"></a>        <span class="cf">if</span> (<span class="sc">!</span><span class="fu">identical</span>(class.na.action, <span class="fu">class</span>(fit.na.action))) {</span>
<span id="cb26-24"><a href="#cb26-24" tabindex="-1"></a>            <span class="do">## hack to override action where explicitly specified</span></span>
<span id="cb26-25"><a href="#cb26-25" tabindex="-1"></a>            <span class="fu">class</span>(fit.na.action) <span class="ot">&lt;-</span> class.na.action</span>
<span id="cb26-26"><a href="#cb26-26" tabindex="-1"></a>        }</span>
<span id="cb26-27"><a href="#cb26-27" tabindex="-1"></a>    }</span>
<span id="cb26-28"><a href="#cb26-28" tabindex="-1"></a></span>
<span id="cb26-29"><a href="#cb26-29" tabindex="-1"></a>    nafun <span class="ot">&lt;-</span> <span class="cf">function</span>(x) { x[] <span class="ot">&lt;-</span> <span class="fu">apply</span>(x,</span>
<span id="cb26-30"><a href="#cb26-30" tabindex="-1"></a>                                        <span class="dv">2</span><span class="dt">L</span>,</span>
<span id="cb26-31"><a href="#cb26-31" tabindex="-1"></a>                                        napredict,</span>
<span id="cb26-32"><a href="#cb26-32" tabindex="-1"></a>                                        <span class="at">omit =</span> fit.na.action); x }</span>
<span id="cb26-33"><a href="#cb26-33" tabindex="-1"></a>    val <span class="ot">&lt;-</span> <span class="cf">if</span> (<span class="fu">is.matrix</span>(val[[<span class="dv">1</span>]])) {</span>
<span id="cb26-34"><a href="#cb26-34" tabindex="-1"></a>        <span class="do">## have to handle binomial response matrices differently --</span></span>
<span id="cb26-35"><a href="#cb26-35" tabindex="-1"></a>        <span class="do">## fill in NAs as appropriate in *both* columns</span></span>
<span id="cb26-36"><a href="#cb26-36" tabindex="-1"></a>        <span class="fu">structure</span>(<span class="fu">lapply</span>(val, nafun),</span>
<span id="cb26-37"><a href="#cb26-37" tabindex="-1"></a>                  <span class="do">## have to put this back into a (weird) data frame again,</span></span>
<span id="cb26-38"><a href="#cb26-38" tabindex="-1"></a>                  <span class="do">## carefully (should do the napredict stuff</span></span>
<span id="cb26-39"><a href="#cb26-39" tabindex="-1"></a>                  <span class="do">## earlier, so we don&#39;t have to redo this transformation!)</span></span>
<span id="cb26-40"><a href="#cb26-40" tabindex="-1"></a>                  <span class="at">class =</span> <span class="st">&quot;data.frame&quot;</span>)</span>
<span id="cb26-41"><a href="#cb26-41" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb26-42"><a href="#cb26-42" tabindex="-1"></a>        <span class="fu">as.data.frame</span>(<span class="fu">lapply</span>(val, napredict, <span class="at">omit=</span>fit.na.action))</span>
<span id="cb26-43"><a href="#cb26-43" tabindex="-1"></a>    }</span>
<span id="cb26-44"><a href="#cb26-44" tabindex="-1"></a></span>
<span id="cb26-45"><a href="#cb26-45" tabindex="-1"></a>    <span class="do">## reconstruct names: first get rid of NAs, then refill them</span></span>
<span id="cb26-46"><a href="#cb26-46" tabindex="-1"></a>    <span class="do">## as appropriate based on fit.na.action (which may be different</span></span>
<span id="cb26-47"><a href="#cb26-47" tabindex="-1"></a>    <span class="do">## from the original model&#39;s na.action spec)</span></span>
<span id="cb26-48"><a href="#cb26-48" tabindex="-1"></a>    nm2 <span class="ot">&lt;-</span></span>
<span id="cb26-49"><a href="#cb26-49" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">is.null</span>(newdata))</span>
<span id="cb26-50"><a href="#cb26-50" tabindex="-1"></a>            <span class="fu">names</span>(<span class="fu">napredict</span>(<span class="fu">na.omit</span>(f), <span class="at">omit=</span>fit.na.action))</span>
<span id="cb26-51"><a href="#cb26-51" tabindex="-1"></a>        <span class="cf">else</span></span>
<span id="cb26-52"><a href="#cb26-52" tabindex="-1"></a>            <span class="fu">rownames</span>(<span class="fu">napredict</span>(newdata, <span class="at">omit=</span>fit.na.action))</span>
<span id="cb26-53"><a href="#cb26-53" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">length</span>(nm2) <span class="sc">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb26-54"><a href="#cb26-54" tabindex="-1"></a>        <span class="fu">row.names</span>(val) <span class="ot">&lt;-</span> nm2</span>
<span id="cb26-55"><a href="#cb26-55" tabindex="-1"></a></span>
<span id="cb26-56"><a href="#cb26-56" tabindex="-1"></a>    <span class="fu">structure</span>(val,</span>
<span id="cb26-57"><a href="#cb26-57" tabindex="-1"></a>              <span class="do">## as.data.frame(lapply(...)) blows away na.action attribute,</span></span>
<span id="cb26-58"><a href="#cb26-58" tabindex="-1"></a>              <span class="do">##  so we have to re-assign here</span></span>
<span id="cb26-59"><a href="#cb26-59" tabindex="-1"></a>              <span class="at">na.action =</span> fit.na.action,</span>
<span id="cb26-60"><a href="#cb26-60" tabindex="-1"></a>              <span class="at">seed =</span> RNGstate)</span>
<span id="cb26-61"><a href="#cb26-61" tabindex="-1"></a><span class="er">}</span><span class="do">## .simulateFun()</span></span></code></pre></div>
</div>
<div id="inner-simulation-functions" class="section level2">
<h2>Inner Simulation Functions</h2>
<p>If the model is a <em>generalized</em> linear mixed model these
functions generate random variables under an appropriate distribution.
They are called from <code>simulate()</code> via lookup in
<code>simfunList</code>. For the linear/normal case no auxiliary
function is required.</p>
<p>The code appears at the bottom of <code>predict.R</code>; none of the
symbols are exported.</p>
<p>The code comments immediately below explain why the basic
<code>R</code> family facilities are inadequate.</p>
<div class="sourceCode" id="cb27"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb27-1"><a href="#cb27-1" tabindex="-1"></a><span class="do">########################</span></span>
<span id="cb27-2"><a href="#cb27-2" tabindex="-1"></a><span class="do">## modified from stats/family.R</span></span>
<span id="cb27-3"><a href="#cb27-3" tabindex="-1"></a><span class="do">## </span><span class="al">TODO</span><span class="do">: the $simulate methods included with R families by default</span></span>
<span id="cb27-4"><a href="#cb27-4" tabindex="-1"></a><span class="do">## are not sufficiently flexible to be re-used by lme4.</span></span>
<span id="cb27-5"><a href="#cb27-5" tabindex="-1"></a><span class="do">## these are modified by:</span></span>
<span id="cb27-6"><a href="#cb27-6" tabindex="-1"></a><span class="do">## (1) adding a &#39;ftd&#39; argument for the fitted values</span></span>
<span id="cb27-7"><a href="#cb27-7" tabindex="-1"></a><span class="do">##     that defaults to fitted(object), to allow more flexibility</span></span>
<span id="cb27-8"><a href="#cb27-8" tabindex="-1"></a><span class="do">##     e.g. in conditioning on or marginalizing over random effects</span></span>
<span id="cb27-9"><a href="#cb27-9" tabindex="-1"></a><span class="do">##     (fitted(object) can be produced from predict.merMod() with</span></span>
<span id="cb27-10"><a href="#cb27-10" tabindex="-1"></a><span class="do">##     alternative parameters rather than being extracted directly</span></span>
<span id="cb27-11"><a href="#cb27-11" tabindex="-1"></a><span class="do">##     from the fitted objects -- this allows simulation with new</span></span>
<span id="cb27-12"><a href="#cb27-12" tabindex="-1"></a><span class="do">##     parameters or new predictor variables</span></span>
<span id="cb27-13"><a href="#cb27-13" tabindex="-1"></a><span class="do">## (2) modifying wts from object$prior.weights to weights(object)</span></span>
<span id="cb27-14"><a href="#cb27-14" tabindex="-1"></a><span class="do">## (3) adding wts as an argument</span></span>
<span id="cb27-15"><a href="#cb27-15" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb27-16"><a href="#cb27-16" tabindex="-1"></a><span class="do">## these can be incorporated by overwriting the simulate()</span></span>
<span id="cb27-17"><a href="#cb27-17" tabindex="-1"></a><span class="do">## components, or calling them</span></span>
<span id="cb27-18"><a href="#cb27-18" tabindex="-1"></a><span class="do">##</span></span>
<span id="cb27-19"><a href="#cb27-19" tabindex="-1"></a>gaussian_simfun <span class="ot">&lt;-</span> <span class="cf">function</span>(object, nsim, <span class="at">ftd=</span><span class="fu">fitted</span>(object),</span>
<span id="cb27-20"><a href="#cb27-20" tabindex="-1"></a>                            <span class="at">wts=</span><span class="fu">weights</span>(object)) {</span>
<span id="cb27-21"><a href="#cb27-21" tabindex="-1"></a></span>
<span id="cb27-22"><a href="#cb27-22" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">any</span>(wts <span class="sc">!=</span> <span class="dv">1</span>)) <span class="fu">warning</span>(<span class="st">&quot;ignoring prior weights&quot;</span>)</span>
<span id="cb27-23"><a href="#cb27-23" tabindex="-1"></a>    <span class="fu">rnorm</span>(nsim<span class="sc">*</span><span class="fu">length</span>(ftd), ftd, <span class="at">sd=</span><span class="fu">sigma</span>(object))</span>
<span id="cb27-24"><a href="#cb27-24" tabindex="-1"></a>}</span>
<span id="cb27-25"><a href="#cb27-25" tabindex="-1"></a></span>
<span id="cb27-26"><a href="#cb27-26" tabindex="-1"></a>binomial_simfun <span class="ot">&lt;-</span> <span class="cf">function</span>(object, nsim, <span class="at">ftd=</span><span class="fu">fitted</span>(object),</span>
<span id="cb27-27"><a href="#cb27-27" tabindex="-1"></a>                            <span class="at">wts=</span><span class="fu">weights</span>(object)) {</span>
<span id="cb27-28"><a href="#cb27-28" tabindex="-1"></a>    n <span class="ot">&lt;-</span> <span class="fu">length</span>(ftd)</span>
<span id="cb27-29"><a href="#cb27-29" tabindex="-1"></a>    ntot <span class="ot">&lt;-</span> n<span class="sc">*</span>nsim</span>
<span id="cb27-30"><a href="#cb27-30" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">any</span>(wts <span class="sc">%%</span> <span class="dv">1</span> <span class="sc">!=</span> <span class="dv">0</span>))</span>
<span id="cb27-31"><a href="#cb27-31" tabindex="-1"></a>        <span class="fu">stop</span>(<span class="st">&quot;cannot simulate from non-integer prior.weights&quot;</span>)</span>
<span id="cb27-32"><a href="#cb27-32" tabindex="-1"></a>    <span class="do">## Try to figure out if the original data were</span></span>
<span id="cb27-33"><a href="#cb27-33" tabindex="-1"></a>    <span class="do">## proportions, a factor or a two-column matrix</span></span>
<span id="cb27-34"><a href="#cb27-34" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">is.null</span>(m <span class="ot">&lt;-</span> <span class="fu">model.frame</span>(object))) {</span>
<span id="cb27-35"><a href="#cb27-35" tabindex="-1"></a>        y <span class="ot">&lt;-</span> <span class="fu">model.response</span>(m)</span>
<span id="cb27-36"><a href="#cb27-36" tabindex="-1"></a>        <span class="cf">if</span>(<span class="fu">is.factor</span>(y)) {</span>
<span id="cb27-37"><a href="#cb27-37" tabindex="-1"></a>            <span class="do">## ignore weights</span></span>
<span id="cb27-38"><a href="#cb27-38" tabindex="-1"></a>            yy <span class="ot">&lt;-</span> <span class="fu">factor</span>(<span class="fu">levels</span>(y)[<span class="dv">1</span> <span class="sc">+</span> <span class="fu">rbinom</span>(ntot, <span class="at">size =</span> <span class="dv">1</span>, <span class="at">prob =</span> ftd)],</span>
<span id="cb27-39"><a href="#cb27-39" tabindex="-1"></a>                         <span class="at">levels =</span> <span class="fu">levels</span>(y))</span>
<span id="cb27-40"><a href="#cb27-40" tabindex="-1"></a>            <span class="fu">split</span>(yy, <span class="fu">rep</span>(<span class="fu">seq_len</span>(nsim), <span class="at">each =</span> n))</span>
<span id="cb27-41"><a href="#cb27-41" tabindex="-1"></a>        } <span class="cf">else</span> <span class="cf">if</span>(<span class="fu">is.matrix</span>(y) <span class="sc">&amp;&amp;</span> <span class="fu">ncol</span>(y) <span class="sc">==</span> <span class="dv">2</span>) {</span>
<span id="cb27-42"><a href="#cb27-42" tabindex="-1"></a>            yy <span class="ot">&lt;-</span> <span class="fu">vector</span>(<span class="st">&quot;list&quot;</span>, nsim)</span>
<span id="cb27-43"><a href="#cb27-43" tabindex="-1"></a>            <span class="cf">for</span> (i <span class="cf">in</span> <span class="fu">seq_len</span>(nsim)) {</span>
<span id="cb27-44"><a href="#cb27-44" tabindex="-1"></a>                Y <span class="ot">&lt;-</span> <span class="fu">rbinom</span>(n, <span class="at">size =</span> wts, <span class="at">prob =</span> ftd)</span>
<span id="cb27-45"><a href="#cb27-45" tabindex="-1"></a>                YY <span class="ot">&lt;-</span> <span class="fu">cbind</span>(Y, wts <span class="sc">-</span> Y)</span>
<span id="cb27-46"><a href="#cb27-46" tabindex="-1"></a>                <span class="fu">colnames</span>(YY) <span class="ot">&lt;-</span> <span class="fu">colnames</span>(y)</span>
<span id="cb27-47"><a href="#cb27-47" tabindex="-1"></a>                yy[[i]] <span class="ot">&lt;-</span> YY</span>
<span id="cb27-48"><a href="#cb27-48" tabindex="-1"></a>            }</span>
<span id="cb27-49"><a href="#cb27-49" tabindex="-1"></a>            yy</span>
<span id="cb27-50"><a href="#cb27-50" tabindex="-1"></a>        } <span class="cf">else</span></span>
<span id="cb27-51"><a href="#cb27-51" tabindex="-1"></a>            <span class="fu">rbinom</span>(ntot, <span class="at">size =</span> wts, <span class="at">prob =</span> ftd)<span class="sc">/</span>wts</span>
<span id="cb27-52"><a href="#cb27-52" tabindex="-1"></a>    } <span class="cf">else</span> <span class="fu">rbinom</span>(ntot, <span class="at">size =</span> wts, <span class="at">prob =</span> ftd)<span class="sc">/</span>wts</span>
<span id="cb27-53"><a href="#cb27-53" tabindex="-1"></a>}</span>
<span id="cb27-54"><a href="#cb27-54" tabindex="-1"></a></span>
<span id="cb27-55"><a href="#cb27-55" tabindex="-1"></a>poisson_simfun <span class="ot">&lt;-</span> <span class="cf">function</span>(object, nsim, <span class="at">ftd=</span><span class="fu">fitted</span>(object),</span>
<span id="cb27-56"><a href="#cb27-56" tabindex="-1"></a>                           <span class="at">wts=</span><span class="fu">weights</span>(object)) {</span>
<span id="cb27-57"><a href="#cb27-57" tabindex="-1"></a>        <span class="do">## A Poisson GLM has dispersion fixed at 1, so prior weights</span></span>
<span id="cb27-58"><a href="#cb27-58" tabindex="-1"></a>        <span class="do">## do not have a simple unambiguous interpretation:</span></span>
<span id="cb27-59"><a href="#cb27-59" tabindex="-1"></a>        <span class="do">## they might be frequency weights or indicate averages.</span></span>
<span id="cb27-60"><a href="#cb27-60" tabindex="-1"></a>        wts <span class="ot">&lt;-</span> <span class="fu">weights</span>(object)</span>
<span id="cb27-61"><a href="#cb27-61" tabindex="-1"></a>        <span class="cf">if</span> (<span class="fu">any</span>(wts <span class="sc">!=</span> <span class="dv">1</span>)) <span class="fu">warning</span>(<span class="st">&quot;ignoring prior weights&quot;</span>)</span>
<span id="cb27-62"><a href="#cb27-62" tabindex="-1"></a>        <span class="fu">rpois</span>(nsim<span class="sc">*</span><span class="fu">length</span>(ftd), ftd)</span>
<span id="cb27-63"><a href="#cb27-63" tabindex="-1"></a>    }</span>
<span id="cb27-64"><a href="#cb27-64" tabindex="-1"></a></span>
<span id="cb27-65"><a href="#cb27-65" tabindex="-1"></a></span>
<span id="cb27-66"><a href="#cb27-66" tabindex="-1"></a><span class="do">##&#39; </span><span class="al">FIXME</span><span class="do">: need a gamma.shape.merMod method in order for this to work.</span></span>
<span id="cb27-67"><a href="#cb27-67" tabindex="-1"></a><span class="do">##&#39;        (see initial shot at gamma.shape.merMod below)</span></span>
<span id="cb27-68"><a href="#cb27-68" tabindex="-1"></a>Gamma_simfun <span class="ot">&lt;-</span> <span class="cf">function</span>(object, nsim, <span class="at">ftd=</span><span class="fu">fitted</span>(object),</span>
<span id="cb27-69"><a href="#cb27-69" tabindex="-1"></a>                         <span class="at">wts=</span><span class="fu">weights</span>(object)) {</span>
<span id="cb27-70"><a href="#cb27-70" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">any</span>(wts <span class="sc">!=</span> <span class="dv">1</span>)) <span class="fu">message</span>(<span class="st">&quot;using weights to scale shape parameter&quot;</span>)</span>
<span id="cb27-71"><a href="#cb27-71" tabindex="-1"></a>    <span class="do">## used to use gamma.shape(), but sigma() is more general</span></span>
<span id="cb27-72"><a href="#cb27-72" tabindex="-1"></a>    <span class="do">## (wouldn&#39;t work *outside* of the merMod context though)</span></span>
<span id="cb27-73"><a href="#cb27-73" tabindex="-1"></a>    shape <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">/</span><span class="fu">sigma</span>(object)<span class="sc">^</span><span class="dv">2</span><span class="sc">*</span>wts</span>
<span id="cb27-74"><a href="#cb27-74" tabindex="-1"></a>    <span class="fu">rgamma</span>(nsim<span class="sc">*</span><span class="fu">length</span>(ftd), <span class="at">shape =</span> shape, <span class="at">rate =</span> shape<span class="sc">/</span>ftd)</span>
<span id="cb27-75"><a href="#cb27-75" tabindex="-1"></a>}</span>
<span id="cb27-76"><a href="#cb27-76" tabindex="-1"></a></span>
<span id="cb27-77"><a href="#cb27-77" tabindex="-1"></a>gamma.shape.merMod <span class="ot">&lt;-</span> <span class="cf">function</span>(object, ...) {</span>
<span id="cb27-78"><a href="#cb27-78" tabindex="-1"></a>    <span class="cf">if</span>(<span class="fu">family</span>(object)<span class="sc">$</span>family <span class="sc">!=</span> <span class="st">&quot;Gamma&quot;</span>)</span>
<span id="cb27-79"><a href="#cb27-79" tabindex="-1"></a>        <span class="fu">stop</span>(<span class="st">&quot;Can not fit gamma shape parameter because Gamma family not used&quot;</span>)</span>
<span id="cb27-80"><a href="#cb27-80" tabindex="-1"></a></span>
<span id="cb27-81"><a href="#cb27-81" tabindex="-1"></a>    y <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;y&quot;</span>)</span>
<span id="cb27-82"><a href="#cb27-82" tabindex="-1"></a>    mu <span class="ot">&lt;-</span> <span class="fu">getME</span>(object, <span class="st">&quot;mu&quot;</span>)</span>
<span id="cb27-83"><a href="#cb27-83" tabindex="-1"></a>    w <span class="ot">&lt;-</span> <span class="fu">weights</span>(object)</span>
<span id="cb27-84"><a href="#cb27-84" tabindex="-1"></a>                                        <span class="co"># Sec 8.3.2 (MN)</span></span>
<span id="cb27-85"><a href="#cb27-85" tabindex="-1"></a>    L <span class="ot">&lt;-</span> w<span class="sc">*</span>(<span class="fu">log</span>(y<span class="sc">/</span>mu)<span class="sc">-</span>((y<span class="sc">-</span>mu)<span class="sc">/</span>mu))</span>
<span id="cb27-86"><a href="#cb27-86" tabindex="-1"></a>    dev <span class="ot">&lt;-</span> <span class="sc">-</span><span class="dv">2</span><span class="sc">*</span><span class="fu">sum</span>(L)</span>
<span id="cb27-87"><a href="#cb27-87" tabindex="-1"></a>                                        <span class="co"># Eqs. between 8.2 &amp; 8.3 (MN)</span></span>
<span id="cb27-88"><a href="#cb27-88" tabindex="-1"></a>    Dbar <span class="ot">&lt;-</span> dev<span class="sc">/</span><span class="fu">length</span>(y)</span>
<span id="cb27-89"><a href="#cb27-89" tabindex="-1"></a>    <span class="fu">structure</span>(<span class="fu">list</span>(<span class="at">alpha =</span> (<span class="dv">6</span><span class="sc">+</span><span class="dv">2</span><span class="sc">*</span>Dbar)<span class="sc">/</span>(Dbar<span class="sc">*</span>(<span class="dv">6</span><span class="sc">+</span>Dbar)),</span>
<span id="cb27-90"><a href="#cb27-90" tabindex="-1"></a>                   <span class="at">SE =</span> <span class="cn">NA</span>), <span class="co"># </span><span class="al">FIXME</span><span class="co">: obtain standard error</span></span>
<span id="cb27-91"><a href="#cb27-91" tabindex="-1"></a>              <span class="at">class =</span> <span class="st">&quot;gamma.shape&quot;</span>)</span>
<span id="cb27-92"><a href="#cb27-92" tabindex="-1"></a>}</span>
<span id="cb27-93"><a href="#cb27-93" tabindex="-1"></a></span>
<span id="cb27-94"><a href="#cb27-94" tabindex="-1"></a>inverse.gaussian_simfun <span class="ot">&lt;-</span> <span class="cf">function</span>(object, nsim, <span class="at">ftd=</span><span class="fu">fitted</span>(object),</span>
<span id="cb27-95"><a href="#cb27-95" tabindex="-1"></a>                                    <span class="at">wts =</span> <span class="fu">weights</span>(object)) {</span>
<span id="cb27-96"><a href="#cb27-96" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">any</span>(wts <span class="sc">!=</span> <span class="dv">1</span>)) <span class="fu">message</span>(<span class="st">&quot;using weights as inverse variances&quot;</span>)</span>
<span id="cb27-97"><a href="#cb27-97" tabindex="-1"></a>    <span class="cf">if</span> (<span class="sc">!</span><span class="fu">requireNamespace</span>(<span class="st">&quot;statmod&quot;</span>)) {</span>
<span id="cb27-98"><a href="#cb27-98" tabindex="-1"></a>      <span class="fu">stop</span>(<span class="st">&quot;The &quot;</span>,<span class="fu">sQuote</span>(<span class="st">&quot;statmod&quot;</span>),<span class="st">&quot; package must be installed &quot;</span>,</span>
<span id="cb27-99"><a href="#cb27-99" tabindex="-1"></a>           <span class="st">&quot; in order to simulate inverse-Gaussian distributions&quot;</span>)</span>
<span id="cb27-100"><a href="#cb27-100" tabindex="-1"></a>    }</span>
<span id="cb27-101"><a href="#cb27-101" tabindex="-1"></a>    statmod<span class="sc">::</span><span class="fu">rinvgauss</span>(nsim <span class="sc">*</span> <span class="fu">length</span>(ftd), <span class="at">mean =</span> ftd,</span>
<span id="cb27-102"><a href="#cb27-102" tabindex="-1"></a>                       <span class="at">shape=</span> wts<span class="sc">/</span><span class="fu">sigma</span>(object))</span>
<span id="cb27-103"><a href="#cb27-103" tabindex="-1"></a>}</span>
<span id="cb27-104"><a href="#cb27-104" tabindex="-1"></a></span>
<span id="cb27-105"><a href="#cb27-105" tabindex="-1"></a><span class="do">## in the original MASS version, .Theta is assigned into the environment</span></span>
<span id="cb27-106"><a href="#cb27-106" tabindex="-1"></a><span class="do">## (triggers a </span><span class="al">NOTE</span><span class="do"> in R CMD check)</span></span>
<span id="cb27-107"><a href="#cb27-107" tabindex="-1"></a><span class="do">## modified from @aosmith16 GH contribution</span></span>
<span id="cb27-108"><a href="#cb27-108" tabindex="-1"></a></span>
<span id="cb27-109"><a href="#cb27-109" tabindex="-1"></a>negative.binomial_simfun <span class="ot">&lt;-</span> <span class="cf">function</span> (object, nsim,</span>
<span id="cb27-110"><a href="#cb27-110" tabindex="-1"></a>                                      <span class="at">ftd =</span> <span class="fu">fitted</span>(object),</span>
<span id="cb27-111"><a href="#cb27-111" tabindex="-1"></a>                                      <span class="at">wts=</span><span class="fu">weights</span>(object))</span>
<span id="cb27-112"><a href="#cb27-112" tabindex="-1"></a>{</span>
<span id="cb27-113"><a href="#cb27-113" tabindex="-1"></a></span>
<span id="cb27-114"><a href="#cb27-114" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">any</span>(wts <span class="sc">!=</span> <span class="dv">1</span>))</span>
<span id="cb27-115"><a href="#cb27-115" tabindex="-1"></a>        <span class="fu">warning</span>(<span class="st">&quot;ignoring prior weights&quot;</span>)</span>
<span id="cb27-116"><a href="#cb27-116" tabindex="-1"></a>    theta <span class="ot">&lt;-</span> <span class="fu">getNBdisp</span>(object)</span>
<span id="cb27-117"><a href="#cb27-117" tabindex="-1"></a>    <span class="fu">rnbinom</span>(nsim <span class="sc">*</span> <span class="fu">length</span>(ftd), <span class="at">mu =</span> ftd, <span class="at">size =</span> theta)</span>
<span id="cb27-118"><a href="#cb27-118" tabindex="-1"></a>}</span>
<span id="cb27-119"><a href="#cb27-119" tabindex="-1"></a></span>
<span id="cb27-120"><a href="#cb27-120" tabindex="-1"></a>simfunList <span class="ot">&lt;-</span> <span class="fu">list</span>(<span class="at">gaussian =</span> gaussian_simfun,</span>
<span id="cb27-121"><a href="#cb27-121" tabindex="-1"></a>                   <span class="at">binomial =</span> binomial_simfun,</span>
<span id="cb27-122"><a href="#cb27-122" tabindex="-1"></a>                   <span class="at">poisson  =</span> poisson_simfun,</span>
<span id="cb27-123"><a href="#cb27-123" tabindex="-1"></a>                   <span class="at">Gamma    =</span> Gamma_simfun,</span>
<span id="cb27-124"><a href="#cb27-124" tabindex="-1"></a>                   <span class="at">negative.binomial =</span> negative.binomial_simfun,</span>
<span id="cb27-125"><a href="#cb27-125" tabindex="-1"></a>                   <span class="at">inverse.gaussian =</span> inverse.gaussian_simfun)</span></code></pre></div>
</div>
</div>
<div id="entire-predict.r-in-lme4" class="section level1">
<h1>Entire <code>predict.R</code> in <code>lme4</code></h1>
<p>As of git commit
<code>5863937d0f5b326fb108067b694b9b337aa03c71</code> from 31 Mar 2024.
Last actual change as of 6/15/24 was</p>
<pre><code>   Revision: 1e678b60e1bcfb0518a40678ed8eb763b0537538
   Author: Ben Bolker &lt;bbolker@gmail.com&gt;
   Date: 11/7/2023 7:29:41 AM
   Message:
   NA + simulate + re.form = NULL (GH #737) [run ci]</code></pre>
<p>Listing suppressed to save space; it’s in the
<code>simulation.Rmd</code> file, the source for this document.</p>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
