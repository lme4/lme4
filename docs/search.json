[{"path":"/README_old.html","id":null,"dir":"","previous_headings":"","what":"Old README","title":"Old README","text":"Information installing ancient versions lme4, ancient versions R.","code":""},{"path":"/README_old.html","id":"on-old-r-pre-300","dir":"","previous_headings":"","what":"On old R (pre-3.0.0)","title":"Old README","text":"possible install (easily check) lme4 least recently 1.1-7. make sure exactly package versions: Rcpp 0.10.5, RcppEigen 3.2.0.2 installation, use ---inst; necessary order prevent R getting hung knitr-based vignettes running R CMD check difficult, possible hand-copy contents inst directory installed package directory …","code":""},{"path":"/README_old.html","id":"of-lme40","dir":"","previous_headings":"","what":"Of lme4.0","title":"Old README","text":"lme4.0 maintained version lme4 back compatible CRAN versions lme4 0.99xy, mainly purpose reproducible research data analysis done 0.99xy versions lme4. reports problems lme4.0 R version 3.1; someone specific reproducible example ’d like donate, please contact maintainers. Notably, lme4.0 features getME(<mod>, \"..\") compatible (much sensibly possible) current lme4’s version getME(). can use convert_old_lme4() function take fitted object created lme4 <1.0 convert use lme4.0. currently resides R-forge, able install (binary versions date unavailable system, please contact maintainers).","code":"install.packages(\"lme4.0\",                  repos=c(\"http://lme4.r-forge.r-project.org/repos\",                          getOption(\"repos\")[[\"CRAN\"]]))"},{"path":"/TODO.html","id":"old-to-do-list-pre-2009","dir":"","previous_headings":"","what":"Old “to do” list (pre-2009)","title":"NA","text":"items uncertain status Change terms object terms fixed-effects drop1 method doesn’t try drop grouping factors random effects. Modify effect verbose setting Nelder-Mead optimizer. particular, count evaluations define “iteration” change best value encountered far. paper Sophia Rabe-Hesketh et al describes spherical form Gauss-Hermite quadrature formula. Look use . Gauss-Hermite quadrature formed sum, necessary divide contributions deviance according levels random effects. means practical use AGQ response vector can split sections conditionally independent. far can see mean single grouping factor . Allow matrix responses lmer multiple fits can performed without needing regenerate model matrices. Determine coef function multiple, possibly non-nested, grouping factors. add nicer (realistic?) pedigree examples tests document print() including example print(, corr = FALSE) one many fixed effects (*) print(, symbolic.cor = TRUE)","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Douglas Bates. Author. Martin Maechler. Author. Ben Bolker. Author, maintainer. Steven Walker. Author. Rune Haubo Bojesen Christensen. Contributor. Henrik Singmann. Contributor. Bin Dai. Contributor. Fabian Scheipl. Contributor. Gabor Grothendieck. Contributor. Peter Green. Contributor. John Fox. Contributor. Alexander Bauer. Contributor. Pavel N. Krivitsky. Contributor, copyright holder.            shared copyright simulate.formula Emi Tanaka. Contributor. Mikael Jagan. Contributor. Ross D. Boylan. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Douglas Bates, Martin Maechler, Ben Bolker, Steve Walker (2015). Fitting Linear Mixed-Effects Models Using lme4. Journal Statistical Software, 67(1), 1-48. doi:10.18637/jss.v067.i01.","code":"@Article{,   title = {Fitting Linear Mixed-Effects Models Using {lme4}},   author = {Douglas Bates and Martin M{\\\"a}chler and Ben Bolker and Steve Walker},   journal = {Journal of Statistical Software},   year = {2015},   volume = {67},   number = {1},   pages = {1--48},   doi = {10.18637/jss.v067.i01}, }"},{"path":[]},{"path":"/index.html","id":"recentrelease-notes","dir":"","previous_headings":"","what":"Recent/release notes","title":"Linear Mixed-Effects Models using Eigen and S4","text":"See NEWS file","code":""},{"path":"/index.html","id":"where-to-get-help","dir":"","previous_headings":"","what":"Where to get help","title":"Linear Mixed-Effects Models using Eigen and S4","text":"r-sig-mixed-models@r-project.org questions lme4 usage general mixed model questions; please read info page, subscribe, posting … (note mailing list support images large/non-text attachments) https://github.com/lme4/lme4/issues bug, infelicity, wishlist reporting lme4 tag StackOverflow programming-related lme4-nlme tag CrossValidated statistics-related questions maintainer e-mail urgent/private communications","code":""},{"path":"/index.html","id":"support","dir":"","previous_headings":"","what":"Support","title":"Linear Mixed-Effects Models using Eigen and S4","text":"choose support lme4 development financially, can contribute fund McMaster University (home institution one developers) . form say donating “Global Coding Fund”; fund available use developers, McMaster’s research spending rules. plan use funds, available, pay students maintenance development work. way earmark funds set bounty direct funding toward particular features, can e-mail maintainers suggest priorities donation.","code":""},{"path":"/index.html","id":"features","dir":"","previous_headings":"","what":"Features","title":"Linear Mixed-Effects Models using Eigen and S4","text":"Efficient large data sets, using algorithms Eigen linear algebra package via RcppEigen interface layer. Allows arbitrarily many nested crossed random effects. Fits generalized linear mixed models (GLMMs) nonlinear mixed models (NLMMs) via Laplace approximation adaptive Gauss-Hermite quadrature; GLMMs allow user-defined families link functions. Incorporates likelihood profiling parametric bootstrapping.","code":""},{"path":[]},{"path":"/index.html","id":"on-current-r--360","dir":"","previous_headings":"Installation","what":"On current R (>= 3.6.0)","title":"Linear Mixed-Effects Models using Eigen and S4","text":"CRAN (stable release 1.+) Development version Github: (requires devtools >= 1.6.1, installs “master” (development) branch.) approach builds package source, .e. make compilers must installed system – see R FAQ operating system; may also need install dependencies manually. Specify build_vignettes=FALSE trouble system missing LaTeX/texi2dvi tools. Development binaries r-universe:","code":"library(\"devtools\"); install_github(\"lme4/lme4\",dependencies=TRUE) install.packages('lme4', repos = c('https://lme4.r-universe.dev', getOption(\"repos\")[[\"CRAN\"]]))"},{"path":"/index.html","id":"development-notes","dir":"","previous_headings":"","what":"Development notes","title":"Linear Mixed-Effects Models using Eigen and S4","text":"lme4 developed mixture NEWS inst/NEWS.Rd (top-level NEWS.md file) documentation .Rd files (roxygen2, although functions internal roxygen-style documentation [used]) ‘classic’ tests tests/ directory Sweave (knitr)/Rnw-format vignette, especially vignettes/lmer.Rnw testthat tests, tests/testthat pkgdown web site (via pkgdown.extras, extensions allow PDF vignettes); trigger manual builds primary development repository issues testing GitHub actions (activated specifying “[run ci]” end commit message) pull requests welcome, please open discussion issue first","code":""},{"path":"/reference/Arabidopsis.html","id":null,"dir":"Reference","previous_headings":"","what":"Arabidopsis clipping/fertilization data — Arabidopsis","title":"Arabidopsis clipping/fertilization data — Arabidopsis","text":"Data genetic variation responses fertilization   simulated herbivory Arabidopsis","code":""},{"path":"/reference/Arabidopsis.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Arabidopsis clipping/fertilization data — Arabidopsis","text":"","code":"data(\"Arabidopsis\")"},{"path":"/reference/Arabidopsis.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Arabidopsis clipping/fertilization data — Arabidopsis","text":"data frame 625 observations following 8 variables. reg region: factor 3 levels NL       (Netherlands), SP (Spain), SW (Sweden) popu population: factor form n.R       representing population region R gen genotype: factor 24 (numeric-valued) levels rack nuisance factor 2 levels, one       two greenhouse racks nutrient fertilization treatment/nutrient level (1,       minimal nutrients 8, added nutrients) amd simulated herbivory \"clipping\" (apical meristem       damage): unclipped (baseline) clipped status nuisance factor germination method       (Normal, Petri.Plate, Transplant) total.fruits total fruit set per plant (integer)","code":""},{"path":"/reference/Arabidopsis.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Arabidopsis clipping/fertilization data — Arabidopsis","text":"Josh Banta","code":""},{"path":"/reference/Arabidopsis.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Arabidopsis clipping/fertilization data — Arabidopsis","text":"Joshua . Banta, Martin H. H Stevens, Massimo Pigliucci (2010)   comprehensive test 'limiting resources' framework applied   plant tolerance apical meristem damage.   Oikos 119(2), 359–369;   doi:10.1111/j.1600-0706.2009.17726.x","code":""},{"path":"/reference/Arabidopsis.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Arabidopsis clipping/fertilization data — Arabidopsis","text":"","code":"data(Arabidopsis) summary(Arabidopsis[,\"total.fruits\"]) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>    0.00    2.00   11.00   29.96   42.00  238.00  table(gsub(\"[0-9].\",\"\",levels(Arabidopsis[,\"popu\"]))) #>  #> NL SP SW  #>  2  4  3  library(lattice) stripplot(log(total.fruits+1) ~ amd|nutrient, data = Arabidopsis,           groups = gen,           strip=strip.custom(strip.names=c(TRUE,TRUE)),           type=c('p','a'), ## points and panel-average value --           ## see ?panel.xyplot           scales=list(x=list(rot=90)),           main=\"Panel: nutrient, Color: genotype\")"},{"path":"/reference/Dyestuff.html","id":null,"dir":"Reference","previous_headings":"","what":"Yield of dyestuff by batch — Dyestuff","title":"Yield of dyestuff by batch — Dyestuff","text":"Dyestuff data frame provides yield   dyestuff (Naphthalene Black 12B) 5 different   preparations 6 different batchs   intermediate product (H-acid).  Dyestuff2 data   generated data structure   large residual variance relative batch variance.","code":""},{"path":"/reference/Dyestuff.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Yield of dyestuff by batch — Dyestuff","text":"Data frames, 30 observations following 2 variables. Batch factor indicating batch       intermediate product preparation created. Yield yield dyestuff preparation       (grams standard color).","code":""},{"path":"/reference/Dyestuff.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Yield of dyestuff by batch — Dyestuff","text":"O.L. Davies P.L. Goldsmith (eds), Statistical   Methods Research Production, 4th ed., Oliver   Boyd, (1972), section 6.4 G.E.P. Box G.C. Tiao, Bayesian Inference   Statistical Analysis, Addison-Wesley, (1973), section   5.1.2","code":""},{"path":"/reference/Dyestuff.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Yield of dyestuff by batch — Dyestuff","text":"Dyestuff data described Davies   Goldsmith (1972) coming “investigation   find much variation batch batch   quality intermediate product (H-acid)   contributes variation yield dyestuff   (Naphthalene Black 12B) made .  experiment   six samples intermediate, representing different   batches works manufacture, obtained, five   preparations dyestuff made laboratory   sample. equivalent yield   preparation grams standard colour determined   dye-trial.” Dyestuff2 data described Box Tiao   (1973) illustrating “ case   -batches mean square less   within-batches mean square.  data   constructed although examples sort   undoubtably occur practice, seem rarely   published.”","code":""},{"path":"/reference/Dyestuff.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Yield of dyestuff by batch — Dyestuff","text":"","code":"#> R_LIBS: #> and extra(:= not in R_LIBS) .libPaths(): #> Matrix -- built: R 4.5.0; x86_64-pc-linux-gnu; 2025-04-28 20:03:33 UTC; unix #>        -- dir  : /opt/R/4.5.0/lib/R/library/Matrix #> Rcpp -- built: R 4.5.0; x86_64-pc-linux-gnu; 2025-05-06 18:13:24 UTC; unix #>      -- dir  : /home/runner/work/_temp/Library/Rcpp #> RcppEigen -- built: R 4.5.0; x86_64-pc-linux-gnu; 2025-05-06 18:27:48 UTC; unix #>           -- dir  : /home/runner/work/_temp/Library/RcppEigen #> minqa -- built: R 4.5.0; x86_64-pc-linux-gnu; 2025-05-06 18:26:31 UTC; unix #>       -- dir  : /home/runner/work/_temp/Library/minqa #> lme4 -- built: R 4.5.0; x86_64-pc-linux-gnu; 2025-05-06 21:13:39 UTC; unix #>      -- dir  : /tmp/RtmpMuU2gT/temp_libpath81c4de17cc9/lme4 require(lattice) str(Dyestuff) #> 'data.frame':\t30 obs. of  2 variables: #>  $ Batch: Factor w/ 6 levels \"A\",\"B\",\"C\",\"D\",..: 1 1 1 1 1 2 2 2 2 2 ... #>  $ Yield: num  1545 1440 1440 1520 1580 ... dotplot(reorder(Batch, Yield) ~ Yield, Dyestuff,         ylab = \"Batch\", jitter.y = TRUE, aspect = 0.3,         type = c(\"p\", \"a\"))  dotplot(reorder(Batch, Yield) ~ Yield, Dyestuff2,         ylab = \"Batch\", jitter.y = TRUE, aspect = 0.3,         type = c(\"p\", \"a\"))  (fm1 <- lmer(Yield ~ 1|Batch, Dyestuff)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Yield ~ 1 | Batch #>    Data: Dyestuff #> REML criterion at convergence: 319.6543 #> Random effects: #>  Groups   Name        Std.Dev. #>  Batch    (Intercept) 42.00    #>  Residual             49.51    #> Number of obs: 30, groups:  Batch, 6 #> Fixed Effects: #> (Intercept)   #>        1528   (fm2 <- lmer(Yield ~ 1|Batch, Dyestuff2)) #> boundary (singular) fit: see help('isSingular') #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Yield ~ 1 | Batch #>    Data: Dyestuff2 #> REML criterion at convergence: 161.8283 #> Random effects: #>  Groups   Name        Std.Dev. #>  Batch    (Intercept) 0.000    #>  Residual             3.716    #> Number of obs: 30, groups:  Batch, 6 #> Fixed Effects: #> (Intercept)   #>       5.666   #> optimizer (nloptwrap) convergence code: 0 (OK) ; 0 optimizer warnings; 1 lme4 warnings"},{"path":"/reference/GHrule.html","id":null,"dir":"Reference","previous_headings":"","what":"Univariate Gauss-Hermite quadrature rule — GHrule","title":"Univariate Gauss-Hermite quadrature rule — GHrule","text":"Create univariate Gauss-Hermite quadrature rule.","code":""},{"path":"/reference/GHrule.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Univariate Gauss-Hermite quadrature rule — GHrule","text":"","code":"GHrule(ord, asMatrix = TRUE)"},{"path":"/reference/GHrule.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Univariate Gauss-Hermite quadrature rule — GHrule","text":"ord scalar integer 1 100 - order,     number nodes weights, rule.      function multiplied standard normal density     polynomial order \\(2k-1\\) rule order \\(k\\)     integrates product exactly. asMatrix logical scalar - result     returned matrix.  FALSE data frame     returned.  Defaults TRUE.","code":""},{"path":"/reference/GHrule.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Univariate Gauss-Hermite quadrature rule — GHrule","text":"matrix (data frame, asMatrix false) ord   rows three columns z node positions, w   weights ldnorm, logarithm normal density   evaluated nodes.","code":""},{"path":"/reference/GHrule.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Univariate Gauss-Hermite quadrature rule — GHrule","text":"version Gauss-Hermite quadrature provides node positions   weights scalar integral function multiplied   standard normal density. Originally based package SparseGrid's hidden GQN(),   fastGHQuad's gaussHermiteData(.).","code":""},{"path":"/reference/GHrule.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Univariate Gauss-Hermite quadrature rule — GHrule","text":"Qing Liu Donald . Pierce (1994).   Note Gauss-Hermite Quadrature. Biometrika 81(3), 624–629.   doi:10.2307/2337136","code":""},{"path":[]},{"path":"/reference/GHrule.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Univariate Gauss-Hermite quadrature rule — GHrule","text":"","code":"(r5  <- GHrule( 5, asMatrix=FALSE)) #>               z          w     ldnorm #> 1 -2.856970e+00 0.01125741 -5.0000774 #> 2 -1.355626e+00 0.22207592 -1.8377997 #> 3  3.865099e-17 0.53333333 -0.9189385 #> 4  1.355626e+00 0.22207592 -1.8377997 #> 5  2.856970e+00 0.01125741 -5.0000774 (r12 <- GHrule(12, asMatrix=FALSE)) #>            z            w     ldnorm #> 1  -5.500902 1.499927e-07 -16.048898 #> 2  -4.271826 4.837185e-05 -10.043187 #> 3  -3.223710 2.203381e-03  -6.115091 #> 4  -2.259464 2.911669e-02  -3.471528 #> 5  -1.340375 1.469670e-01  -1.817241 #> 6  -0.444403 3.216644e-01  -1.017686 #> 7   0.444403 3.216644e-01  -1.017686 #> 8   1.340375 1.469670e-01  -1.817241 #> 9   2.259464 2.911669e-02  -3.471528 #> 10  3.223710 2.203381e-03  -6.115091 #> 11  4.271826 4.837185e-05 -10.043187 #> 12  5.500902 1.499927e-07 -16.048898  ## second, fourth, sixth, eighth and tenth central moments of the ## standard Gaussian N(0,1) density: ps <- seq(2, 10, by = 2) cbind(p = ps, \"E[X^p]\" = with(r5,  sapply(ps, function(p) sum(w * z^p)))) # p=10 is wrong for 5-rule #>       p E[X^p] #> [1,]  2      1 #> [2,]  4      3 #> [3,]  6     15 #> [4,]  8    105 #> [5,] 10    825 p <- 1:15 GQ12 <- with(r12, sapply(p, function(p) sum(w * z^p))) cbind(p = p, \"E[X^p]\" = zapsmall(GQ12)) #>        p E[X^p] #>  [1,]  1      0 #>  [2,]  2      1 #>  [3,]  3      0 #>  [4,]  4      3 #>  [5,]  5      0 #>  [6,]  6     15 #>  [7,]  7      0 #>  [8,]  8    105 #>  [9,]  9      0 #> [10,] 10    945 #> [11,] 11      0 #> [12,] 12  10395 #> [13,] 13      0 #> [14,] 14 135135 #> [15,] 15      0 ## standard R numerical integration can do it too: intL <- lapply(p, function(p) integrate(function(x) x^p * dnorm(x),                                         -Inf, Inf, rel.tol=1e-11)) integR <- sapply(intL, `[[`, \"value\") cbind(p, \"E[X^p]\" = integR)# no zapsmall() needed here #>        p E[X^p] #>  [1,]  1      0 #>  [2,]  2      1 #>  [3,]  3      0 #>  [4,]  4      3 #>  [5,]  5      0 #>  [6,]  6     15 #>  [7,]  7      0 #>  [8,]  8    105 #>  [9,]  9      0 #> [10,] 10    945 #> [11,] 11      0 #> [12,] 12  10395 #> [13,] 13      0 #> [14,] 14 135135 #> [15,] 15      0 all.equal(GQ12, integR, tol=0)# => shows small difference #> [1] \"Mean relative difference: 5.910896e-15\" stopifnot(all.equal(GQ12, integR, tol = 1e-10)) (xactMom <- cumprod(seq(1,13, by=2))) #> [1]      1      3     15    105    945  10395 135135 stopifnot(all.equal(xactMom, GQ12[2*(1:7)], tol=1e-14)) ## mean relative errors : mean(abs(GQ12  [2*(1:7)] / xactMom - 1)) # 3.17e-16 #> [1] 3.172066e-16 mean(abs(integR[2*(1:7)] / xactMom - 1)) # 9.52e-17 {even better} #> [1] 9.516197e-17"},{"path":"/reference/GQdk.html","id":null,"dir":"Reference","previous_headings":"","what":"Sparse Gaussian / Gauss-Hermite Quadrature grid — GQdk","title":"Sparse Gaussian / Gauss-Hermite Quadrature grid — GQdk","text":"Generate sparse multidimensional Gaussian quadrature grids. Currently unused.  See GHrule() version   currently use package lme4.","code":""},{"path":"/reference/GQdk.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Sparse Gaussian / Gauss-Hermite Quadrature grid — GQdk","text":"","code":"GQdk(d = 1L, k = 1L)   GQN"},{"path":"/reference/GQdk.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Sparse Gaussian / Gauss-Hermite Quadrature grid — GQdk","text":"d integer scalar - dimension function     integrated respect standard     d-dimensional Gaussian density. k integer scalar - order grid.  grid     order k provides exact result     polynomial total order 2k - 1 less.","code":""},{"path":"/reference/GQdk.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Sparse Gaussian / Gauss-Hermite Quadrature grid — GQdk","text":"GQdk() returns matrix d + 1 columns.  first   column weights remaining d columns   node coordinates. GQN list lists, containing   non-redundant quadrature nodes weights integration scalar   function d-dimensional argument respect density   function d-dimensional Gaussian density function.      outer list indexed dimension, d,   range 1 20.  inner list indexed k,   order quadrature.","code":""},{"path":"/reference/GQdk.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Sparse Gaussian / Gauss-Hermite Quadrature grid — GQdk","text":"GQN contains non-redundant nodes.  regenerate   whole array nodes, possible permutations   axes possible combinations \\(\\pm 1\\)   must applied axes.  entire array nodes exactly   GQdk() reproduces. number nodes gets large quickly   increasing d k.  See charts   http://www.sparse-grids.de.","code":""},{"path":"/reference/GQdk.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Sparse Gaussian / Gauss-Hermite Quadrature grid — GQdk","text":"","code":"GQdk(2,5) # 53 x 3 #>              [,1]       [,2]       [,3] #>  [1,]  1.51111111  0.0000000  0.0000000 #>  [2,] -0.45412415  0.0000000 -0.7419638 #>  [3,] -0.33333333  0.0000000 -1.0000000 #>  [4,]  0.22207592  0.0000000 -1.3556262 #>  [5,]  0.11111111  0.0000000 -1.7320508 #>  [6,] -0.04587585  0.0000000 -2.3344142 #>  [7,]  0.01125741  0.0000000 -2.8569700 #>  [8,]  0.22706207 -0.7419638 -1.0000000 #>  [9,] -0.08333333 -1.0000000 -1.7320508 #> [10,]  0.02293793 -1.0000000 -2.3344142 #> [11,]  0.02777778 -1.7320508 -1.7320508 #> [12,] -0.45412415 -0.7419638  0.0000000 #> [13,] -0.33333333 -1.0000000  0.0000000 #> [14,]  0.22207592 -1.3556262  0.0000000 #> [15,]  0.11111111 -1.7320508  0.0000000 #> [16,] -0.04587585 -2.3344142  0.0000000 #> [17,]  0.01125741 -2.8569700  0.0000000 #> [18,]  0.22706207 -1.0000000 -0.7419638 #> [19,] -0.08333333 -1.7320508 -1.0000000 #> [20,]  0.02293793 -2.3344142 -1.0000000 #> [21,]  0.22706207  0.7419638 -1.0000000 #> [22,] -0.08333333  1.0000000 -1.7320508 #> [23,]  0.02293793  1.0000000 -2.3344142 #> [24,]  0.02777778  1.7320508 -1.7320508 #> [25,] -0.45412415  0.7419638  0.0000000 #> [26,] -0.33333333  1.0000000  0.0000000 #> [27,]  0.22207592  1.3556262  0.0000000 #> [28,]  0.11111111  1.7320508  0.0000000 #> [29,] -0.04587585  2.3344142  0.0000000 #> [30,]  0.01125741  2.8569700  0.0000000 #> [31,]  0.22706207  1.0000000 -0.7419638 #> [32,] -0.08333333  1.7320508 -1.0000000 #> [33,]  0.02293793  2.3344142 -1.0000000 #> [34,] -0.45412415  0.0000000  0.7419638 #> [35,] -0.33333333  0.0000000  1.0000000 #> [36,]  0.22207592  0.0000000  1.3556262 #> [37,]  0.11111111  0.0000000  1.7320508 #> [38,] -0.04587585  0.0000000  2.3344142 #> [39,]  0.01125741  0.0000000  2.8569700 #> [40,]  0.22706207 -0.7419638  1.0000000 #> [41,] -0.08333333 -1.0000000  1.7320508 #> [42,]  0.02293793 -1.0000000  2.3344142 #> [43,]  0.02777778 -1.7320508  1.7320508 #> [44,]  0.22706207 -1.0000000  0.7419638 #> [45,] -0.08333333 -1.7320508  1.0000000 #> [46,]  0.02293793 -2.3344142  1.0000000 #> [47,]  0.22706207  0.7419638  1.0000000 #> [48,] -0.08333333  1.0000000  1.7320508 #> [49,]  0.02293793  1.0000000  2.3344142 #> [50,]  0.02777778  1.7320508  1.7320508 #> [51,]  0.22706207  1.0000000  0.7419638 #> [52,] -0.08333333  1.7320508  1.0000000 #> [53,]  0.02293793  2.3344142  1.0000000  GQN[[3]][[5]] # a 14 x 4 matrix #>              [,1] [,2]      [,3]      [,4] #>  [1,]  4.93333333    0 0.0000000 0.0000000 #>  [2,] -0.90824829    0 0.0000000 0.7419638 #>  [3,] -1.33333333    0 0.0000000 1.0000000 #>  [4,]  0.22207592    0 0.0000000 1.3556262 #>  [5,]  0.38888889    0 0.0000000 1.7320508 #>  [6,] -0.09175171    0 0.0000000 2.3344142 #>  [7,]  0.01125741    0 0.0000000 2.8569700 #>  [8,]  0.22706207    0 0.7419638 1.0000000 #>  [9,]  0.41666667    0 1.0000000 1.0000000 #> [10,] -0.16666667    0 1.0000000 1.7320508 #> [11,]  0.02293793    0 1.0000000 2.3344142 #> [12,]  0.02777778    0 1.7320508 1.7320508 #> [13,] -0.25000000    1 1.0000000 1.0000000 #> [14,]  0.04166667    1 1.0000000 1.7320508"},{"path":"/reference/InstEval.html","id":null,"dir":"Reference","previous_headings":"","what":"University Lecture/Instructor Evaluations by Students at ETH — InstEval","title":"University Lecture/Instructor Evaluations by Students at ETH — InstEval","text":"University lecture evaluations students ETH Zurich,   anonymized privacy protection.    interesting “medium” sized example   partially nested mixed effect model.","code":""},{"path":"/reference/InstEval.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"University Lecture/Instructor Evaluations by Students at ETH — InstEval","text":"data frame 73421 observations following 7 variables. s factor levels 1:2972 denoting       individual students. d factor 1128 levels 1:2160, denoting       individual professors lecturers. studage ordered factor levels 2 <       4 < 6 < 8, denoting student's “age”       measured semester number student enrolled. lectage ordered factor 6 levels, 1 <       2 < ... < 6, measuring many semesters back       lecture rated taken place. service binary factor levels 0       1; lecture “service”, held       different department lecturer's main one. dept factor 14 levels 1:15, using       random code department lecture. y numeric vector ratings lectures       students, using discrete scale 1:5, meanings       ‘poor’ ‘good’. observation one student's rating specific lecture   (one lecturer, one semester past).","code":""},{"path":"/reference/InstEval.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"University Lecture/Instructor Evaluations by Students at ETH — InstEval","text":"main goal survey find “best   liked prof”, according lectures given.   Statistical analysis data basis   (student) jury selecting final winners. present data set anonymized slightly   simplified purpose.","code":""},{"path":"/reference/InstEval.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"University Lecture/Instructor Evaluations by Students at ETH — InstEval","text":"","code":"str(InstEval) #> 'data.frame':\t73421 obs. of  7 variables: #>  $ s      : Factor w/ 2972 levels \"1\",\"2\",\"3\",\"4\",..: 1 1 1 1 2 2 3 3 3 3 ... #>  $ d      : Factor w/ 1128 levels \"1\",\"6\",\"7\",\"8\",..: 525 560 832 1068 62 406 3 6 19 75 ... #>  $ studage: Ord.factor w/ 4 levels \"2\"<\"4\"<\"6\"<\"8\": 1 1 1 1 1 1 1 1 1 1 ... #>  $ lectage: Ord.factor w/ 6 levels \"1\"<\"2\"<\"3\"<\"4\"<..: 2 1 2 2 1 1 1 1 1 1 ... #>  $ service: Factor w/ 2 levels \"0\",\"1\": 1 2 1 2 1 1 2 1 1 1 ... #>  $ dept   : Factor w/ 14 levels \"15\",\"5\",\"10\",..: 14 5 14 12 2 2 13 3 3 3 ... #>  $ y      : int  5 2 5 3 2 4 4 5 5 4 ...  head(InstEval, 16) #>    s    d studage lectage service dept y #> 1  1 1002       2       2       0    2 5 #> 2  1 1050       2       1       1    6 2 #> 3  1 1582       2       2       0    2 5 #> 4  1 2050       2       2       1    3 3 #> 5  2  115       2       1       0    5 2 #> 6  2  756       2       1       0    5 4 #> 7  3    7       2       1       1   11 4 #> 8  3   13       2       1       0   10 5 #> 9  3   36       2       1       0   10 5 #> 10 3  140       2       1       0   10 4 #> 11 3  409       2       2       0   10 4 #> 12 3  444       2       2       0   10 4 #> 13 3  494       2       1       1    9 4 #> 14 3  625       2       2       0   10 3 #> 15 3  696       2       2       1    9 2 #> 16 3 1056       2       2       1    8 4 xtabs(~ service + dept, InstEval) #>        dept #> service   15    5   10   12    6    7    4    8    9   14    1    3   11    2 #>       0 2466 3576 4343 6209 3772 1601 4518  578 4224 2606 1260 3550 1711 1224 #>       1  826  214  365 3319 4325  919 2207 3848 2400 1328 1372 1199 6863 2598"},{"path":"/reference/NelderMead-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Class \"NelderMead\" reference class Nelder-Mead   simplex optimizer allowing box constraints parameters using   reverse communication. NelderMead() function conveniently generates objects.","code":""},{"path":"/reference/NelderMead-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class ","text":"","code":"NelderMead(...)"},{"path":"/reference/NelderMead-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class ","text":"... Argument list (see Note ).","code":""},{"path":"/reference/NelderMead-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class ","text":"default optimizer second stage   glmer nlmer fits.    found reliable often faster   sophisticated optimizers. Arguments NelderMead() new method must   named arguments: lower numeric vector lower bounds - elements may -Inf. upper numeric vector upper bounds - elements may Inf. xst numeric vector initial step sizes establish       simplex - elements must non-zero. x0 numeric vector starting values parameters. xt numeric vector tolerances parameters.","code":""},{"path":"/reference/NelderMead-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"NelderMead$new(lower, upper, xst, x0, xt) Create       new NelderMead object","code":""},{"path":"/reference/NelderMead-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Class ","text":"reference classes extend inherit methods   \"envRefClass\".","code":""},{"path":"/reference/NelderMead-class.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Class ","text":"Based code NLopt collection.","code":""},{"path":[]},{"path":"/reference/NelderMead-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"showClass(\"NelderMead\") #> Class \"NelderMead\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"envRefClass\", directly #> Class \".environment\", by class \"envRefClass\", distance 2 #> Class \"refClass\", by class \"envRefClass\", distance 2 #> Class \"environment\", by class \"envRefClass\", distance 3, with explicit coerce #> Class \"refObject\", by class \"envRefClass\", distance 3"},{"path":"/reference/Nelder_Mead.html","id":null,"dir":"Reference","previous_headings":"","what":"Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained — NelderMead","title":"Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained — NelderMead","text":"Nelder-Mead optimization parameters, allowing   optimization subject box constraints (contrary default,   method = \"Nelder-Mead\", R's optim()),   using reverse communications.","code":""},{"path":"/reference/Nelder_Mead.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained — NelderMead","text":"","code":"Nelder_Mead(fn, par, lower = rep.int(-Inf, n), upper = rep.int(Inf, n),             control = list())"},{"path":"/reference/Nelder_Mead.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained — NelderMead","text":"fn function single numeric vector argument     returning numeric scalar. par numeric vector starting values parameters. lower numeric vector lower bounds (elements may -Inf). upper numeric vector upper bounds (elements may Inf). control named list control settings. Possible settings iprint numeric scalar - frequency printing evaluation information. \tDefaults 0 indicating printing. maxfun numeric scalar - maximum number function \tevaluations allowed (default:10000). FtolAbs numeric scalar - absolute tolerance \tchange function values (default: 1e-5) FtolRel numeric scalar - relative tolerance \tchange function values (default:1e-15) XtolRel numeric scalar - relative tolerance \tchange parameter values (default: 1e-7) MinfMax numeric scalar - maximum value \tminimum (default: .Machine$double.xmin) xst numeric vector initial step sizes \testablish simplex - elements must non-zero \t(default: rep(0.02,length(par))) xt numeric vector tolerances parameters (default: xst*5e-4) verbose numeric value: 0=printing, \t1=print every 20 evaluations, 2=print every 10 \tevalutions, 3=print every evaluation.  Sets \t‘iprint’, specified, override . warnOnly logical indicating non-convergence (codes \t-1,-2,-3) stop(.), rather call \twarning return result might inspected. \tDefaults FALSE, .e., stop non-convergence.","code":""},{"path":"/reference/Nelder_Mead.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained — NelderMead","text":"list components fval numeric scalar - minimum function value achieved par numeric vector - value x providing minimum convergence integer valued scalar, 0, error code: -4 nm_evals: maximum evaluations reached -3 nm_forced: ? -2 nm_nofeasible: generate feasible simplex -1 nm_x0notfeasible: initial x feasible (?) 0 successful convergence  message string specifying kind convergence. control list control settings     substituting defaults. feval number function evaluations.","code":""},{"path":[]},{"path":"/reference/Nelder_Mead.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nelder-Mead Optimization of Parameters, Possibly (Box) Constrained — NelderMead","text":"","code":"fr <- function(x) {   ## Rosenbrock Banana function     x1 <- x[1]     x2 <- x[2]     100 * (x2 - x1 * x1)^2 + (1 - x1)^2 } p0 <- c(-1.2, 1)  oo  <- optim(p0, fr) ## also uses Nelder-Mead by default o.  <- Nelder_Mead(fr, p0) o.1 <- Nelder_Mead(fr, p0, control=list(verbose=1))# -> some iteration output #> (NM) 20: f = 4.09883 at -0.998242   1.02902 #> (NM) 40: f = 3.85065 at -0.946969  0.921237 #> (NM) 60: f = 2.12558 at -0.43529 0.215075 #> (NM) 80: f = 1.052 at -0.00264012  -0.0216052 #> (NM) 100: f = 0.351113 at 0.431272 0.169364 #> (NM) 120: f = 0.0662375 at  0.77641 0.590067 #> (NM) 140: f = 0.00120832 at 0.976014  0.95512 #> (NM) 160: f = 8.04753e-06 at 1.00132  1.0029 #> (NM) 180: f = 4.64058e-08 at 0.999793 0.999593 #> (NM) 200: f = 1.94299e-10 at 0.999989 0.999979 stopifnot(identical(o.[1:4], o.1[1:4]),           all.equal(o.$par, oo$par, tolerance=1e-3))# diff: 0.0003865   o.2 <- Nelder_Mead(fr, p0, control=list(verbose=3, XtolRel=1e-15, FtolAbs= 1e-14)) #> (NM) 1: f = inf at -1.2    1 #> (NM) init_pos <= d_n #> (NM) 2: f = 24.2 at -1.2    1 #> (NM) init_pos <= d_n #> (NM) 3: f = 20.1502 at -1.18     1 #> (NM) init_pos <= d_n #> (NM) 4: f = 20.1502 at -1.18     1 #> (NM) 5: f = 18.6206 at -1.18  1.02 #> (NM) 6: f = 16.1942 at -1.17  1.03 #> (NM) 7: f = 14.3881 at -1.15  1.01 #> (NM) 8: f = 11.3082 at -1.125  1.005 #> (NM) 9: f = 8.80899 at -1.115  1.035 #> (NM) 10: f = 5.7602 at -1.0825  1.0525 #> (NM) 11: f = 4.39059 at -1.0375  1.0275 #> (NM) 12: f = 4.39059 at -1.0375  1.0275 #> (NM) 13: f = 4.39059 at -1.0375  1.0275 #> (NM) 14: f = 4.39059 at -1.0375  1.0275 #> (NM) 15: f = 4.39059 at -1.0375  1.0275 #> (NM) 16: f = 4.39059 at -1.0375  1.0275 #> (NM) 17: f = 4.12674 at -1.02852  1.04695 #> (NM) 18: f = 4.12674 at -1.02852  1.04695 #> (NM) 19: f = 4.12674 at -1.02852  1.04695 #> (NM) 20: f = 4.09883 at -0.998242   1.02902 #> (NM) 21: f = 4.09883 at -0.998242   1.02902 #> (NM) 22: f = 4.07791 at -1.01767  1.02731 #> (NM) 23: f = 4.06835 at -0.987393   1.00938 #> (NM) 24: f = 4.06835 at -0.987393   1.00938 #> (NM) 25: f = 4.03092 at -1.00682  1.00768 #> (NM) 26: f = 4.03092 at -1.00682  1.00768 #> (NM) 27: f = 4.03092 at -1.00682  1.00768 #> (NM) 28: f = 3.98541 at -0.995967  0.988037 #> (NM) 29: f = 3.98541 at -0.995967  0.988037 #> (NM) 30: f = 3.98541 at -0.995967  0.988037 #> (NM) 31: f = 3.98541 at -0.995967  0.988037 #> (NM) 32: f = 3.98541 at -0.995967  0.988037 #> (NM) 33: f = 3.98078 at -0.988967  0.993801 #> (NM) 34: f = 3.94339 at -0.978118  0.974163 #> (NM) 35: f = 3.93793 at -0.963768  0.957406 #> (NM) 36: f = 3.93793 at -0.963768  0.957406 #> (NM) 37: f = 3.93793 at -0.963768  0.957406 #> (NM) 38: f = 3.89364 at -0.960968  0.945425 #> (NM) 39: f = 3.85065 at -0.946969  0.921237 #> (NM) 40: f = 3.85065 at -0.946969  0.921237 #> (NM) 41: f = 3.77359 at -0.90777 0.860654 #> (NM) 42: f = 3.68007 at -0.879771  0.812278 #> (NM) 43: f = 3.67015 at -0.90217 0.836692 #> (NM) 44: f = 3.59215 at -0.890971  0.806627 #> (NM) 45: f = 3.36249 at -0.823773  0.697667 #> (NM) 46: f = 3.10773 at -0.762175  0.585882 #> (NM) 47: f = 3.10773 at -0.762175  0.585882 #> (NM) 48: f = 3.0182 at -0.64458 0.359486 #> (NM) 49: f = 3.0182 at -0.64458 0.359486 #> (NM) 50: f = 2.79777 at -0.63338 0.365137 #> (NM) 51: f = 2.79777 at -0.63338 0.365137 #> (NM) 52: f = 2.79777 at -0.63338 0.365137 #> (NM) 53: f = 2.79777 at -0.63338 0.365137 #> (NM) 54: f = 2.59475 at -0.601882  0.345315 #> (NM) 55: f = 2.49823 at -0.580533  0.338229 #> (NM) 56: f = 2.49823 at -0.580533  0.338229 #> (NM) 57: f = 2.18451 at -0.477988  0.229247 #> (NM) 58: f = 2.12558 at -0.43529 0.215075 #> (NM) 59: f = 2.12558 at -0.43529 0.215075 #> (NM) 60: f = 2.12558 at -0.43529 0.215075 #> (NM) 61: f = 1.85847 at -0.339132 0.0894769 #> (NM) 62: f = 1.85847 at -0.339132 0.0894769 #> (NM) 63: f = 1.74109 at  -0.169346 -0.0324544 #> (NM) 64: f = 1.74109 at  -0.169346 -0.0324544 #> (NM) 65: f = 1.74109 at  -0.169346 -0.0324544 #> (NM) 66: f = 1.74109 at  -0.169346 -0.0324544 #> (NM) 67: f = 1.74109 at  -0.169346 -0.0324544 #> (NM) 68: f = 1.74109 at  -0.169346 -0.0324544 #> (NM) 69: f = 1.74109 at  -0.169346 -0.0324544 #> (NM) 70: f = 1.6557 at -0.269968 0.0521755 #> (NM) 71: f = 1.55396 at    -0.17894 -0.00848461 #> (NM) 72: f = 1.50655 at  -0.138222 -0.0268297 #> (NM) 73: f = 1.50655 at  -0.138222 -0.0268297 #> (NM) 74: f = 1.33243 at -0.107098 -0.021205 #> (NM) 75: f = 1.33243 at -0.107098 -0.021205 #> (NM) 76: f = 1.33243 at -0.107098 -0.021205 #> (NM) 77: f = 1.33243 at -0.107098 -0.021205 #> (NM) 78: f = 1.16367 at -0.0478342 -0.0233467 #> (NM) 79: f = 1.052 at -0.00264012  -0.0216052 #> (NM) 80: f = 1.052 at -0.00264012  -0.0216052 #> (NM) 81: f = 0.980011 at 0.0203829 0.0146849 #> (NM) 82: f = 0.794206 at  0.110771 0.0181679 #> (NM) 83: f = 0.794206 at  0.110771 0.0181679 #> (NM) 84: f = 0.794206 at  0.110771 0.0181679 #> (NM) 85: f = 0.794206 at  0.110771 0.0181679 #> (NM) 86: f = 0.794206 at  0.110771 0.0181679 #> (NM) 87: f = 0.607797 at  0.224182 0.0579409 #> (NM) 88: f = 0.607797 at  0.224182 0.0579409 #> (NM) 89: f = 0.607797 at  0.224182 0.0579409 #> (NM) 90: f = 0.607797 at  0.224182 0.0579409 #> (NM) 91: f = 0.44247 at 0.375246 0.117973 #> (NM) 92: f = 0.44247 at 0.375246 0.117973 #> (NM) 93: f = 0.44247 at 0.375246 0.117973 #> (NM) 94: f = 0.44247 at 0.375246 0.117973 #> (NM) 95: f = 0.351113 at 0.431272 0.169364 #> (NM) 96: f = 0.351113 at 0.431272 0.169364 #> (NM) 97: f = 0.351113 at 0.431272 0.169364 #> (NM) 98: f = 0.351113 at 0.431272 0.169364 #> (NM) 99: f = 0.351113 at 0.431272 0.169364 #> (NM) 100: f = 0.351113 at 0.431272 0.169364 #> (NM) 101: f = 0.308628 at 0.445597 0.194999 #> (NM) 102: f = 0.270158 at 0.480773 0.233512 #> (NM) 103: f = 0.270158 at 0.480773 0.233512 #> (NM) 104: f = 0.197707 at 0.593757 0.334471 #> (NM) 105: f = 0.197707 at 0.593757 0.334471 #> (NM) 106: f = 0.197707 at 0.593757 0.334471 #> (NM) 107: f = 0.197707 at 0.593757 0.334471 #> (NM) 108: f = 0.197707 at 0.593757 0.334471 #> (NM) 109: f = 0.126096 at 0.645994 0.420093 #> (NM) 110: f = 0.126096 at 0.645994 0.420093 #> (NM) 111: f = 0.126096 at 0.645994 0.420093 #> (NM) 112: f = 0.106835 at 0.690501 0.487301 #> (NM) 113: f = 0.106835 at 0.690501 0.487301 #> (NM) 114: f = 0.106835 at 0.690501 0.487301 #> (NM) 115: f = 0.106835 at 0.690501 0.487301 #> (NM) 116: f = 0.106835 at 0.690501 0.487301 #> (NM) 117: f = 0.10306 at 0.688431 0.466201 #> (NM) 118: f = 0.0727579 at 0.732938 0.533409 #> (NM) 119: f = 0.0662375 at  0.77641 0.590067 #> (NM) 120: f = 0.0662375 at  0.77641 0.590067 #> (NM) 121: f = 0.0662375 at  0.77641 0.590067 #> (NM) 122: f = 0.0458798 at 0.799439 0.631583 #> (NM) 123: f = 0.0458798 at 0.799439 0.631583 #> (NM) 124: f = 0.0458798 at 0.799439 0.631583 #> (NM) 125: f = 0.0458798 at 0.799439 0.631583 #> (NM) 126: f = 0.0274164 at 0.842102 0.704151 #> (NM) 127: f = 0.0175222 at 0.874948 0.761194 #> (NM) 128: f = 0.0175222 at 0.874948 0.761194 #> (NM) 129: f = 0.0175222 at 0.874948 0.761194 #> (NM) 130: f = 0.0175222 at 0.874948 0.761194 #> (NM) 131: f = 0.0175222 at 0.874948 0.761194 #> (NM) 132: f = 0.0175222 at 0.874948 0.761194 #> (NM) 133: f = 0.00997536 at 0.900123 0.810242 #> (NM) 134: f = 0.00440675 at 0.943057 0.885944 #> (NM) 135: f = 0.00440675 at 0.943057 0.885944 #> (NM) 136: f = 0.00440675 at 0.943057 0.885944 #> (NM) 137: f = 0.00395144 at 0.942326 0.890478 #> (NM) 138: f = 0.00120832 at 0.976014  0.95512 #> (NM) 139: f = 0.00120832 at 0.976014  0.95512 #> (NM) 140: f = 0.00120832 at 0.976014  0.95512 #> (NM) 141: f = 0.00120832 at 0.976014  0.95512 #> (NM) 142: f = 0.00120832 at 0.976014  0.95512 #> (NM) 143: f = 0.00120832 at 0.976014  0.95512 #> (NM) 144: f = 0.00120832 at 0.976014  0.95512 #> (NM) 145: f = 0.00101227 at 1.00728 1.01771 #> (NM) 146: f = 0.00101227 at 1.00728 1.01771 #> (NM) 147: f = 0.000184224 at  1.0134 1.02676 #> (NM) 148: f = 0.000184224 at  1.0134 1.02676 #> (NM) 149: f = 0.000184224 at  1.0134 1.02676 #> (NM) 150: f = 7.50713e-05 at 0.999298 0.997733 #> (NM) 151: f = 7.50713e-05 at 0.999298 0.997733 #> (NM) 152: f = 7.50713e-05 at 0.999298 0.997733 #> (NM) 153: f = 7.50713e-05 at 0.999298 0.997733 #> (NM) 154: f = 7.50713e-05 at 0.999298 0.997733 #> (NM) 155: f = 7.50713e-05 at 0.999298 0.997733 #> (NM) 156: f = 7.50713e-05 at 0.999298 0.997733 #> (NM) 157: f = 4.19678e-05 at 1.00646 1.01293 #> (NM) 158: f = 4.19678e-05 at 1.00646 1.01293 #> (NM) 159: f = 8.04753e-06 at 1.00132  1.0029 #> (NM) 160: f = 8.04753e-06 at 1.00132  1.0029 #> (NM) 161: f = 8.04753e-06 at 1.00132  1.0029 #> (NM) 162: f = 8.04753e-06 at 1.00132  1.0029 #> (NM) 163: f = 8.04753e-06 at 1.00132  1.0029 #> (NM) 164: f = 2.30719e-06 at 1.00024 1.00033 #> (NM) 165: f = 2.30719e-06 at 1.00024 1.00033 #> (NM) 166: f = 2.02763e-06 at 0.998617 0.997203 #> (NM) 167: f = 2.02763e-06 at 0.998617 0.997203 #> (NM) 168: f = 7.9281e-07 at 1.00038 1.00083 #> (NM) 169: f = 7.9281e-07 at 1.00038 1.00083 #> (NM) 170: f = 4.11309e-07 at 0.999869 0.999675 #> (NM) 171: f = 4.11309e-07 at 0.999869 0.999675 #> (NM) 172: f = 4.11309e-07 at 0.999869 0.999675 #> (NM) 173: f = 4.11309e-07 at 0.999869 0.999675 #> (NM) 174: f = 4.77849e-08 at 0.999998  1.00002 #> (NM) 175: f = 4.77849e-08 at 0.999998  1.00002 #> (NM) 176: f = 4.77849e-08 at 0.999998  1.00002 #> (NM) 177: f = 4.77849e-08 at 0.999998  1.00002 #> (NM) 178: f = 4.77849e-08 at 0.999998  1.00002 #> (NM) 179: f = 4.77849e-08 at 0.999998  1.00002 #> (NM) 180: f = 4.64058e-08 at 0.999793 0.999593 #> (NM) 181: f = 4.64058e-08 at 0.999793 0.999593 #> (NM) 182: f = 9.81791e-09 at 0.999977 0.999944 #> (NM) 183: f = 9.81791e-09 at 0.999977 0.999944 #> (NM) 184: f = 9.81791e-09 at 0.999977 0.999944 #> (NM) 185: f = 9.81791e-09 at 0.999977 0.999944 #> (NM) 186: f = 9.81791e-09 at 0.999977 0.999944 #> (NM) 187: f = 2.51267e-09 at 1.00004 1.00008 #> (NM) 188: f = 2.51267e-09 at 1.00004 1.00008 #> (NM) 189: f = 9.81397e-10 at 0.999975 0.999953 #> (NM) 190: f = 9.81397e-10 at 0.999975 0.999953 #> (NM) 191: f = 9.81397e-10 at 0.999975 0.999953 #> (NM) 192: f = 9.81397e-10 at 0.999975 0.999953 #> (NM) 193: f = 9.81397e-10 at 0.999975 0.999953 #> (NM) 194: f = 4.39883e-10 at 1.00002 1.00004 #> (NM) 195: f = 4.39883e-10 at 1.00002 1.00004 #> (NM) 196: f = 4.39883e-10 at 1.00002 1.00004 #> (NM) 197: f = 2.55886e-10 at 0.999985 0.999969 #> (NM) 198: f = 2.55886e-10 at 0.999985 0.999969 #> (NM) 199: f = 1.94299e-10 at 0.999989 0.999979 #> (NM) 200: f = 1.94299e-10 at 0.999989 0.999979 #> (NM) 201: f = 1.84303e-11 at       1 1.00001 #> (NM) 202: f = 1.84303e-11 at       1 1.00001 #> (NM) 203: f = 1.84303e-11 at       1 1.00001 #> (NM) 204: f = 1.84303e-11 at       1 1.00001 #> (NM) 205: f = 1.84303e-11 at       1 1.00001 all.equal(o.2[-5],o.1[-5], tolerance=1e-15)# TRUE, unexpectedly #> [1] \"Component “control”: Component “iprint”: Mean relative difference: 19\"     #> [2] \"Component “control”: Component “FtolAbs”: Mean relative difference: 1e+09\" #> [3] \"Component “control”: Component “XtolRel”: Mean absolute difference: 1e-07\""},{"path":"/reference/Pastes.html","id":null,"dir":"Reference","previous_headings":"","what":"Paste strength by batch and cask — Pastes","title":"Paste strength by batch and cask — Pastes","text":"Strength chemical paste product; quality   depending delivery batch, cask within   delivery.","code":""},{"path":"/reference/Pastes.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Paste strength by batch and cask — Pastes","text":"data frame 60 observations following 4 variables. strength paste strength. batch delivery batch sample       sample.  factor 10 levels: ‘’ ‘J’. cask cask within delivery batch       sample chosen.  factor 3 levels: ‘’       ‘c’. sample sample paste whose strength assayed,       two assays per sample. factor 30 levels: ‘:’       ‘J:c’.","code":""},{"path":"/reference/Pastes.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Paste strength by batch and cask — Pastes","text":"O.L. Davies P.L. Goldsmith (eds), Statistical   Methods Research Production, 4th ed., Oliver   Boyd, (1972), section 6.5","code":""},{"path":"/reference/Pastes.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Paste strength by batch and cask — Pastes","text":"data described Davies Goldsmith (1972)   coming “ deliveries chemical paste   product contained casks , addition sampling   testing errors, variations quality   deliveries ... routine, three casks   selected random delivery sampled   samples kept reference. ... Ten   delivery batches sampled random two   analytical tests carried 30 samples”.","code":""},{"path":"/reference/Pastes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Paste strength by batch and cask — Pastes","text":"","code":"str(Pastes) #> 'data.frame':\t60 obs. of  4 variables: #>  $ strength: num  62.8 62.6 60.1 62.3 62.7 63.1 60 61.4 57.5 56.9 ... #>  $ batch   : Factor w/ 10 levels \"A\",\"B\",\"C\",\"D\",..: 1 1 1 1 1 1 2 2 2 2 ... #>  $ cask    : Factor w/ 3 levels \"a\",\"b\",\"c\": 1 1 2 2 3 3 1 1 2 2 ... #>  $ sample  : Factor w/ 30 levels \"A:a\",\"A:b\",\"A:c\",..: 1 1 2 2 3 3 4 4 5 5 ... require(lattice) dotplot(cask ~ strength | reorder(batch, strength), Pastes,         strip = FALSE, strip.left = TRUE, layout = c(1, 10),         ylab = \"Cask within batch\",         xlab = \"Paste strength\", jitter.y = TRUE)  ## Modifying the factors to enhance the plot Pastes <- within(Pastes, batch <- reorder(batch, strength)) Pastes <- within(Pastes, sample <- reorder(reorder(sample, strength),           as.numeric(batch))) dotplot(sample ~ strength | batch, Pastes,         strip = FALSE, strip.left = TRUE, layout = c(1, 10),         scales = list(y = list(relation = \"free\")),         ylab = \"Sample within batch\",         xlab = \"Paste strength\", jitter.y = TRUE)  ## Four equivalent models differing only in specification (fm1 <- lmer(strength ~ (1|batch) + (1|sample), Pastes)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: strength ~ (1 | batch) + (1 | sample) #>    Data: Pastes #> REML criterion at convergence: 246.9907 #> Random effects: #>  Groups   Name        Std.Dev. #>  sample   (Intercept) 2.9041   #>  batch    (Intercept) 1.2874   #>  Residual             0.8234   #> Number of obs: 60, groups:  sample, 30; batch, 10 #> Fixed Effects: #> (Intercept)   #>       60.05   (fm2 <- lmer(strength ~ (1|batch/cask), Pastes)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: strength ~ (1 | batch/cask) #>    Data: Pastes #> REML criterion at convergence: 246.9907 #> Random effects: #>  Groups     Name        Std.Dev. #>  cask:batch (Intercept) 2.9041   #>  batch      (Intercept) 1.2874   #>  Residual               0.8234   #> Number of obs: 60, groups:  cask:batch, 30; batch, 10 #> Fixed Effects: #> (Intercept)   #>       60.05   (fm3 <- lmer(strength ~ (1|batch) + (1|batch:cask), Pastes)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: strength ~ (1 | batch) + (1 | batch:cask) #>    Data: Pastes #> REML criterion at convergence: 246.9907 #> Random effects: #>  Groups     Name        Std.Dev. #>  batch:cask (Intercept) 2.9041   #>  batch      (Intercept) 1.2874   #>  Residual               0.8234   #> Number of obs: 60, groups:  batch:cask, 30; batch, 10 #> Fixed Effects: #> (Intercept)   #>       60.05   (fm4 <- lmer(strength ~ (1|batch/sample), Pastes)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: strength ~ (1 | batch/sample) #>    Data: Pastes #> REML criterion at convergence: 246.9907 #> Random effects: #>  Groups       Name        Std.Dev. #>  sample:batch (Intercept) 2.9041   #>  batch        (Intercept) 1.2874   #>  Residual                 0.8234   #> Number of obs: 60, groups:  sample:batch, 30; batch, 10 #> Fixed Effects: #> (Intercept)   #>       60.05   ## fm4 results in redundant labels on the sample:batch interaction head(ranef(fm4)[[1]]) #>       (Intercept) #> E:b:E  -3.9424485 #> E:a:E  -3.3175663 #> E:c:E  -0.3854267 #> J:c:J  -1.7031213 #> J:a:J  -0.6936962 #> J:b:J  -0.3091533 ## compare to fm1 head(ranef(fm1)[[1]]) #>     (Intercept) #> E:b  -3.9424485 #> E:a  -3.3175663 #> E:c  -0.3854267 #> J:c  -1.7031213 #> J:a  -0.6936962 #> J:b  -0.3091533 ## This model is different and NOT appropriate for these data (fm5 <- lmer(strength ~ (1|batch) + (1|cask), Pastes)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: strength ~ (1 | batch) + (1 | cask) #>    Data: Pastes #> REML criterion at convergence: 301.4709 #> Random effects: #>  Groups   Name        Std.Dev. #>  batch    (Intercept) 1.8341   #>  cask     (Intercept) 0.3856   #>  Residual             2.7030   #> Number of obs: 60, groups:  batch, 10; cask, 3 #> Fixed Effects: #> (Intercept)   #>       60.05    L <- getME(fm1, \"L\") Matrix::image(L, sub = \"Structure of random effects interaction in pastes model\")"},{"path":"/reference/Penicillin.html","id":null,"dir":"Reference","previous_headings":"","what":"Variation in penicillin testing — Penicillin","title":"Variation in penicillin testing — Penicillin","text":"Six samples penicillin tested using B.   subtilis plate method 24 plates.    response diameter (mm) zone inhibition   growth organism.","code":""},{"path":"/reference/Penicillin.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Variation in penicillin testing — Penicillin","text":"data frame 144 observations following 3 variables. diameter diameter (mm) zone inhibition       growth organism. plate assay plate.  factor levels ‘’       ‘x’. sample penicillin sample.  factor levels       ‘’ ‘F’.","code":""},{"path":"/reference/Penicillin.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Variation in penicillin testing — Penicillin","text":"O.L. Davies P.L. Goldsmith (eds), Statistical   Methods Research Production, 4th ed., Oliver   Boyd, (1972), section 6.6","code":""},{"path":"/reference/Penicillin.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Variation in penicillin testing — Penicillin","text":"data described Davies Goldsmith (1972)   coming investigation “assess   variability samples penicillin B.   subtilis method.  test method bulk-inoculated   nutrient agar medium poured Petri dish   approximately 90 mm. diameter, known plate.    medium set, six small hollow cylinders pots   (4 mm. diameter) cemented onto surface   equally spaced intervals.  drops   penicillin solutions compared placed   respective cylinders, whole plate placed   incubator given time.  Penicillin diffuses   pots agar, produces clear circular   zone inhibition growth organisms, can   readily measured.  diameter zone related   known way concentration penicillin   solution.”","code":""},{"path":"/reference/Penicillin.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Variation in penicillin testing — Penicillin","text":"","code":"str(Penicillin) #> 'data.frame':\t144 obs. of  3 variables: #>  $ diameter: num  27 23 26 23 23 21 27 23 26 23 ... #>  $ plate   : Factor w/ 24 levels \"a\",\"b\",\"c\",\"d\",..: 1 1 1 1 1 1 2 2 2 2 ... #>  $ sample  : Factor w/ 6 levels \"A\",\"B\",\"C\",\"D\",..: 1 2 3 4 5 6 1 2 3 4 ... require(lattice) dotplot(reorder(plate, diameter) ~ diameter, Penicillin, groups = sample,         ylab = \"Plate\", xlab = \"Diameter of growth inhibition zone (mm)\",         type = c(\"p\", \"a\"), auto.key = list(columns = 3, lines = TRUE,         title = \"Penicillin sample\"))  (fm1 <- lmer(diameter ~ (1|plate) + (1|sample), Penicillin)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: diameter ~ (1 | plate) + (1 | sample) #>    Data: Penicillin #> REML criterion at convergence: 330.8606 #> Random effects: #>  Groups   Name        Std.Dev. #>  plate    (Intercept) 0.8467   #>  sample   (Intercept) 1.9316   #>  Residual             0.5499   #> Number of obs: 144, groups:  plate, 24; sample, 6 #> Fixed Effects: #> (Intercept)   #>       22.97    L <- getME(fm1, \"L\") Matrix::image(L, main = \"L\",               sub = \"Penicillin: Structure of random effects interaction\")"},{"path":"/reference/VarCorr.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Variance and Correlation Components — VarCorr","title":"Extract Variance and Correlation Components — VarCorr","text":"function calculates estimated variances,   standard deviations, correlations   random-effects terms mixed-effects model, class   merMod (linear, generalized   nonlinear).  within-group error variance standard   deviation also calculated.","code":""},{"path":"/reference/VarCorr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Variance and Correlation Components — VarCorr","text":"","code":"# S3 method for class 'merMod' VarCorr(x, sigma=1, ...)  <!-- %% documented because of \"surprising arguments\": --> # S3 method for class 'VarCorr.merMod' as.data.frame(x, row.names = NULL,     optional = FALSE, order = c(\"cov.last\", \"lower.tri\"), ...) # S3 method for class 'VarCorr.merMod' print(x, digits = max(3, getOption(\"digits\") - 2),     comp = \"Std.Dev.\", corr = any(comp == \"Std.Dev.\"),     formatter = format, ...)"},{"path":"/reference/VarCorr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Variance and Correlation Components — VarCorr","text":"x VarCorr: fitted model object, usually object inheriting     class merMod. .data.frame,     VarCorr.merMod object returned VarCorr. sigma optional numeric value used multiplier     standard deviations. digits optional integer value specifying number digits order arrange data frame variances/standard deviations     first covariances/correlations last random effects     term (\"cov.last\"), order lower triangle     variance-covariance matrix (\"lower.tri\")? row.names, optional Ignored: necessary     .data.frame method. ... Ignored .data.frame method; passed     print() methods print() method.  comp character vector, specifying components     printed; simply passed formatVC(). formatter function formatting numbers;     simply passed formatVC(). corr (logical) print correlations (rather covariances)     random effects?","code":""},{"path":"/reference/VarCorr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Variance and Correlation Components — VarCorr","text":"object class VarCorr.merMod. internal   structure object   list matrices, one random effects grouping   term.  grouping term, standard deviations   correlation matrices grouping term stored   attributes \"stddev\" \"correlation\",   respectively, variance-covariance matrix,   residual standard deviation stored attribute   \"sc\" (glmer fits, attribute stores   scale parameter model). .data.frame method produces combined data frame one row variance covariance parameter (row residual error term applicable) following columns: grp grouping factor var1 first variable var2 second variable (NA variance parameters) vcov variances covariances sdcor standard deviations correlations","code":""},{"path":"/reference/VarCorr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Variance and Correlation Components — VarCorr","text":"print method VarCorr.merMod objects   optional arguments digits (specify digits   precision printing) comp: latter   character vector combination \"Variance\"   \"Std.Dev.\", specify whether variances,   standard deviations, printed.","code":""},{"path":"/reference/VarCorr.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Extract Variance and Correlation Components — VarCorr","text":"modeled VarCorr   package nlme, Jose Pinheiro Douglas Bates.","code":""},{"path":[]},{"path":"/reference/VarCorr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Variance and Correlation Components — VarCorr","text":"","code":"data(Orthodont, package=\"nlme\") fm1 <- lmer(distance ~ age + (age|Subject), data = Orthodont) print(vc <- VarCorr(fm1))  ## default print method: standard dev and corr #>  Groups   Name        Std.Dev. Corr   #>  Subject  (Intercept) 2.32736         #>           age         0.22645  -0.609 #>  Residual             1.31002         ## both variance and std.dev. print(vc,comp=c(\"Variance\",\"Std.Dev.\"), digits=2) #>  Groups   Name        Variance Std.Dev. Corr  #>  Subject  (Intercept) 5.417    2.33           #>           age         0.051    0.23     -0.61 #>  Residual             1.716    1.31           ## variance only print(vc, comp=c(\"Variance\")) #>  Groups   Name        Variance Cov    #>  Subject  (Intercept) 5.416600        #>           age         0.051279 -0.321 #>  Residual             1.716157        ## standard deviations only, but covariances rather than correlations print(vc, corr = FALSE) #>  Groups   Name        Std.Dev. Cov    #>  Subject  (Intercept) 2.32736         #>           age         0.22645  -0.321 #>  Residual             1.31002         as.data.frame(vc) #>        grp        var1 var2       vcov      sdcor #> 1  Subject (Intercept) <NA>  5.4166005  2.3273591 #> 2  Subject         age <NA>  0.0512792  0.2264491 #> 3  Subject (Intercept)  age -0.3211854 -0.6094270 #> 4 Residual        <NA> <NA>  1.7161573  1.3100219 as.data.frame(vc, order=\"lower.tri\") #>        grp        var1 var2       vcov      sdcor #> 1  Subject (Intercept) <NA>  5.4166005  2.3273591 #> 2  Subject (Intercept)  age -0.3211854 -0.6094270 #> 3  Subject         age <NA>  0.0512792  0.2264491 #> 4 Residual        <NA> <NA>  1.7161573  1.3100219"},{"path":"/reference/VerbAgg.html","id":null,"dir":"Reference","previous_headings":"","what":"Verbal Aggression item responses — VerbAgg","title":"Verbal Aggression item responses — VerbAgg","text":"item responses questionaire verbal   aggression.  data used throughout De Boeck   Wilson (2004) illustrate various forms item   response models.","code":""},{"path":"/reference/VerbAgg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Verbal Aggression item responses — VerbAgg","text":"data frame 7584 observations following 13 variables. Anger subject's Trait Anger score measured       State-Trait Anger Expression Inventory (STAXI) Gender subject's gender - factor levels       M F item item questionaire, factor resp subject's response item - ordered       factor levels < perhaps < yes id subject identifier, factor btype behavior type - factor levels       curse, scold shout situ situation type - factor levels       self indicating --blame self--blame mode behavior mode - factor levels want       r2 dichotomous version response - factor       levels N Y","code":""},{"path":"/reference/VerbAgg.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Verbal Aggression item responses — VerbAgg","text":"Data originally UC Berkeley BEAR Center; original link   available   https://web.archive.org/web/20221128003829/https://old.bear.berkeley.edu/page/materials-explanatory-item-response-models,   data longer accessible .","code":""},{"path":"/reference/VerbAgg.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Verbal Aggression item responses — VerbAgg","text":"De Boeck Wilson (2004), Explanatory Item   Response Models, Springer.","code":""},{"path":"/reference/VerbAgg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Verbal Aggression item responses — VerbAgg","text":"","code":"str(VerbAgg) #> 'data.frame':\t7584 obs. of  9 variables: #>  $ Anger : int  20 11 17 21 17 21 39 21 24 16 ... #>  $ Gender: Factor w/ 2 levels \"F\",\"M\": 2 2 1 1 1 1 1 1 1 1 ... #>  $ item  : Factor w/ 24 levels \"S1WantCurse\",..: 1 1 1 1 1 1 1 1 1 1 ... #>  $ resp  : Ord.factor w/ 3 levels \"no\"<\"perhaps\"<..: 1 1 2 2 2 3 3 1 1 3 ... #>  $ id    : Factor w/ 316 levels \"1\",\"2\",\"3\",\"4\",..: 1 2 3 4 5 6 7 8 9 10 ... #>  $ btype : Factor w/ 3 levels \"curse\",\"scold\",..: 1 1 1 1 1 1 1 1 1 1 ... #>  $ situ  : Factor w/ 2 levels \"other\",\"self\": 1 1 1 1 1 1 1 1 1 1 ... #>  $ mode  : Factor w/ 2 levels \"want\",\"do\": 1 1 1 1 1 1 1 1 1 1 ... #>  $ r2    : Factor w/ 2 levels \"N\",\"Y\": 1 1 2 2 2 2 2 1 1 2 ... ## Show how  r2 := h(resp) is defined: with(VerbAgg, stopifnot( identical(r2, {      r <- factor(resp, ordered=FALSE); levels(r) <- c(\"N\",\"Y\",\"Y\"); r})))  xtabs(~ item + resp, VerbAgg) #>              resp #> item           no perhaps yes #>   S1WantCurse  91      95 130 #>   S1WantScold 126      86 104 #>   S1WantShout 154      99  63 #>   S2WantCurse  67     112 137 #>   S2WantScold 118      93 105 #>   S2WantShout 158      84  74 #>   S3WantCurse 128     120  68 #>   S3WantScold 198      90  28 #>   S3WantShout 240      63  13 #>   S4wantCurse  98     127  91 #>   S4WantScold 179      88  49 #>   S4WantShout 217      64  35 #>   S1DoCurse    91     108 117 #>   S1DoScold   136      97  83 #>   S1DoShout   208      68  40 #>   S2DoCurse   109      97 110 #>   S2DoScold   162      92  62 #>   S2DoShout   238      53  25 #>   S3DoCurse   171     108  37 #>   S3DoScold   239      61  16 #>   S3DoShout   287      25   4 #>   S4DoCurse   118     117  81 #>   S4DoScold   181      91  44 #>   S4DoShout   259      43  14 xtabs(~ btype + resp, VerbAgg) #>        resp #> btype     no perhaps  yes #>   curse  873     884  771 #>   scold 1339     698  491 #>   shout 1761     499  268 round(100 * ftable(prop.table(xtabs(~ situ + mode + resp, VerbAgg), 1:2), 1)) #>            resp no perhaps yes #> situ  mode                     #> other want      38      30  32 #>       do        50      27  23 #> self  want      56      29  15 #>       do        66      23  10 person <- unique(subset(VerbAgg, select = c(id, Gender, Anger))) require(lattice) densityplot(~ Anger, person, groups = Gender, auto.key = list(columns = 2),             xlab = \"Trait Anger score (STAXI)\")   if(lme4:::testLevel() >= 3) { ## takes about 15 sec     print(fmVA <- glmer(r2 ~ (Anger + Gender + btype + situ)^2 +         (1|id) + (1|item), family = binomial, data =        VerbAgg), corr=FALSE) } ## testLevel() >= 3 if (interactive()) { ## much faster but less accurate     print(fmVA0 <- glmer(r2 ~ (Anger + Gender + btype + situ)^2 +                              (1|id) + (1|item), family = binomial,                          data = VerbAgg, nAGQ=0L), corr=FALSE) } ## interactive()"},{"path":"/reference/allFit.html","id":null,"dir":"Reference","previous_headings":"","what":"Refit a fitted model with all available optimizers — allFit","title":"Refit a fitted model with all available optimizers — allFit","text":"Attempt re-fit [g]lmer model range optimizers. default use known optimizers R satisfy requirements (.e. require functions allow box constraints: see ‘optimizer’ lmerControl). optimizers fall four categories; () built-(minqa::bobyqa, lme4::Nelder_Mead, nlminbwrap), (ii) wrapped via optimx (optimx's optimizers allow box constraints require explicit gradient function specified; two provided base R functions can accessed via optimx), (iii) wrapped via nloptr (see examples list options), (iv) ‘dfoptim::nmkb’ (via (unexported) nmkbw wrapper: appears ‘nmkbw’ meth.tab)","code":""},{"path":"/reference/allFit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refit a fitted model with all available optimizers — allFit","text":"","code":"allFit(object, meth.tab = NULL, data=NULL,        verbose = TRUE,        show.meth.tab = FALSE,        maxfun = 1e5,        parallel = c(\"no\", \"multicore\", \"snow\"),        ncpus = getOption(\"allFit.ncpus\", 1L), cl = NULL,        catch.errs = TRUE)"},{"path":"/reference/allFit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refit a fitted model with all available optimizers — allFit","text":"object fitted model meth.tab matrix (data.frame) columns method name specific optimization method pass \toptimizer (leave blank built-optimizers) optimizer optimizer function use  data data included result (later debugging etc.) verbose logical: report progress detail? show.meth.tab logical: return table methods? maxfun passed part optCtrl set maximum     number function evaluations: automatically     converted correct specification (e.g. maxfun,     maxfeval, maxit, etc.) optimizer parallel type parallel operation used ().     missing,     default taken option \"boot.parallel\" (    set, \"\"). ncpus integer: number processes used parallel operation:   typically one choose number available CPUs.   Use options(allFit.ncpus=X) set default value X   duration R session. cl optional parallel snow cluster use     parallel = \"snow\".  supplied, cluster     local machine created duration boot call. catch.errs (logical) Wrap model fits tryCatch clause     skip errors? (catch.errs=FALSE probably     useful debugging)","code":""},{"path":"/reference/allFit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refit a fitted model with all available optimizers — allFit","text":"object type allFit, list fitted merMod objects (unless show.meth.tab   specified, case data frame methods returned).   summary method class   extracts tables variety useful information   different fits (see examples).","code":""},{"path":"/reference/allFit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refit a fitted model with all available optimizers — allFit","text":"Needs packages optimx, dfoptim use optimizers using parallel=\"snow\" (e.g. running parallel Windows), need set cluster run clusterEvalQ(cl,library(\"lme4\")) calling allFit make sure lme4 package loaded workers Control arguments control$optCtrl unused particular optimizer silently ignored (particular, maxfun specification respected bobyqa, Nelder_Mead, nmkbw) allFit works calling update, may fragile original model call contains references variables, especially originally defined environments longer exist allFit called.","code":""},{"path":[]},{"path":"/reference/allFit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refit a fitted model with all available optimizers — allFit","text":"","code":"if (interactive()) { library(lme4)   gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),              data = cbpp, family = binomial)   ## show available methods   allFit(show.meth.tab=TRUE)    gm_all <- allFit(gm1)   ss <- summary(gm_all)   ss$which.OK            ## logical vector: which optimizers worked?   ## the other components only contain values for the optimizers that worked   ss$llik                ## vector of log-likelihoods   ss$fixef               ## table of fixed effects   ss$sdcor               ## table of random effect SDs and correlations   ss$theta               ## table of random effects parameters, Cholesky scale }  if (FALSE) { # \\dontrun{   ## Parallel examples for Windows   nc <- detectCores()-1   optCls <- makeCluster(nc, type = \"SOCK\")   clusterEvalQ(optCls,library(\"lme4\"))   ### not necessary here because using a built-in   ## data set, but in general you should clusterExport() your data   clusterExport(optCls, \"cbpp\")   system.time(af1 <- allFit(m0, parallel = 'snow',                            ncpus = nc, cl=optCls))   stopCluster(optCls) } # }"},{"path":"/reference/bootMer.html","id":null,"dir":"Reference","previous_headings":"","what":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"Perform model-based (Semi-)parametric bootstrap mixed   models.","code":""},{"path":"/reference/bootMer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"","code":"bootMer(x, FUN, nsim = 1, seed = NULL, use.u = FALSE, re.form=NA,   type = c(\"parametric\", \"semiparametric\"),   verbose = FALSE, .progress = \"none\", PBargs = list(),   parallel = c(\"no\", \"multicore\", \"snow\"),   ncpus = getOption(\"boot.ncpus\", 1L), cl = NULL)"},{"path":"/reference/bootMer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"x fitted merMod object: see     lmer, glmer, etc. FUN function taking fitted     merMod object input returning     statistic interest, must (possibly named)     numeric vector. nsim number simulations, positive integer;     bootstrap \\(B\\) (\\(R\\)). seed optional argument set.seed. use.u logical, indicating whether spherical     random effects simulated / bootstrapped     well.  TRUE, changed,     inference conditional values.     FALSE, new normal deviates drawn (see     Details). re.form formula, NA (equivalent use.u=FALSE),     NULL (equivalent use.u=TRUE):     alternative use.u     specifying random effects incorporate.     See simulate.merMod details. type character string specifying type     bootstrap, \"parametric\"     \"semiparametric\"; partial matching allowed. verbose logical indicating progress     print output .progress character string - type progress bar     display.  Default \"none\"; function     look relevant *ProgressBar function,     \"txt\" work general; \"tk\"     available tcltk package loaded;     \"win\" Windows systems. Progress bars     disabled (message) parallel operation. PBargs list additional arguments     progress bar function (package authors like     list(style=3)). parallel type parallel operation used ().     missing,     default taken option \"boot.parallel\" (    set, \"\"). ncpus integer: number processes used parallel operation:     typically one choose number available CPUs. cl optional parallel snow cluster use     parallel = \"snow\".  supplied, cluster     local machine created duration boot call.","code":""},{"path":"/reference/bootMer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"object S3 class \"boot\",   compatible boot package's   boot() result. (See Details information   retrieve information errors bootstrapping.)","code":""},{"path":"/reference/bootMer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"using parallel=\"snow\", need run   clusterEvalQ(cl,library(\"lme4\")) calling   bootMer make sure   lme4 package loaded workers; may   additionally need use clusterExport   using summary function calls objects   environment.","code":""},{"path":"/reference/bootMer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"semi-parametric variant partially implemented,   provide method lmer   glmer results. Information warning error messages incurred   bootstrap returns can retrieved via attributes bootFail number failures (errors) boot.fail.msgs error messages boot..msgs messages, warnings, error messages e.g. attr(\"boot.fail.msgs\") retrieve error messages working name bootMer()   “simulestimate()”, extension simulate   (see simulate.merMod), want emphasize potential   valid inference. use.u FALSE type     \"parametric\", simulation generates new values     “spherical” random effects \\(u\\)     ..d. errors \\(\\epsilon\\), using rnorm()     parameters corresponding fitted model x. use.u TRUE type==\"parametric\",     ..d. errors (, GLMMs, response values drawn     appropriate distributions) resampled, values     \\(u\\) staying fixed estimated values. use.u TRUE type==\"semiparametric\",     ..d. errors sampled distribution (response)     residuals.  (GLMMs, resulting     sample longer properties original     sample, method may make sense; warning generated.)     semiparametric bootstrap currently experimental feature,     therefore may stable. case use.u FALSE     type==\"semiparametric\" implemented; Morris (2002)     suggests resampling estimated values \\(u\\)     good practice.","code":""},{"path":"/reference/bootMer.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"Davison, .C. Hinkley, D.V. (1997)   Bootstrap Methods Application.   Cambridge University Press. Morris, J. S. (2002).   BLUPs ‘best’ Comes Bootstrapping.   Statistics & Probability Letters 56(4): 425–430.   doi:10.1016/S0167-7152(02)00041-X.","code":""},{"path":[]},{"path":"/reference/bootMer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Model-based (Semi-)Parametric Bootstrap for Mixed Models — bootMer","text":"","code":"if (interactive()) { fm01ML <- lmer(Yield ~ 1|Batch, Dyestuff, REML = FALSE) ## see ?\"profile-methods\" mySumm <- function(.) { s <- sigma(.)     c(beta =getME(., \"beta\"), sigma = s, sig01 = unname(s * getME(., \"theta\"))) } (t0 <- mySumm(fm01ML)) # just three parameters ## alternatively: mySumm2 <- function(.) {     c(beta=fixef(.),sigma=sigma(.), sig01=sqrt(unlist(VarCorr(.)))) }  set.seed(101) ## 3.8s (on a 5600 MIPS 64bit fast(year 2009) desktop \"AMD Phenom(tm) II X4 925\"): system.time( boo01 <- bootMer(fm01ML, mySumm, nsim = 100) )  ## to \"look\" at it if (requireNamespace(\"boot\")) {     boo01     ## note large estimated bias for sig01     ## (~30% low, decreases _slightly_ for nsim = 1000)      ## extract the bootstrapped values as a data frame ...     head(as.data.frame(boo01))      ## ------ Bootstrap-based confidence intervals ------------      ## warnings about \"Some ... intervals may be unstable\" go away     ##   for larger bootstrap samples, e.g. nsim=500      ## intercept     (bCI.1 <- boot::boot.ci(boo01, index=1, type=c(\"norm\", \"basic\", \"perc\")))# beta      ## Residual standard deviation - original scale:     (bCI.2  <- boot::boot.ci(boo01, index=2, type=c(\"norm\", \"basic\", \"perc\")))     ## Residual SD - transform to log scale:     (bCI.2L <- boot::boot.ci(boo01, index=2, type=c(\"norm\", \"basic\", \"perc\"),                        h = log, hdot = function(.) 1/., hinv = exp))      ## Among-batch variance:     (bCI.3 <- boot::boot.ci(boo01, index=3, type=c(\"norm\", \"basic\", \"perc\"))) # sig01           confint(boo01)     confint(boo01,type=\"norm\")     confint(boo01,type=\"basic\")      ## Graphical examination:     plot(boo01,index=3)      ## Check stored values from a longer (1000-replicate) run:     (load(system.file(\"testdata\",\"boo01L.RData\", package=\"lme4\")))# \"boo01L\"     plot(boo01L, index=3)     mean(boo01L$t[,\"sig01\"]==0) ## note point mass at zero! }  }"},{"path":"/reference/cake.html","id":null,"dir":"Reference","previous_headings":"","what":"Breakage Angle of Chocolate Cakes — cake","title":"Breakage Angle of Chocolate Cakes — cake","text":"Data breakage angle chocolate cakes made   three different recipes baked six different   temperatures.  split-plot design   recipes whole-units different temperatures   applied sub-units (within replicates).   experimental notes suggest replicate numbering   represents temporal ordering.","code":""},{"path":"/reference/cake.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Breakage Angle of Chocolate Cakes — cake","text":"data frame 270 observations following 5 variables. replicate factor levels 1 15 recipe factor levels , B C temperature ordered factor levels 175       < 185 < 195 < 205 < 215 < 225 angle numeric vector giving angle       cake broke. temp numeric value baking temperature (degrees F).","code":""},{"path":"/reference/cake.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Breakage Angle of Chocolate Cakes — cake","text":"Original data presented Cook (1938), reported   Cochran Cox (1957, p. 300).  Also cited Lee,   Nelder Pawitan (2006).","code":""},{"path":"/reference/cake.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Breakage Angle of Chocolate Cakes — cake","text":"replicate factor nested within   recipe factor, temperature nested   within replicate.","code":""},{"path":"/reference/cake.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Breakage Angle of Chocolate Cakes — cake","text":"Cook, F. E. (1938) Chocolate cake, . Optimum   baking temperature. Master's Thesis, Iowa State College. Cochran, W. G., Cox, G. M. (1957) Experimental   designs, 2nd Ed.  New York, John Wiley & Sons. Lee, Y., Nelder, J. ., Pawitan, Y. (2006)   Generalized linear models random effects.   Unified analysis via H-likelihood. Boca Raton, Chapman   Hall/CRC.","code":""},{"path":"/reference/cake.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Breakage Angle of Chocolate Cakes — cake","text":"","code":"str(cake) #> 'data.frame':\t270 obs. of  5 variables: #>  $ replicate  : Factor w/ 15 levels \"1\",\"2\",\"3\",\"4\",..: 1 1 1 1 1 1 1 1 1 1 ... #>  $ recipe     : Factor w/ 3 levels \"A\",\"B\",\"C\": 1 1 1 1 1 1 2 2 2 2 ... #>  $ temperature: Ord.factor w/ 6 levels \"175\"<\"185\"<\"195\"<..: 1 2 3 4 5 6 1 2 3 4 ... #>  $ angle      : int  42 46 47 39 53 42 39 46 51 49 ... #>  $ temp       : num  175 185 195 205 215 225 175 185 195 205 ... ## 'temp' is continuous, 'temperature' an ordered factor with 6 levels  (fm1 <- lmer(angle ~ recipe * temperature + (1|recipe:replicate), cake, REML= FALSE)) #> Linear mixed model fit by maximum likelihood  ['lmerMod'] #> Formula: angle ~ recipe * temperature + (1 | recipe:replicate) #>    Data: cake #>       AIC       BIC    logLik -2*log(L)  df.resid  #> 1719.0519 1791.0203 -839.5259 1679.0519       250  #> Random effects: #>  Groups           Name        Std.Dev. #>  recipe:replicate (Intercept) 6.249    #>  Residual                     4.371    #> Number of obs: 270, groups:  recipe:replicate, 45 #> Fixed Effects: #>           (Intercept)                recipeB                recipeC   #>              33.12222               -1.47778               -1.52222   #>         temperature.L          temperature.Q          temperature.C   #>               6.43033               -0.71285               -2.32551   #>         temperature^4          temperature^5  recipeB:temperature.L   #>              -3.35128               -0.15119                0.45419   #> recipeC:temperature.L  recipeB:temperature.Q  recipeC:temperature.Q   #>               0.08765               -0.23277                1.21475   #> recipeB:temperature.C  recipeC:temperature.C  recipeB:temperature^4   #>               2.69322                2.63856                3.02372   #> recipeC:temperature^4  recipeB:temperature^5  recipeC:temperature^5   #>               3.13711               -0.66354               -1.62525   (fm2 <- lmer(angle ~ recipe + temperature + (1|recipe:replicate), cake, REML= FALSE)) #> Linear mixed model fit by maximum likelihood  ['lmerMod'] #> Formula: angle ~ recipe + temperature + (1 | recipe:replicate) #>    Data: cake #>       AIC       BIC    logLik -2*log(L)  df.resid  #> 1709.5822 1745.5665 -844.7911 1689.5822       260  #> Random effects: #>  Groups           Name        Std.Dev. #>  recipe:replicate (Intercept) 6.237    #>  Residual                     4.475    #> Number of obs: 270, groups:  recipe:replicate, 45 #> Fixed Effects: #>   (Intercept)        recipeB        recipeC  temperature.L  temperature.Q   #>       33.1222        -1.4778        -1.5222         6.6109        -0.3855   #> temperature.C  temperature^4  temperature^5   #>       -0.5483        -1.2977        -0.9141   (fm3 <- lmer(angle ~ recipe + temp        + (1|recipe:replicate), cake, REML= FALSE)) #> Linear mixed model fit by maximum likelihood  ['lmerMod'] #> Formula: angle ~ recipe + temp + (1 | recipe:replicate) #>    Data: cake #>       AIC       BIC    logLik -2*log(L)  df.resid  #> 1708.1578 1729.7483 -848.0789 1696.1578       264  #> Random effects: #>  Groups           Name        Std.Dev. #>  recipe:replicate (Intercept) 6.229    #>  Residual                     4.540    #> Number of obs: 270, groups:  recipe:replicate, 45 #> Fixed Effects: #> (Intercept)      recipeB      recipeC         temp   #>       1.516       -1.478       -1.522        0.158    ## and now \"choose\" : anova(fm3, fm2, fm1) #> Data: cake #> Models: #> fm3: angle ~ recipe + temp + (1 | recipe:replicate) #> fm2: angle ~ recipe + temperature + (1 | recipe:replicate) #> fm1: angle ~ recipe * temperature + (1 | recipe:replicate) #>     npar    AIC    BIC  logLik -2*log(L)   Chisq Df Pr(>Chisq) #> fm3    6 1708.2 1729.8 -848.08    1696.2                       #> fm2   10 1709.6 1745.6 -844.79    1689.6  6.5755  4     0.1601 #> fm1   20 1719.0 1791.0 -839.53    1679.0 10.5304 10     0.3953"},{"path":"/reference/cbpp.html","id":null,"dir":"Reference","previous_headings":"","what":"Contagious bovine pleuropneumonia — cbpp","title":"Contagious bovine pleuropneumonia — cbpp","text":"Contagious bovine pleuropneumonia (CBPP) major   disease cattle Africa, caused mycoplasma.   dataset describes serological incidence CBPP   zebu cattle follow-survey implemented   15 commercial herds located Boji district   Ethiopia.  goal survey study   within-herd spread CBPP newly infected herds. Blood   samples quarterly collected animals   herds determine CBPP status.  data   used compute serological incidence CBPP   (new cases occurring given time period).    data missing (lost follow-).","code":""},{"path":"/reference/cbpp.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Contagious bovine pleuropneumonia — cbpp","text":"data frame 56 observations following 4 variables. herd factor identifying herd (1 15). incidence number new serological cases       given herd time period. size numeric vector describing herd size       beginning given time period. period factor levels 1 4.","code":""},{"path":"/reference/cbpp.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Contagious bovine pleuropneumonia — cbpp","text":"Lesnoff, M., Laval, G., Bonnet, P., Abdicho, S.,   Workalemahu, ., Kifle, D., Peyraud, ., Lancelot, R.,   Thiaucourt, F. (2004) Within-herd spread contagious   bovine pleuropneumonia Ethiopian highlands.   Preventive Veterinary Medicine 64, 27–40.","code":""},{"path":"/reference/cbpp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Contagious bovine pleuropneumonia — cbpp","text":"Serological status determined using competitive   enzyme-linked immuno-sorbent assay (cELISA).","code":""},{"path":"/reference/cbpp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Contagious bovine pleuropneumonia — cbpp","text":"","code":"## response as a matrix (m1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),              family = binomial, data = cbpp)) #> Generalized linear mixed model fit by maximum likelihood (Laplace #>   Approximation) [glmerMod] #>  Family: binomial  ( logit ) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) #>    Data: cbpp #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  194.0531  204.1799  -92.0266  184.0531        51  #> Random effects: #>  Groups Name        Std.Dev. #>  herd   (Intercept) 0.6421   #> Number of obs: 56, groups:  herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>     -1.3983      -0.9919      -1.1282      -1.5797   ## response as a vector of probabilities and usage of argument \"weights\" m1p <- glmer(incidence / size ~ period + (1 | herd), weights = size,              family = binomial, data = cbpp) ## Confirm that these are equivalent: stopifnot(all.equal(fixef(m1), fixef(m1p), tolerance = 1e-5),           all.equal(ranef(m1), ranef(m1p), tolerance = 1e-5))   ## GLMM with individual-level variability (accounting for overdispersion) cbpp$obs <- 1:nrow(cbpp) (m2 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd) +  (1|obs),               family = binomial, data = cbpp)) #> Generalized linear mixed model fit by maximum likelihood (Laplace #>   Approximation) [glmerMod] #>  Family: binomial  ( logit ) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) + (1 |   #>     obs) #>    Data: cbpp #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  186.6383  198.7904  -87.3192  174.6383        50  #> Random effects: #>  Groups Name        Std.Dev. #>  obs    (Intercept) 0.8911   #>  herd   (Intercept) 0.1840   #> Number of obs: 56, groups:  obs, 56; herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>      -1.500       -1.226       -1.329       -1.866"},{"path":"/reference/checkConv.html","id":null,"dir":"Reference","previous_headings":"","what":"Extended Convergence Checking — checkConv","title":"Extended Convergence Checking — checkConv","text":"Primarily internal code checking optimization convergence,   see convergence detailed discussion.","code":""},{"path":"/reference/checkConv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extended Convergence Checking — checkConv","text":"","code":"checkConv(derivs, coefs, ctrl, lbound, debug = FALSE)"},{"path":"/reference/checkConv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extended Convergence Checking — checkConv","text":"derivs typically \"derivs\" attribute optimizeLmer();     \"gradients\" possibly \"Hessian\" component coefs current coefficient estimates ctrl list lists, action character strings specifying     happen check triggers, tol numerical tolerances,     result lmerControl()$checkConv. lbound vector lower bounds random-effects parameters     (length taken determine number RE parameters) debug enable debugging output, useful checks     \"ignore\", \"trigger\"","code":""},{"path":"/reference/checkConv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extended Convergence Checking — checkConv","text":"result list containing code return code check messages character vector warnings messages generated check","code":""},{"path":[]},{"path":"/reference/confint.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","title":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","text":"Compute confidence intervals parameters *lmer()   model fit (class\"merMod\").","code":""},{"path":"/reference/confint.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","text":"","code":"# S3 method for class 'merMod' confint(object, parm, level = 0.95,   method = c(\"profile\", \"Wald\", \"boot\"), zeta,   nsim = 500,         boot.type = c(\"perc\",\"basic\",\"norm\"),         FUN = NULL, quiet = FALSE,   oldNames = TRUE, ...) # S3 method for class 'thpr' confint(object, parm, level = 0.95,         zeta, non.mono.tol=1e-2,   ...)"},{"path":"/reference/confint.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","text":"object fitted [ng]lmer model profile parm parameters intervals sought. Specified     integer vector positions, character vector     parameter names, (unless parametric bootstrapping     user-specified bootstrap function) \"theta_\" \"beta_\"     specify variance-covariance fixed effects parameters : see     parameter profile. level confidence level \\(< 1\\), typically 0.90. method character string determining method     computing confidence intervals. zeta (method = \"profile\" :) likelihood cutoff     (specified, default, computed level). nsim number simulations parametric bootstrap intervals. FUN bootstrap function; NULL, internal function     returns fixed-effect parameters well     random-effect parameters standard deviation/correlation scale     used. See bootMer details. boot.type bootstrap confidence interval type, described     boot.ci. (Methods ‘stud’ ‘bca’     unavailable require additional components     calculated.) quiet (logical) suppress messages computationally intensive profiling? oldNames (logical) use old-style names variance-covariance     parameters, e.g. \".sig01\", rather newer (informative) names     \"sd_(Intercept)|Subject\"? (See signames argument     profile). non.mono.tol tolerance detecting non-monotonic profile     warning/falling back linear interpolation ... additional parameters passed     profile.merMod bootMer, respectively.","code":""},{"path":"/reference/confint.merMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","text":"numeric table (matrix column row names)   confidence intervals; confidence intervals computed   standard deviation scale.","code":""},{"path":"/reference/confint.merMod.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","text":"default method \"profile\" amounts profile method profile.merMod   almost computations.  Therefore typically   advisable store profile(.) result, say   pp, use confint(pp, level=*) e.g.,   different levels.","code":"confint(profile(object, which=parm, signames=oldNames, ...),             level, zeta)"},{"path":"/reference/confint.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","text":"Depending method specified, confint() computes   confidence intervals \"profile\": computing       likelihood profile finding appropriate cutoffs       based likelihood ratio test; \"Wald\": approximating       confidence intervals (fixed-effect parameters       ; variance-covariance parameters       CIs returned NA)       based estimated local curvature       likelihood surface; \"boot\": performing parametric       bootstrapping confidence intervals computed       bootstrap distribution according boot.type (see       bootMer, boot.ci).","code":""},{"path":"/reference/confint.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compute Confidence Intervals for Parameters of a [ng]lmer Fit — confint.merMod","text":"","code":"if (interactive() || lme4_testlevel() >= 3) { fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy) fm1W <- confint(fm1, method=\"Wald\")# very fast, but not useful for \"sigmas\" = var-cov pars fm1W (fm2 <- lmer(Reaction ~ Days + (Days || Subject), sleepstudy)) (CI2 <- confint(fm2, maxpts = 8)) # method = \"profile\"; 8: to be much faster DONTSHOW({ stopifnot(all.equal(tolerance = 5e-6, signif(unname(CI2), 7),                array(c(15.25847, 3.964157, 22.88062, 237.5732,  7.33431,                        37.78184, 8.768238, 28.78768, 265.2383, 13.60057),                      dim = c(5L, 2L)))) }) if (lme4_testlevel() >= 3) {   system.time(fm1P <- confint(fm1, method=\"profile\", ## <- default                               oldNames = FALSE))   ## --> ~ 2.2 seconds (2022)   set.seed(123) # (reproducibility when using bootstrap)   system.time(fm1B <- confint(fm1, method=\"boot\", oldNames=FALSE,                               .progress=\"txt\", PBargs= list(style=3)))   ## --> ~ 6.2 seconds (2022) and warning, messages } else {     load(system.file(\"testdata\",\"confint_ex.rda\",package=\"lme4\")) } fm1P fm1B } ## if interactive && testlevel>=3"},{"path":"/reference/convergence.html","id":null,"dir":"Reference","previous_headings":"","what":"Assessing Convergence for Fitted Models — convergence","title":"Assessing Convergence for Fitted Models — convergence","text":"[g]lmer fits may produce convergence warnings;   necessarily mean fit incorrect (see   “Theoretical details” ). following steps recommended   assessing resolving convergence warnings   (also see examples ):  double-check model specification data adjust stopping (convergence) tolerances nonlinear optimizer,     using optCtrl argument [g]lmerControl     (see “Convergence controls” ) center scale continuous predictor variables (e.g. scale) double-check Hessian calculation expensive     Richardson extrapolation method (see examples) restart fit reported optimum, point     perturbed slightly away reported optimum use allFit try fit available optimizers (e.g. several different implementations     BOBYQA Nelder-Mead, L-BFGS-B optim, nlminb,     ...).  course slow large fits, consider     gold standard; optimizers converge values     practically equivalent, consider convergence     warnings false positives.","code":""},{"path":[]},{"path":"/reference/convergence.html","id":"convergence-controls","dir":"Reference","previous_headings":"","what":"Convergence controls","title":"Assessing Convergence for Fitted Models — convergence","text":"controls nloptwrap optimizer (default   lmer) ftol_abs (default 1e-6) stop small change deviance ftol_rel (default 0) stop small relative change deviance xtol_abs (default 1e-6) stop small change parameter values xtol_rel (default 0) stop small relative change \t  parameter values maxeval (default 1000) maximum number function evaluations Changing ftol_abs xtol_abs stricter values       (e.g. 1e-8) good first step resolving convergence       problems, cost slowing model fits. controls minqa::bobyqa (default       glmer first-stage optimization) rhobeg (default 2e-3) initial radius trust region rhoend (default 2e-7) final radius trust region maxfun (default 10000) maximum number function evaluations rhoend, describes scale parameter uncertainty       convergence, approximately analogous xtol_abs. controls Nelder_Mead (default       glmer second-stage optimization) FtolAbs (default 1e-5) stop small change deviance FtolRel (default 1e-15) stop small relative change deviance XtolRel (default 1e-7) stop small change parameter \t  values maxfun (default 10000) maximum number function evaluations","code":""},{"path":"/reference/convergence.html","id":"theoretical-issues","dir":"Reference","previous_headings":"","what":"Theoretical issues","title":"Assessing Convergence for Fitted Models — convergence","text":"lme4 uses general-purpose nonlinear optimizers   (e.g. Nelder-Mead Powell's BOBYQA method) estimate   variance-covariance matrices random effects.  Assessing   convergence algorithms reliably difficult.    example, evaluating   Karush-Kuhn-Tucker conditions (convergence criteria   reduce simple cases showing   gradient zero Hessian positive definite)   challenging difficulty evaluating gradient   Hessian. (lme4 authors maintainers) still process   finding best strategies testing convergence.    relevant issues gradient Hessian basic ingredients     KKT-style testing, (least now) lme4 estimates     finite-difference approximations sometimes     unreliable. Hessian computation particular represents     difficult tradeoff computational expense     accuracy.  present Hessian computations used     convergence checking (estimating standard errors     fixed-effect parameters GLMMs) follow ordinal package     using naive computationally cheap centered finite difference     computation (fixed step size \\(10^{-4}\\)).      reliable expensive approach use     Richardson extrapolation,     implemented numDeriv package. important scale estimated gradient     estimate appropriately; two reasonable approaches scale gradients inverse Cholesky factor       Hessian, equivalent scaling gradients       estimated Wald standard error       estimated parameters.  lme4 uses       approach; requires Hessian estimated (although Hessian       required \treliable estimation fixed-effect standard errors GLMMs       case). use unscaled gradients random-effects parameters,       since essentially already unitless (LMMs scaled       relative residual variance; GLMMs scaled       relative sampling variance conditional distribution);       GLMMs, scale fixed-effect gradients standard deviations       corresponding input variable Exploratory analyses suggest (1) naive estimation     Hessian may fail large data sets (number observations     greater approximately     \\(10^{5}\\)); (2) magnitude scaled     gradient increases sample size, warnings occur     even apparently well-behaved fits large data sets.","code":""},{"path":[]},{"path":"/reference/convergence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Assessing Convergence for Fitted Models — convergence","text":"","code":"if (interactive()) { fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)  ## 1. decrease stopping tolerances strict_tol <- lmerControl(optCtrl=list(xtol_abs=1e-8, ftol_abs=1e-8)) if (all(fm1@optinfo$optimizer==\"nloptwrap\")) {     fm1.tol <- update(fm1, control=strict_tol) }  ## 2. center and scale predictors: ss.CS <- transform(sleepstudy, Days=scale(Days)) fm1.CS <- update(fm1, data=ss.CS)  ## 3. recompute gradient and Hessian with Richardson extrapolation devfun <- update(fm1, devFunOnly=TRUE) if (isLMM(fm1)) {     pars <- getME(fm1,\"theta\") } else {     ## GLMM: requires both random and fixed parameters     pars <- getME(fm1, c(\"theta\",\"fixef\")) } if (require(\"numDeriv\")) {     cat(\"hess:\\n\"); print(hess <- hessian(devfun, unlist(pars)))     cat(\"grad:\\n\"); print(grad <- grad(devfun, unlist(pars)))     cat(\"scaled gradient:\\n\")     print(scgrad <- solve(chol(hess), grad)) } ## compare with internal calculations: fm1@optinfo$derivs  ## compute reciprocal condition number of Hessian H <- fm1@optinfo$derivs$Hessian Matrix::rcond(H)  ## 4. restart the fit from the original value (or ## a slightly perturbed value): fm1.restart <- update(fm1, start=pars) set.seed(101) pars_x <- runif(length(pars),pars/1.01,pars*1.01) fm1.restart2 <- update(fm1, start=pars_x,                        control=strict_tol)  ## 5. try all available optimizers    fm1.all <- allFit(fm1)   ss <- summary(fm1.all)   ss$ fixef               ## fixed effects   ss$ llik                ## log-likelihoods   ss$ sdcor               ## SDs and correlations   ss$ theta               ## Cholesky factors   ss$ which.OK            ## which fits worked  }"},{"path":"/reference/devcomp.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the deviance component list — devcomp","title":"Extract the deviance component list — devcomp","text":"Return deviance component list","code":""},{"path":"/reference/devcomp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the deviance component list — devcomp","text":"","code":"devcomp(x)"},{"path":"/reference/devcomp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the deviance component list — devcomp","text":"x fitted model class merMod","code":""},{"path":"/reference/devcomp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the deviance component list — devcomp","text":"list components dims named integer vector various dimensions cmp named numeric vector components deviance","code":""},{"path":"/reference/devcomp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract the deviance component list — devcomp","text":"fitted model class merMod   devcomp slot described value section.","code":""},{"path":"/reference/devcomp.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract the deviance component list — devcomp","text":"function deprecated, use getME(., \"devcomp\")","code":""},{"path":"/reference/devfun2.html","id":null,"dir":"Reference","previous_headings":"","what":"Deviance Function in Terms of Standard Deviations/Correlations — devfun2","title":"Deviance Function in Terms of Standard Deviations/Correlations — devfun2","text":"deviance profiled respect fixed-effects   parameters respect sigma; ,   function takes parameters variance-covariance parameters   residual standard deviation.  random-effects   variance-covariance parameters standard deviation/correlation   scale, theta (Cholesky factor) scale.","code":""},{"path":"/reference/devfun2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deviance Function in Terms of Standard Deviations/Correlations — devfun2","text":"","code":"devfun2(fm, useSc = if(isLMM(fm)) TRUE else NA,         transfuns = list(from.chol = Cv_to_Sv,                            to.chol = Sv_to_Cv,                              to.sd = identity), ...)"},{"path":"/reference/devfun2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deviance Function in Terms of Standard Deviations/Correlations — devfun2","text":"fm fitted model inheriting  class \"merMod\". useSc (logical) indicating whether scale parameter     model used.  transfuns list functions     converting parameters Cholesky-factor scale ... arguments passed internal profnames function     (signames=TRUE use old-style .sigxx names,     FALSE uses (sd_cor|xx);     also prefix=c(\"sd\",\"cor\"))","code":""},{"path":"/reference/devfun2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deviance Function in Terms of Standard Deviations/Correlations — devfun2","text":"Returns function takes vector standard deviations   correlations returns deviance (REML criterion).    function additional attributes optimum named vector giving parameter values       optimum basedev deviance optimum, (.e.,       REML criterion). thopt optimal variance-covariance parameters       “theta” (Cholesky factor) scale stderr standard errors fixed effect parameters","code":""},{"path":"/reference/devfun2.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Deviance Function in Terms of Standard Deviations/Correlations — devfun2","text":"Even original model fitted using REML=TRUE default  lmer(), returns deviance, .e., objective  function maximum (log) likelihood (ML). REML objective function, use getME(fm, \"devfun\")  instead.","code":""},{"path":"/reference/devfun2.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Deviance Function in Terms of Standard Deviations/Correlations — devfun2","text":"","code":"m1 <- lmer(Reaction~Days+(Days|Subject),sleepstudy) dd <- devfun2(m1, useSc=TRUE) pp <- attr(dd,\"optimum\") ## extract variance-covariance and residual std dev parameters sigpars <- pp[grepl(\"^\\\\.sig\",names(pp))] all.equal(unname(dd(sigpars)),deviance(refitML(m1))) #> [1] TRUE"},{"path":"/reference/drop1.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop all possible single fixed-effect terms from a mixed effect model — drop1.merMod","title":"Drop all possible single fixed-effect terms from a mixed effect model — drop1.merMod","text":"Drop allowable single terms model: see drop1   details appropriate scope dropping terms   determined.","code":""},{"path":"/reference/drop1.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop all possible single fixed-effect terms from a mixed effect model — drop1.merMod","text":"","code":"# S3 method for class 'merMod' drop1(object, scope, scale = 0,       test = c(\"none\", \"Chisq\", \"user\"),       k = 2, trace = FALSE, sumFun, ...)"},{"path":"/reference/drop1.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop all possible single fixed-effect terms from a mixed effect model — drop1.merMod","text":"object fitted merMod object. scope formula giving terms considered adding     dropping. scale Currently ignored (included S3 method compatibility) test results include test statistic relative     original model?     \\(\\chi^2\\) test likelihood-ratio test,     approximate due finite-size effects. k penalty constant AIC trace print tracing information? sumFun summary function used     test==\"user\".  must allow arguments scale     k, may ignored (e.g. swallowed ...,     see examples).     first two arguments must object, full model fit,     objectDrop, reduced model.  objectDrop missing,     sumFun(*) return vector appropriate     length names (actual contents ignored). ... arguments (ignored)","code":""},{"path":"/reference/drop1.merMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Drop all possible single fixed-effect terms from a mixed effect model — drop1.merMod","text":"object class anova summarizing differences fit   models.","code":""},{"path":"/reference/drop1.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Drop all possible single fixed-effect terms from a mixed effect model — drop1.merMod","text":"drop1 relies able find appropriate information   within environment formula original model.    formula created environment contain data,   variables passed original model (example,   separate function called define formula),   drop1 fail.  workaround (see example )   manually specify appropriate environment formula.","code":""},{"path":"/reference/drop1.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Drop all possible single fixed-effect terms from a mixed effect model — drop1.merMod","text":"","code":"fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy) ## likelihood ratio tests drop1(fm1,test=\"Chisq\") #> Single term deletions #>  #> Model: #> Reaction ~ Days + (Days | Subject) #>        npar    AIC    LRT   Pr(Chi)     #> <none>      1763.9                      #> Days      1 1785.5 23.537 1.226e-06 *** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1 ## use Kenward-Roger corrected F test, or parametric bootstrap, ## to test the significance of each dropped predictor if (require(pbkrtest) && packageVersion(\"pbkrtest\")>=\"0.3.8\") {    KRSumFun <- function(object, objectDrop, ...) {       krnames <- c(\"ndf\",\"ddf\",\"Fstat\",\"p.value\",\"F.scaling\")       r <- if (missing(objectDrop)) {           setNames(rep(NA,length(krnames)),krnames)       } else {          krtest <- KRmodcomp(object,objectDrop)          unlist(krtest$stats[krnames])       }       attr(r,\"method\") <- c(\"Kenward-Roger via pbkrtest package\")       r    }    drop1(fm1, test=\"user\", sumFun=KRSumFun)     if(lme4:::testLevel() >= 3) { ## takes about 16 sec      nsim <- 100      PBSumFun <- function(object, objectDrop, ...) {   pbnames <- c(\"stat\",\"p.value\")   r <- if (missing(objectDrop)) {       setNames(rep(NA,length(pbnames)),pbnames)   } else {      pbtest <- PBmodcomp(object,objectDrop,nsim=nsim)      unlist(pbtest$test[2,pbnames])   }   attr(r,\"method\") <- c(\"Parametric bootstrap via pbkrtest package\")   r      }      system.time(drop1(fm1, test=\"user\", sumFun=PBSumFun))    } } #> Loading required package: pbkrtest ## workaround for creating a formula in a separate environment createFormula <- function(resp, fixed, rand) {       f <- reformulate(c(fixed,rand),response=resp)     ## use the parent (createModel) environment, not the     ## environment of this function (which does not contain 'data')     environment(f) <- parent.frame()     f } createModel <- function(data) {     mf.final <- createFormula(\"Reaction\", \"Days\", \"(Days|Subject)\")     lmer(mf.final, data=data) } drop1(createModel(data=sleepstudy)) #> Single term deletions #>  #> Model: #> Reaction ~ Days + (Days | Subject) #>        npar    AIC #> <none>      1763.9 #> Days      1 1785.5"},{"path":"/reference/dummy.html","id":null,"dir":"Reference","previous_headings":"","what":"Dummy variables (experimental) — dummy","title":"Dummy variables (experimental) — dummy","text":"Largely wrapper model.matrix   accepts factor, f, returns dummy   matrix nlevels(f)-1 columns (first   column dropped default).  Useful whenever one wishes avoid   behaviour model.matrix always returning   nlevels(f)-column matrix, either   addition intercept column, keeping one   column levels.","code":""},{"path":"/reference/dummy.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dummy variables (experimental) — dummy","text":"","code":"dummy(f, levelsToKeep)"},{"path":"/reference/dummy.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dummy variables (experimental) — dummy","text":"f object coercible factor. levelsToKeep optional character vector giving subset   levels(f) converted dummy variables.","code":""},{"path":"/reference/dummy.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dummy variables (experimental) — dummy","text":"model.matrix dummy variables columns.","code":""},{"path":"/reference/dummy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dummy variables (experimental) — dummy","text":"","code":"data(Orthodont,package=\"nlme\") lmer(distance ~ age + (age|Subject) +      (0+dummy(Sex, \"Female\")|Subject), data = Orthodont) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: distance ~ age + (age | Subject) + (0 + dummy(Sex, \"Female\") |   #>     Subject) #>    Data: Orthodont #> REML criterion at convergence: 442.5444 #> Random effects: #>  Groups    Name                 Std.Dev. Corr  #>  Subject   (Intercept)          2.3439         #>            age                  0.2264   -0.66 #>  Subject.1 dummy(Sex, \"Female\") 1.0521         #>  Residual                       1.3100         #> Number of obs: 108, groups:  Subject, 27 #> Fixed Effects: #> (Intercept)          age   #>     16.8643       0.6602"},{"path":"/reference/factorize.html","id":null,"dir":"Reference","previous_headings":"","what":"Attempt to convert grouping variables to factors — factorize","title":"Attempt to convert grouping variables to factors — factorize","text":"variables within data frame factors, try   convert .  intended end-user use;   utility function needs exported, technical reasons.","code":""},{"path":"/reference/factorize.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Attempt to convert grouping variables to factors — factorize","text":"","code":"factorize(x,frloc,char.only=FALSE)"},{"path":"/reference/factorize.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Attempt to convert grouping variables to factors — factorize","text":"x formula frloc data frame char.(logical) convert character variables factors?","code":""},{"path":"/reference/factorize.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Attempt to convert grouping variables to factors — factorize","text":"copy data frame factors converted","code":""},{"path":"/reference/fixef.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract fixed-effects estimates — fixef","title":"Extract fixed-effects estimates — fixef","text":"Extract fixed-effects estimates","code":""},{"path":"/reference/fixef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract fixed-effects estimates — fixef","text":"","code":"# S3 method for class 'merMod' fixef (object, add.dropped=FALSE, ...)"},{"path":"/reference/fixef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract fixed-effects estimates — fixef","text":"object fitted model object fixed   effects estimates can extracted. add.dropped models rank-deficient design   matrix, reconstitute full-length parameter vector   adding NA values appropriate locations? ... optional additional arguments. Currently   none used methods.","code":""},{"path":"/reference/fixef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract fixed-effects estimates — fixef","text":"named, numeric vector fixed-effects estimates.","code":""},{"path":"/reference/fixef.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract fixed-effects estimates — fixef","text":"Extract estimates fixed-effects parameters   fitted model.","code":""},{"path":"/reference/fixef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract fixed-effects estimates — fixef","text":"","code":"fixef(lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy)) #> (Intercept)        Days  #>   251.40510    10.46729  fm2 <- lmer(Reaction ~ Days + Days2 + (1|Subject),             data=transform(sleepstudy,Days2=Days)) #> fixed-effect model matrix is rank deficient so dropping 1 column / coefficient fixef(fm2,add.dropped=TRUE) #> (Intercept)        Days       Days2  #>   251.40510    10.46729          NA  ## first two parameters are the same ... stopifnot(all.equal(fixef(fm2,add.dropped=TRUE)[1:2],                     fixef(fm2)))"},{"path":"/reference/fortify.html","id":null,"dir":"Reference","previous_headings":"","what":"add information to data based on a fitted model — fortify","title":"add information to data based on a fitted model — fortify","text":"fortify adds information data based fitted model;   getData retrieves data specified data   argument","code":""},{"path":"/reference/fortify.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"add information to data based on a fitted model — fortify","text":"","code":"fortify.merMod(model, data = getData(model),     ...) # S3 method for class 'merMod' getData(object)"},{"path":"/reference/fortify.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"add information to data based on a fitted model — fortify","text":"model fitted model object fitted model data original data set, needed ... additional arguments","code":""},{"path":"/reference/fortify.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"add information to data based on a fitted model — fortify","text":"fortify defined     ggplot2 package, q.v. details.     fortify defined ,     fortify.merMod defined function     rather S3 method, avoid (1) inducing     dependency ggplot2 (2) masking     methods ggplot2.     feature experimental semi-deprecated,     help page fortify says:     “Rather using function, now recommend using       broom package, implements much wider range       methods. fortify may deprecated future.”     broom.mixed package recommended mixed models     general. getData bare-bones implementation; relies     data argument specified data     available environment formula. Unlike functions     nlme package, anything special     na.action subset.","code":""},{"path":"/reference/fortify.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"add information to data based on a fitted model — fortify","text":"","code":"fm1 <- lmer(Reaction~Days+(1|Subject),sleepstudy)   names(fortify.merMod(fm1)) #> [1] \"Reaction\" \"Days\"     \"Subject\"  \".fitted\"  \".resid\"   \".scresid\""},{"path":"/reference/getME.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract or Get Generalized Components from a Fitted Mixed Effects Model — getME","title":"Extract or Get Generalized Components from a Fitted Mixed Effects Model — getME","text":"Extract (“get”) “components” –   generalized sense – fitted mixed-effects model,   .e., (version package) object   class \"merMod\".","code":""},{"path":"/reference/getME.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract or Get Generalized Components from a Fitted Mixed Effects Model — getME","text":"","code":"getME(object, name, ...)  # S3 method for class 'merMod' getME(object,       name = c(\"X\", \"Z\", \"Zt\", \"Ztlist\", \"mmList\", \"y\", \"mu\", \"u\", \"b\",                \"Gp\", \"Tp\", \"L\", \"Lambda\", \"Lambdat\", \"Lind\", \"Tlist\",                \"A\", \"RX\", \"RZX\", \"sigma\", \"flist\",                \"fixef\", \"beta\", \"theta\", \"ST\", \"REML\", \"is_REML\",                \"n_rtrms\", \"n_rfacs\", \"N\", \"n\", \"p\", \"q\",                \"p_i\", \"l_i\", \"q_i\", \"k\", \"m_i\", \"m\",                \"cnms\", \"devcomp\", \"offset\", \"lower\", \"devfun\", \"glmer.nb.theta\"),       ...)"},{"path":"/reference/getME.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract or Get Generalized Components from a Fitted Mixed Effects Model — getME","text":"object fitted mixed-effects model class     \"merMod\", .e., typically result     lmer(), glmer() nlmer(). name character vector specifying name(s)     “component”.  length(name) > 1 name     = \"\", named list components returned.  Possible values : \"X\": fixed-effects model matrix \"Z\": random-effects model matrix \"Zt\": transpose \trandom-effects model matrix.  Note structure \tZt changed since lme4.0; get \tbackward-compatible structure, use \t.call(Matrix::rBind,getME(.,\"Ztlist\")) \"Ztlist\": list components transpose \trandom-effects model matrix, separated individual \tvariance component \"mmList\": list raw model matrices associated random \teffects terms \"y\": response vector \"mu\": conditional mean response \"u\": conditional mode “spherical” \trandom effects variable \"b\": conditional mode \trandom effects variable \"Gp\": groups pointer vector. \tpointer beginning group random \teffects corresponding random-effects terms, \tbeginning 0 including final element giving \ttotal number random effects \"Tp\": theta pointer vector.  pointer beginning theta \tsub-vectors corresponding random-effects terms, \tbeginning 0 including final element giving \tnumber thetas. \"L\": sparse Cholesky factor penalized random-effects model. \"Lambda\": relative covariance factor \\(\\Lambda\\) random effects. \"Lambdat\": transpose \\(\\Lambda'\\) \\(\\Lambda\\) . \"Lind\": index vector inserting elements \t\\(\\theta\\) nonzeros \\(\\Lambda\\). \"Tlist\": vector template matrices blocks \t\\(\\Lambda\\) generated. \"\": Scaled sparse model matrix (class \t\"dgCMatrix\") \tunit, orthogonal random effects, \\(U\\), equal \tgetME(.,\"Zt\") %*% getME(.,\"Lambdat\") \"RX\": Cholesky factor fixed-effects parameters \"RZX\": cross-term full Cholesky factor \"sigma\": residual standard error; note sigma(object) preferred. \"flist\": list grouping variables (factors) \tinvolved random effect terms \"fixef\": fixed-effects parameter estimates \"beta\": fixed-effects parameter estimates (identical \tresult fixef, without names) \"theta\": random-effects parameter estimates: \tparameterized relative Cholesky factors \trandom effect term \"ST\": list S T factors TSST' Cholesky       factorization relative variance matrices random       effects associated random-effects term.  unit lower       triangular matrix, \\(T\\), diagonal matrix, \\(S\\),       term stored single matrix diagonal elements       \\(S\\) -diagonal elements \\(T\\). \"n_rtrms\": number random-effects terms \"n_rfacs\": number distinct random-effects grouping factors \"N\": number rows X \"n\": length response vector, y \"p\": number columns fixed effects model matrix, X \"q\": number columns random effects model matrix, Z \"p_i\": numbers columns raw model matrices, mmList \"l_i\": numbers levels grouping factors \"q_i\": numbers columns term-wise model matrices, ZtList \"k\": number random effects terms \"m_i\": numbers covariance parameters term \"m\": total number covariance parameters, .e., \tdims@nth . \"cnms\": “component names”, list. \"REML\": 0 indicates model fitted maximum \tlikelihood, positive integer indicates fitting \trestricted maximum likelihood \"is_REML\": result isREML(.) \"devcomp\": list consisting named numeric vector,         cmp, named integer vector, dims, describing         fitted model.  elements cmp : ldL2 twice log determinant L ldRX2 twice log determinant RX wrss weighted residual sum squares ussq squared length u pwrss penalized weighted residual sum squares,             “wrss + ussq” drsum sum residual deviance (GLMMs ) REML REML criterion optimum (LMMs fit             REML ) dev deviance criterion optimum             (models fit ML ) sigmaML ML estimate residual standard deviation sigmaREML REML estimate residual standard deviation tolPwrss tolerance declaring convergence \t  penalized iteratively weighted residual sum--squares (GLMMs ) elements dims : N number rows X n length y p number columns X nmp n-p nth length theta q number columns Z nAGQ see glmer compDev see glmerControl useSc TRUE model scale parameter reTrms number random effects terms REML 0 indicates model fitted maximum \t    likelihood, positive integer indicates fitting \t    restricted maximum likelihood GLMM TRUE GLMM NLMM TRUE NLMM  \"offset\": model offset \"lower\": lower bounds random-effects model \tparameters (.e, \"theta\" parameters). order constrain \trandom effects covariance matrices semi-positive-definite, \tvector equal 0 elements \ttheta vector corresponding diagonal elements \tCholesky factor, -Inf \totherwise. (getME(.,\"lower\")==0 can used test \tidentify diagonal elements, isSingular.) \"devfun\": deviance function (far available LMMs) \"glmer.nb.theta\": negative binomial \\(\\theta\\) parameter, \tglmer.nb. \"\": get list.  ... currently unused lme4, potentially     arguments methods.","code":""},{"path":"/reference/getME.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract or Get Generalized Components from a Fitted Mixed Effects Model — getME","text":"Unspecified, much depending name.","code":""},{"path":"/reference/getME.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract or Get Generalized Components from a Fitted Mixed Effects Model — getME","text":"goal provide “everything user may   want” fitted \"merMod\" object far   available methods,   fixef, ranef,   vcov, etc.","code":""},{"path":[]},{"path":"/reference/getME.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract or Get Generalized Components from a Fitted Mixed Effects Model — getME","text":"","code":"## shows many methods you should consider *before* using getME(): methods(class = \"merMod\") #>  [1] PBmodcomp                PBrefdist                VarCorr                  #>  [4] anova                    as.function              coef                     #>  [7] confint                  cooks.distance           deviance                 #> [10] df.residual              drop1                    extractAIC               #> [13] family                   fitted                   fixef                    #> [16] formula                  getData                  getL                     #> [19] getME                    hatvalues                influence                #> [22] isGLMM                   isLMM                    isNLMM                   #> [25] isREML                   logLik                   model.frame              #> [28] model.matrix             model2restriction_matrix ngrps                    #> [31] nobs                     plot                     predict                  #> [34] print                    profile                  qqmath                   #> [37] ranef                    rePCA                    refit                    #> [40] refitML                  residuals                rstudent                 #> [43] show                     sigma                    simulate                 #> [46] summary                  terms                    update                   #> [49] vcov                     weights                  #> see '?methods' for accessing help and source code  (fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy #> REML criterion at convergence: 1743.628 #> Random effects: #>  Groups   Name        Std.Dev. Corr #>  Subject  (Intercept) 24.741        #>           Days         5.922   0.07 #>  Residual             25.592        #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      251.41        10.47   Z <- getME(fm1, \"Z\") stopifnot(is(Z, \"CsparseMatrix\"),           c(180,36) == dim(Z),     all.equal(fixef(fm1), b1 <- getME(fm1, \"beta\"),         check.attributes=FALSE, tolerance = 0))  ## A way to get *all* getME()s : ## internal consistency check ensuring that all work: parts <- getME(fm1, \"ALL\") str(parts, max=2) #> List of 45 #>  $ X             : num [1:180, 1:2] 1 1 1 1 1 1 1 1 1 1 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   ..- attr(*, \"assign\")= int [1:2] 0 1 #>   ..- attr(*, \"msgScaleX\")= chr(0)  #>  $ Z             :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>  $ Zt            :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>  $ Ztlist        :List of 2 #>   ..$ Subject.(Intercept):Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   ..$ Subject.Days       :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>  $ mmList        :List of 1 #>   ..$ Days | Subject: num [1:180, 1:2] 1 1 1 1 1 1 1 1 1 1 ... #>   .. ..- attr(*, \"dimnames\")=List of 2 #>   .. ..- attr(*, \"assign\")= int [1:2] 0 1 #>  $ y             : num [1:180] 250 259 251 321 357 ... #>  $ mu            : num [1:180] 254 273 293 313 332 ... #>  $ u             : num [1:36] 2.34 39.68 -41.79 -34.58 -40.3 ... #>  $ b             :Formal class 'dgeMatrix' [package \"Matrix\"] with 4 slots #>  $ Gp            : int [1:2] 0 36 #>  $ Tp            : Named num [1:2] 0 3 #>   ..- attr(*, \"names\")= chr [1:2] \"beg__\" \"Subject\" #>  $ L             :Formal class 'dCHMsimpl' [package \"Matrix\"] with 11 slots #>  $ Lambda        :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>  $ Lambdat       :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>  $ Lind          : int [1:54] 1 2 3 1 2 3 1 2 3 1 ... #>  $ Tlist         :List of 1 #>   ..$ Subject: num [1:2, 1:2] 0.9667 0.0152 0 0.2309 #>  $ A             :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>  $ RX            : num [1:2, 1:2] 3.79 0 2.3 16.56 #>   ..- attr(*, \"dimnames\")=List of 2 #>  $ RZX           : num [1:36, 1:2] 3.022 0.269 3.022 0.269 3.022 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>  $ sigma         : num 25.6 #>  $ flist         :List of 1 #>   ..$ Subject: Factor w/ 18 levels \"308\",\"309\",\"310\",..: 1 1 1 1 1 1 1 1 1 1 ... #>   ..- attr(*, \"assign\")= int 1 #>  $ fixef         : Named num [1:2] 251.4 10.5 #>   ..- attr(*, \"names\")= chr [1:2] \"(Intercept)\" \"Days\" #>  $ beta          : num [1:2] 251.4 10.5 #>  $ theta         : Named num [1:3] 0.9667 0.0152 0.2309 #>   ..- attr(*, \"names\")= chr [1:3] \"Subject.(Intercept)\" \"Subject.Days.(Intercept)\" \"Subject.Days\" #>  $ ST            :List of 1 #>   ..$ Subject: num [1:2, 1:2] 0.9667 0.0157 0 0.2309 #>  $ REML          : int 2 #>  $ is_REML       : logi TRUE #>  $ n_rtrms       : int 1 #>  $ n_rfacs       : int 1 #>  $ N             : int 180 #>  $ n             : int 180 #>  $ p             : int 2 #>  $ q             : int 36 #>  $ p_i           : Named int 2 #>   ..- attr(*, \"names\")= chr \"Days | Subject\" #>  $ l_i           : Named int 18 #>   ..- attr(*, \"names\")= chr \"Subject\" #>  $ q_i           : Named int 36 #>   ..- attr(*, \"names\")= chr \"Days | Subject\" #>  $ k             : int 1 #>  $ m_i           : Named num 3 #>   ..- attr(*, \"names\")= chr \"Days | Subject\" #>  $ m             : int 3 #>  $ cnms          :List of 1 #>   ..$ Subject: chr [1:2] \"(Intercept)\" \"Days\" #>  $ devcomp       :List of 2 #>   ..$ cmp : Named num [1:10] 7.60e+01 8.28 9.89e+04 1.77e+04 1.17e+05 ... #>   .. ..- attr(*, \"names\")= chr [1:10] \"ldL2\" \"ldRX2\" \"wrss\" \"ussq\" ... #>   ..$ dims: Named int [1:12] 180 180 2 178 36 3 1 1 0 2 ... #>   .. ..- attr(*, \"names\")= chr [1:12] \"N\" \"n\" \"p\" \"nmp\" ... #>  $ offset        : num [1:180] 0 0 0 0 0 0 0 0 0 0 ... #>  $ lower         : Named num [1:3] 0 -Inf 0 #>   ..- attr(*, \"names\")= chr [1:3] \"Subject.(Intercept)\" \"Subject.Days.(Intercept)\" \"Subject.Days\" #>  $ devfun        :function (theta)   #>  $ glmer.nb.theta: logi NA stopifnot(identical(Z,  parts $ Z),           identical(b1, parts $ beta))"},{"path":"/reference/glmFamily-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"class wrapper class family   objects specifying distibution family link function   generalized linear model (glm).    reference class contains external pointer C++   object representing class.  common families   link functions functions family   implemented compiled code can accessed   compiled code speed boost.","code":""},{"path":"/reference/glmFamily-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class ","text":"Objects reference class correspond objects   C++ class.  Methods invoked C++ class   using external pointer Ptr field.    saving object external pointer converted   null pointer, redundant   field ptr active-binding function   returning external pointer.  Ptr field   null pointer, external pointer regenerated   stored family field.","code":""},{"path":"/reference/glmFamily-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Class ","text":"reference classes extend inherit methods   \"envRefClass\".","code":""},{"path":[]},{"path":"/reference/glmFamily-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"str(glmFamily$new(family=poisson())) #> Reference class 'glmFamily' [package \"lme4\"] with 2 fields #>  $ Ptr   :<externalptr>  #>  $ family:List of 13 #>   ..$ family    : chr \"poisson\" #>   ..$ link      : chr \"log\" #>   ..$ linkfun   :function (mu)   #>   ..$ linkinv   :function (eta)   #>   ..$ variance  :function (mu)   #>   ..$ dev.resids:function (y, mu, wt)   #>   ..$ aic       :function (y, n, mu, wt, dev)   #>   ..$ mu.eta    :function (eta)   #>   ..$ initialize:  expression({  if (any(y < 0))  stop(\"negative values not allowed for the 'Poisson' family\")  n <- rep.int(1, nobs| __truncated__ #>   ..$ validmu   :function (mu)   #>   ..$ valideta  :function (eta)   #>   ..$ simulate  :function (object, nsim)   #>   ..$ dispersion: num 1 #>   ..- attr(*, \"class\")= chr \"family\" #>  and 23 methods, of which 9 are  possibly relevant: #>    aic, devResid, link, linkInv, muEta, ptr, setTheta, theta, variance"},{"path":"/reference/glmFamily.html","id":null,"dir":"Reference","previous_headings":"","what":"Generator object for the glmFamily class — glmFamily","title":"Generator object for the glmFamily class — glmFamily","text":"generator object   glmFamily reference class.   object primarily used new method.","code":""},{"path":"/reference/glmFamily.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generator object for the glmFamily class — glmFamily","text":"","code":"glmFamily(...)"},{"path":"/reference/glmFamily.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generator object for the glmFamily class — glmFamily","text":"... Named argument (see Note )","code":""},{"path":"/reference/glmFamily.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generator object for the glmFamily class — glmFamily","text":"Arguments new method must named   arguments.","code":""},{"path":"/reference/glmFamily.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Generator object for the glmFamily class — glmFamily","text":"new(family=family) Create new   glmFamily object","code":""},{"path":[]},{"path":"/reference/glmer.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting Generalized Linear Mixed-Effects Models — glmer","title":"Fitting Generalized Linear Mixed-Effects Models — glmer","text":"Fit generalized linear mixed-effects model (GLMM).  fixed   effects random effects specified via model formula.","code":""},{"path":"/reference/glmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting Generalized Linear Mixed-Effects Models — glmer","text":"","code":"glmer(formula, data = NULL, family = gaussian     , control = glmerControl()     , start = NULL     , verbose = 0L     , nAGQ = 1L     , subset, weights, na.action, offset, contrasts = NULL     , mustart, etastart     , devFunOnly = FALSE)"},{"path":"/reference/glmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting Generalized Linear Mixed-Effects Models — glmer","text":"formula two-sided linear formula object describing     fixed-effects random-effects part model, response     left ~ operator terms, separated     + operators, right.  Random-effects terms     distinguished vertical bars (\"|\") separating expressions     design matrices grouping factors. data optional data frame containing variables named     formula.  default variables taken     environment lmer called.  data     optional, package authors strongly recommend use,     especially later applying methods update     drop1 fitted model (methods     guaranteed work properly data omitted).      data omitted, variables taken environment     formula (specified formula) parent     frame (specified character vector). family GLM family, see glm     family. control list (correct class, resulting     lmerControl() glmerControl()     respectively) containing control parameters, including nonlinear     optimizer used parameters passed     nonlinear optimizer, see *lmerControl documentation     details. start named list starting values parameters     model, numeric vector.  numeric start argument     used starting value theta.  start     list, theta element (numeric vector) used     starting value first optimization step (default=1     diagonal elements 0 -diagonal elements lower     Cholesky factor); fitted value theta first     step, plus start[[\"fixef\"]], used starting values     second optimization step.  start fixef     theta elements, first optimization step skipped.     details finer control optimization, see     modular. verbose integer scalar.  > 0 verbose output     generated optimization parameter estimates.      > 1 verbose output generated individual     penalized iteratively reweighted least squares (PIRLS) steps. nAGQ integer scalar - number points per axis     evaluating adaptive Gauss-Hermite approximation     log-likelihood.  Defaults 1, corresponding Laplace     approximation.  Values greater 1 produce greater accuracy     evaluation log-likelihood expense speed.      value zero uses faster less exact form parameter     estimation GLMMs optimizing random effects     fixed-effects coefficients penalized iteratively reweighted     least squares step. (See Details.) subset optional expression indicating subset rows     data used fit. can logical     vector, numeric vector indicating observation numbers     included, character vector row names     included.  observations included default. weights optional vector ‘prior weights’ used       fitting process.  NULL numeric       vector. na.action function indicates happen     data contain NAs.  default action (na.omit,     inherited ‘factory fresh’ value     getOption(\"na.action\")) strips observations     missing values variables. offset can used specify priori known     component included linear predictor     fitting. NULL numeric vector length     equal number cases.  One offset     terms can included formula instead well,     one specified sum used.  See model.offset. contrasts optional list.  See contrasts.arg     model.matrix.default. mustart optional starting values scale     conditional mean, glm; see     details. etastart optional starting values scale unbounded     predictor glm; see details. devFunOnly logical - return deviance evaluation     function. Note deviance function operates     variables stored environment, may return     exactly values subsequent calls (results     always within machine tolerance).","code":""},{"path":"/reference/glmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting Generalized Linear Mixed-Effects Models — glmer","text":"object class merMod (specifically,   object subclass glmerMod) many   methods available (e.g. methods(class=\"merMod\"))","code":""},{"path":"/reference/glmer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fitting Generalized Linear Mixed-Effects Models — glmer","text":"earlier version lme4 package, method argument   used.  functionality replaced nAGQ argument.","code":""},{"path":"/reference/glmer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting Generalized Linear Mixed-Effects Models — glmer","text":"Fit generalized linear mixed model, incorporates   fixed-effects parameters random effects linear predictor, via   maximum likelihood.  linear predictor related   conditional mean response inverse link function   defined GLM family. expression likelihood mixed-effects model   integral random effects space.  linear mixed-effects   model (LMM), fit lmer, integral can   evaluated exactly.  GLMM integral must approximated.    reliable approximation GLMMs   adaptive Gauss-Hermite quadrature,   present implemented models   single scalar random effect.    nAGQ argument controls number nodes quadrature   formula.  model single, scalar random-effects term   reasonably use 25 quadrature points per scalar integral.","code":""},{"path":[]},{"path":"/reference/glmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting Generalized Linear Mixed-Effects Models — glmer","text":"","code":"## generalized linear mixed model library(lattice) xyplot(incidence/size ~ period|herd, cbpp, type=c('g','p','l'),        layout=c(3,5), index.cond = function(x,y)max(y))  (gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),               data = cbpp, family = binomial)) #> Generalized linear mixed model fit by maximum likelihood (Laplace #>   Approximation) [glmerMod] #>  Family: binomial  ( logit ) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) #>    Data: cbpp #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  194.0531  204.1799  -92.0266  184.0531        51  #> Random effects: #>  Groups Name        Std.Dev. #>  herd   (Intercept) 0.6421   #> Number of obs: 56, groups:  herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>     -1.3983      -0.9919      -1.1282      -1.5797   ## using nAGQ=0 only gets close to the optimum (gm1a <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),                cbpp, binomial, nAGQ = 0)) #> Generalized linear mixed model fit by maximum likelihood (Adaptive #>   Gauss-Hermite Quadrature, nAGQ = 0) [glmerMod] #>  Family: binomial  ( logit ) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) #>    Data: cbpp #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  194.1087  204.2355  -92.0543  184.1087        51  #> Random effects: #>  Groups Name        Std.Dev. #>  herd   (Intercept) 0.6418   #> Number of obs: 56, groups:  herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>     -1.3605      -0.9762      -1.1111      -1.5597   ## using  nAGQ = 9  provides a better evaluation of the deviance ## Currently the internal calculations use the sum of deviance residuals, ## which is not directly comparable with the nAGQ=0 or nAGQ=1 result. ## 'verbose = 1' monitors iteratin a bit; (verbose = 2 does more): (gm1a <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),                cbpp, binomial, verbose = 1, nAGQ = 9)) #> start par. =  1 fn =  186.7231  #> At return #> eval:  18 fn:      184.10869 par: 0.641839 #> (NM) 20: f = 100.035 at   0.65834  -1.40366 -0.973379  -1.12553  -1.51926 #> (NM) 40: f = 100.012 at  0.650182  -1.39827 -0.993156  -1.11768  -1.57305 #> (NM) 60: f = 100.011 at  0.649102  -1.39735 -0.999034  -1.13415  -1.57634 #> (NM) 80: f = 100.01 at  0.647402  -1.39987 -0.987353  -1.12767  -1.57516 #> (NM) 100: f = 100.01 at   0.64823      -1.4 -0.991134  -1.12755  -1.58048 #> (NM) 120: f = 100.01 at  0.647543  -1.39916 -0.991869  -1.12839  -1.57993 #> (NM) 140: f = 100.01 at  0.647452  -1.39935 -0.991366  -1.12764  -1.57936 #> (NM) 160: f = 100.01 at  0.647519  -1.39925 -0.991348  -1.12784  -1.57948 #> (NM) 180: f = 100.01 at  0.647513  -1.39924 -0.991381  -1.12783  -1.57947 #> Generalized linear mixed model fit by maximum likelihood (Adaptive #>   Gauss-Hermite Quadrature, nAGQ = 9) [glmerMod] #>  Family: binomial  ( logit ) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) #>    Data: cbpp #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  110.0100  120.1368  -50.0050  100.0100        51  #> Random effects: #>  Groups Name        Std.Dev. #>  herd   (Intercept) 0.6475   #> Number of obs: 56, groups:  herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>     -1.3992      -0.9914      -1.1278      -1.5795    ## GLMM with individual-level variability (accounting for overdispersion) ## For this data set the model is the same as one allowing for a period:herd ## interaction, which the plot indicates could be needed. cbpp$obs <- 1:nrow(cbpp) (gm2 <- glmer(cbind(incidence, size - incidence) ~ period +     (1 | herd) +  (1|obs),               family = binomial, data = cbpp)) #> Generalized linear mixed model fit by maximum likelihood (Laplace #>   Approximation) [glmerMod] #>  Family: binomial  ( logit ) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) + (1 |   #>     obs) #>    Data: cbpp #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  186.6383  198.7904  -87.3192  174.6383        50  #> Random effects: #>  Groups Name        Std.Dev. #>  obs    (Intercept) 0.8911   #>  herd   (Intercept) 0.1840   #> Number of obs: 56, groups:  obs, 56; herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>      -1.500       -1.226       -1.329       -1.866   anova(gm1,gm2) #> Data: cbpp #> Models: #> gm1: cbind(incidence, size - incidence) ~ period + (1 | herd) #> gm2: cbind(incidence, size - incidence) ~ period + (1 | herd) + (1 | obs) #>     npar    AIC    BIC  logLik -2*log(L)  Chisq Df Pr(>Chisq)    #> gm1    5 194.05 204.18 -92.027    184.05                         #> gm2    6 186.64 198.79 -87.319    174.64 9.4148  1   0.002152 ** #> --- #> Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1  ## glmer and glm log-likelihoods are consistent gm1Devfun <- update(gm1,devFunOnly=TRUE) gm0 <- glm(cbind(incidence, size - incidence) ~ period,            family = binomial, data = cbpp) ## evaluate GLMM deviance at RE variance=theta=0, beta=(GLM coeffs) gm1Dev0 <- gm1Devfun(c(0,coef(gm0))) ## compare stopifnot(all.equal(gm1Dev0,c(-2*logLik(gm0)))) ## the toenail oncholysis data from Backer et al 1998 ## these data are notoriously difficult to fit if (FALSE) { # \\dontrun{ if (require(\"HSAUR3\")) {     gm2 <- glmer(outcome~treatment*visit+(1|patientID),                  data=toenail,                  family=binomial,nAGQ=20) } } # }"},{"path":"/reference/glmer.nb.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting Negative Binomial GLMMs — glmer.nb","title":"Fitting Negative Binomial GLMMs — glmer.nb","text":"Fits generalized linear mixed-effects model (GLMM) negative   binomial family, building glmer, initializing via   theta.ml MASS.","code":""},{"path":"/reference/glmer.nb.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting Negative Binomial GLMMs — glmer.nb","text":"","code":"glmer.nb(..., interval = log(th) + c(-3, 3),          tol = 5e-5, verbose = FALSE, nb.control = NULL,          initCtrl = list(limit = 20, eps = 2*tol, trace = verbose,                          theta = NULL))"},{"path":"/reference/glmer.nb.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting Negative Binomial GLMMs — glmer.nb","text":"... arguments glmer(.) formula,     data, control, etc, family! interval interval start optimization.      default symmetric log scale around initially estimated theta. tol tolerance optimization via optimize. verbose logical indicating much     progress information printed optimization.  Use     verbose = 2 (larger) enable verbose=TRUE     glmer() calls. nb.control optional list, like output glmerControl(),     used refit(*, control = control.nb)     optimization (control, included ...,     used initial-stage glmer(...,family=poisson)     fit, passed later optimization stages well) initCtrl (experimental, rely :)     list named components default, passed     theta.ml (package MASS) initial     value negative binomial parameter theta.     May also include theta component, case     initial estimation step skipped","code":""},{"path":"/reference/glmer.nb.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fitting Negative Binomial GLMMs — glmer.nb","text":"object class glmerMod, many   methods available (e.g. methods(class=\"glmerMod\")), see   glmer.","code":""},{"path":"/reference/glmer.nb.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fitting Negative Binomial GLMMs — glmer.nb","text":"historical reasons, shape parameter negative   binomial random effects parameters (G)LMM models   called theta (\\(\\theta\\)), unrelated . negative binomial \\(\\theta\\) can extracted fit   g <- glmer.nb() getME(g, \"glmer.nb.theta\"). Parts glmer.nb() still experimental methods   still missing suboptimal.  particular, inference   available dispersion parameter \\(\\theta\\), yet. fit negative binomial model known overdispersion   parameter (e.g. part model comparison exercise, use   glmer negative.binomial family   MASS package, e.g.   glmer(...,family=MASS::negative.binomial(theta=1.75)).","code":""},{"path":[]},{"path":"/reference/glmer.nb.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting Negative Binomial GLMMs — glmer.nb","text":"","code":"set.seed(101) dd <- expand.grid(f1 = factor(1:3),                   f2 = LETTERS[1:2], g=1:9, rep=1:15,           KEEP.OUT.ATTRS=FALSE) summary(mu <- 5*(-4 + with(dd, as.integer(f1) + 4*as.numeric(f2)))) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>       5      10      20      20      30      35  dd$y <- rnbinom(nrow(dd), mu = mu, size = 0.5) str(dd) #> 'data.frame':\t810 obs. of  5 variables: #>  $ f1 : Factor w/ 3 levels \"1\",\"2\",\"3\": 1 2 3 1 2 3 1 2 3 1 ... #>  $ f2 : Factor w/ 2 levels \"A\",\"B\": 1 1 1 2 2 2 1 1 1 2 ... #>  $ g  : int  1 1 1 1 1 1 2 2 2 2 ... #>  $ rep: int  1 1 1 1 1 1 1 1 1 1 ... #>  $ y  : num  3 16 31 6 51 14 19 31 0 15 ... require(\"MASS\")## and use its glm.nb() - as indeed we have zero random effect: #> Loading required package: MASS if (FALSE) { # \\dontrun{ m.glm <- glm.nb(y ~ f1*f2, data=dd, trace=TRUE) summary(m.glm) m.nb <- glmer.nb(y ~ f1*f2 + (1|g), data=dd, verbose=TRUE) m.nb ## The neg.binomial theta parameter: getME(m.nb, \"glmer.nb.theta\") LL <- logLik(m.nb) ## mixed model has 1 additional parameter (RE variance) stopifnot(attr(LL,\"df\")==attr(logLik(m.glm),\"df\")+1) plot(m.nb, resid(.) ~ g)# works, as long as data 'dd' is found } # }"},{"path":"/reference/glmerLaplaceHandle.html","id":null,"dir":"Reference","previous_headings":"","what":"Handle for glmerLaplace — glmerLaplaceHandle","title":"Handle for glmerLaplace — glmerLaplaceHandle","text":"Handle calling glmerLaplace C++ function.    intended routine use.","code":""},{"path":"/reference/glmerLaplaceHandle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Handle for glmerLaplace — glmerLaplaceHandle","text":"","code":"glmerLaplaceHandle(pp, resp, nAGQ, tol, maxit, verbose)"},{"path":"/reference/glmerLaplaceHandle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Handle for glmerLaplace — glmerLaplaceHandle","text":"pp merPredD object resp lmResp object nAGQ see glmer tol tolerance maxit maximum number pwrss iterations verbose display optimizer progress","code":""},{"path":"/reference/glmerLaplaceHandle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Handle for glmerLaplace — glmerLaplaceHandle","text":"Value objective function","code":""},{"path":"/reference/golden-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"\"golden\" reference class golden search scalar optimizer,   parameter within interval. golden() generator \"golden\"   class.  optimizer uses reverse communications.","code":""},{"path":"/reference/golden-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class ","text":"","code":"golden(...)"},{"path":"/reference/golden-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class ","text":"... (partly optional) arguments passed     new() must named arguments.  lower     upper bounds scalar parameter; must     finite.","code":""},{"path":"/reference/golden-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Class ","text":"reference classes extend inherit methods   \"envRefClass\".","code":""},{"path":"/reference/golden-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"showClass(\"golden\") #> Class \"golden\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"envRefClass\", directly #> Class \".environment\", by class \"envRefClass\", distance 2 #> Class \"refClass\", by class \"envRefClass\", distance 2 #> Class \"environment\", by class \"envRefClass\", distance 3, with explicit coerce #> Class \"refObject\", by class \"envRefClass\", distance 3  golden(lower= -100, upper= 1e100) #> Reference class object of class \"golden\" #> Field \"Ptr\": #> <pointer: 0x55f09fadfc30> #> Field \"lowerbd\": #> [1] -100 #> Field \"upperbd\": #> [1] 1e+100"},{"path":"/reference/grouseticks.html","id":null,"dir":"Reference","previous_headings":"","what":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","title":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","text":"Number ticks heads red grouse chicks   sampled field (grouseticks)   aggregated version (grouseticks_agg); see original source details","code":""},{"path":"/reference/grouseticks.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","text":"","code":"data(grouseticks)"},{"path":"/reference/grouseticks.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","text":"INDEX (factor) chick number (observation level) TICKS number ticks sampled BROOD (factor) brood number HEIGHT height sea level (meters) YEAR year (-1900) LOCATION (factor) geographic location code cHEIGHT centered height, derived HEIGHT meanTICKS mean number ticks brood varTICKS variance number ticks brood","code":""},{"path":"/reference/grouseticks.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","text":"Robert Moss, via David Elston","code":""},{"path":"/reference/grouseticks.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","text":"grouseticks_agg just brood-level   aggregation data","code":""},{"path":"/reference/grouseticks.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","text":"Elston, D. ., R. Moss, T. Boulinier, C. Arrowsmith, X. Lambin. 2001. \"Analysis Aggregation, Worked Example: Numbers Ticks Red Grouse Chicks.\" Parasitology 122 (05): 563-569. doi:10.1017/S0031182001007740","code":""},{"path":"/reference/grouseticks.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data on red grouse ticks from Elston et al. 2001 — grouseticks","text":"","code":"if (interactive()) { data(grouseticks) ## Figure 1a from Elston et al par(las=1,bty=\"l\") tvec <- c(0,1,2,5,20,40,80) pvec <- c(4,1,3) with(grouseticks_agg,plot(1+meanTICKS~HEIGHT,                   pch=pvec[factor(YEAR)],                   log=\"y\",axes=FALSE,                   xlab=\"Altitude (m)\",                   ylab=\"Brood mean ticks\")) axis(side=1) axis(side=2,at=tvec+1,label=tvec) box() abline(v=405,lty=2) ## Figure 1b with(grouseticks_agg,plot(varTICKS~meanTICKS,                   pch=4,                   xlab=\"Brood mean ticks\",                   ylab=\"Within-brood variance\")) curve(1*x,from=0,to=70,add=TRUE) ## Model fitting form <- TICKS~YEAR+HEIGHT+(1|BROOD)+(1|INDEX)+(1|LOCATION) (full_mod1  <- glmer(form, family=\"poisson\",data=grouseticks)) }"},{"path":"/reference/hatvalues.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagonal elements of the hat matrix — hatvalues.merMod","title":"Diagonal elements of the hat matrix — hatvalues.merMod","text":"Returns values diagonal hat matrix,   matrix transforms response vector (minus offset)   fitted values (minus offset).  Note method   used linear mixed models.  clear hat matrix   concept even makes sense generalized linear mixed models.","code":""},{"path":"/reference/hatvalues.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagonal elements of the hat matrix — hatvalues.merMod","text":"","code":"# S3 method for class 'merMod' hatvalues (model, fullHatMatrix = FALSE, ...)"},{"path":"/reference/hatvalues.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagonal elements of the hat matrix — hatvalues.merMod","text":"model object class merMod. fullHatMatrix Return full hat matrix (just diagonal values)? ... currently used","code":""},{"path":"/reference/hatvalues.merMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Diagonal elements of the hat matrix — hatvalues.merMod","text":"diagonal elements hat matrix.","code":""},{"path":"/reference/hatvalues.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagonal elements of the hat matrix — hatvalues.merMod","text":"","code":"m <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy) hatvalues(m) #>          1          2          3          4          5          6          7  #> 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625  #>          8          9         10         11         12         13         14  #> 0.16230880 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520  #>         15         16         17         18         19         20         21  #> 0.09101445 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719 0.22930404  #>         22         23         24         25         26         27         28  #> 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625 0.16230880  #>         29         30         31         32         33         34         35  #> 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445  #>         36         37         38         39         40         41         42  #> 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719 0.22930404 0.16972999  #>         43         44         45         46         47         48         49  #> 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625 0.16230880 0.21940911  #>         50         51         52         53         54         55         56  #> 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147  #>         57         58         59         60         61         62         63  #> 0.12187625 0.16230880 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372  #>         64         65         66         67         68         69         70  #> 0.10058520 0.09101445 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719  #>         71         72         73         74         75         76         77  #> 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625  #>         78         79         80         81         82         83         84  #> 0.16230880 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520  #>         85         86         87         88         89         90         91  #> 0.09101445 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719 0.22930404  #>         92         93         94         95         96         97         98  #> 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625 0.16230880  #>         99        100        101        102        103        104        105  #> 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445  #>        106        107        108        109        110        111        112  #> 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719 0.22930404 0.16972999  #>        113        114        115        116        117        118        119  #> 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625 0.16230880 0.21940911  #>        120        121        122        123        124        125        126  #> 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147  #>        127        128        129        130        131        132        133  #> 0.12187625 0.16230880 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372  #>        134        135        136        137        138        139        140  #> 0.10058520 0.09101445 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719  #>        141        142        143        144        145        146        147  #> 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625  #>        148        149        150        151        152        153        154  #> 0.16230880 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520  #>        155        156        157        158        159        160        161  #> 0.09101445 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719 0.22930404  #>        162        163        164        165        166        167        168  #> 0.16972999 0.12682372 0.10058520 0.09101445 0.09811147 0.12187625 0.16230880  #>        169        170        171        172        173        174        175  #> 0.21940911 0.29317719 0.22930404 0.16972999 0.12682372 0.10058520 0.09101445  #>        176        177        178        179        180  #> 0.09811147 0.12187625 0.16230880 0.21940911 0.29317719"},{"path":"/reference/influence.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"functions compute deletion influence diagnostics linear   (fit lmer) generalized linear mixed-effects models   (fit glmer).  main functions methods   influence generic function.  functions   provided computing dfbeta, dfbetas,   cooks.distance, influence variance-covariance   components based objects computed influence.merMod","code":""},{"path":"/reference/influence.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"","code":"# S3 method for class 'merMod' influence(model, groups, data, maxfun = 1000,           do.coef = TRUE, ncores = getOption(\"mc.cores\",1), start, ...) # S3 method for class 'influence.merMod' cooks.distance(model, ...) # S3 method for class 'influence.merMod' dfbeta(model, which = c(\"fixed\", \"var.cov\"), ...) # S3 method for class 'influence.merMod' dfbetas(model, ...)"},{"path":"/reference/influence.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"model case influence.merMod, model class \"merMod\";     case cooks.distance, dfbeta, dfbetas,     object returned influence.merMod groups character vector containing name grouping factor names grouping factors; one name     supplied, groups defined combinations levels grouping factors appear     data. omitted, individual row data matrix treated \"group\" deleted turn. data optional data frame data model     fit; influence.merMod can usually retrieve data used     fit model, unless found current environment, usually unnecessary supply argument. maxfun maximum number function evaluations (influence.merMod)     perform deleting group; defaults large enough iterations typically continue convergence.     Setting maxfun=20 lmer model 100 glmer model typically produce faster reasonable approximation.     even smaller value can used interest influence fixed effects. \"fixed.effects\" (default), return influence     fixed effects; \"var.cov\", return influence     variance-covariance components. .coef FALSE, skip potentially time-consuming     computations, returning just list containing hat values. ncores number computational cores use run parallel;     directly passed makeCluster() R's     parallel package. start starting value new fits (set optimal values     original fit default) ... ignored.","code":""},{"path":"/reference/influence.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"influence.merMod start estimated variance-covariance components model refit model omitting group turn, necessarily iterating completion. example, maxfun=20 takes 20 function evaluations step away ML REML solution full data, usually provides decent approximations fully iterated estimates. functions methods dfbeta, dfbetas, cooks.distance generics, applied \"influence.merMod\" object produced influence function; dfbeta methods can also return influence variance-covariance components.","code":""},{"path":"/reference/influence.merMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"influence.merMod returns objects class   \"influence.merMod\", contain following elements: \"fixed.effects\" estimated fixed effects model. \"fixed.effects[-groups]\" matrix columns corresponding fixed-effects coefficients rows corresponding groups, giving     estimated fixed effects group deleted turn; groups formed name(s) grouping factor(s). \"var.cov.comps\" estimated variance-covariance parameters model. \"var.cov.comps[-groups]\" matrix estimated covariance parameters (columns) group deleted turn. \"vcov\" estimated covariance matrix fixed-effects coefficients. \"vcov[-groups]\" list whose elements estimated covariance matrix fixed-effects coefficients one group deleted. \"groups\" character vector giving names grouping factors. \"deleted\" possibly composite grouping factor, whose elements deleted turn. \"converged\" influence.merMod, logical vector indicating whether computation converged group. \"function.evals\" influence.merMod, vector number function evaluations performed group. plotting \"influence.merMod\" objects, see infIndexPlot.","code":""},{"path":"/reference/influence.merMod.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"Fox, J. Weisberg, S. (2019)   R Companion Applied Regression, Third Edition, Sage.","code":""},{"path":"/reference/influence.merMod.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"J. Fox jfox@mcmaster.ca","code":""},{"path":[]},{"path":"/reference/influence.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Influence Diagnostics for Mixed-Effects Models — influence.merMod","text":"","code":"if (interactive()) {   fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)   inf_fm1 <- influence(fm1, \"Subject\")   if (require(\"car\")) {     infIndexPlot(inf_fm1)   }   dfbeta(inf_fm1)   dfbetas(inf_fm1)   gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),                data = cbpp, family = binomial)   inf_gm1 <- influence(gm1, \"herd\", maxfun=100)   gm1.11 <- update(gm1, subset = herd != 11) # check deleting herd 11   if (require(\"car\")) {     infIndexPlot(inf_gm1)     compareCoefs(gm1, gm1.11)   }   if(packageVersion(\"car\") >= \"3.0.10\") {     dfbeta(inf_gm1)     dfbetas(inf_gm1)   }  }"},{"path":"/reference/isNested.html","id":null,"dir":"Reference","previous_headings":"","what":"Is f1 nested within f2? — isNested","title":"Is f1 nested within f2? — isNested","text":"every level f1 occur conjunction exactly   one level f2? function based converting   triplet sparse matrix compressed column-oriented   form nesting can quickly evaluated.","code":""},{"path":"/reference/isNested.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Is f1 nested within f2? — isNested","text":"","code":"isNested(f1, f2)"},{"path":"/reference/isNested.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Is f1 nested within f2? — isNested","text":"f1 factor 1 f2 factor 2","code":""},{"path":"/reference/isNested.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Is f1 nested within f2? — isNested","text":"TRUE factor 1 nested within factor 2","code":""},{"path":"/reference/isNested.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Is f1 nested within f2? — isNested","text":"","code":"with(Pastes, isNested(cask, batch))   ## => FALSE #> [1] FALSE with(Pastes, isNested(sample, batch))  ## => TRUE #> [1] TRUE"},{"path":"/reference/isREML.html","id":null,"dir":"Reference","previous_headings":"","what":"Check characteristics of models — isREML","title":"Check characteristics of models — isREML","text":"Check characteristics models: whether model fit   corresponds linear (LMM), generalized linear (GLMM),   nonlinear (NLMM) mixed model, whether linear   mixed model fitted REML   (isREML(x) always FALSE GLMMs   NLMMs).","code":""},{"path":"/reference/isREML.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Check characteristics of models — isREML","text":"","code":"isREML(x, ...)    isLMM(x, ...)    isNLMM(x, ...)    isGLMM(x, ...)"},{"path":"/reference/isREML.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Check characteristics of models — isREML","text":"x fitted model. ... additional, optional arguments.  (None   used merMod methods)","code":""},{"path":"/reference/isREML.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Check characteristics of models — isREML","text":"logical value","code":""},{"path":"/reference/isREML.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Check characteristics of models — isREML","text":"generic functions.  present methods   mixed-effects models class   merMod.","code":""},{"path":[]},{"path":"/reference/isREML.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Check characteristics of models — isREML","text":"","code":"fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy) gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),               data = cbpp, family = binomial) nm1 <- nlmer(circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym|Tree,              Orange, start = c(Asym = 200, xmid = 725, scal = 350))  isLMM(fm1) #> [1] TRUE isGLMM(gm1) #> [1] TRUE ## check all : is.MM <- function(x) c(LMM = isLMM(x), GLMM= isGLMM(x), NLMM= isNLMM(x)) stopifnot(cbind(is.MM(fm1), is.MM(gm1), is.MM(nm1))     == diag(rep(TRUE,3)))"},{"path":"/reference/isSingular.html","id":null,"dir":"Reference","previous_headings":"","what":"Test Fitted Model for (Near) Singularity — isSingular","title":"Test Fitted Model for (Near) Singularity — isSingular","text":"Evaluates whether fitted mixed model (almost / near) singular, .e.,   parameters boundary feasible   parameter space: variances one linear combinations effects   (close ) zero.","code":""},{"path":"/reference/isSingular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test Fitted Model for (Near) Singularity — isSingular","text":"","code":"isSingular(x, tol = 1e-4)"},{"path":"/reference/isSingular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test Fitted Model for (Near) Singularity — isSingular","text":"x fitted merMod object (result lmer glmer). tol numerical tolerance detecting singularity.","code":""},{"path":"/reference/isSingular.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Test Fitted Model for (Near) Singularity — isSingular","text":"Complex mixed-effect models (.e.,   large number variance-covariance parameters) frequently result   singular fits, .e. estimated variance-covariance matrices   less full rank. Less technically, means   \"dimensions\" variance-covariance matrix estimated   exactly zero. scalar random effects intercept-models,   2-dimensional random effects intercept+slope models,   singularity relatively easy detect leads   random-effect variance estimates (nearly) zero, estimates   correlations (almost) exactly -1 1. However,   complex models (variance-covariance matrices dimension >=3)   singularity can hard detect; models can often singular   without individual variances close zero   correlations close +/-1. function performs simple test determine whether   random effects covariance matrices fitted model singular.   rePCA method provides detail   singularity pattern, showing standard deviations   orthogonal variance components mapping   variance terms model orthogonal components   (.e., eigenvector/rotation matrices). singular models statistically well defined (  theoretically sensible true maximum likelihood estimate   correspond singular fit), real concerns   (1) singular fits correspond overfitted models may   poor power; (2) chances numerical problems mis-convergence   higher singular models (e.g. may computationally   difficult compute profile confidence intervals   models); (3) standard inferential procedures Wald statistics   likelihood ratio tests may inappropriate. yet consensus deal singularity,   generally choose random-effects specification (  range choices varying complexity) use.  proposals   include:  avoid fitting overly complex models first place,     .e. design experiments/restrict models priori     variance-covariance matrices can estimated precisely enough     avoid singularity (Matuschek et al 2017) use form model selection choose model     balances predictive accuracy overfitting/type error     (Bates et al 2015, Matuschek et al 2017) “keep maximal”, .e. fit complex     model consistent experimental design, removing     terms required allow non-singular fit (Barr et al. 2013),     removing terms based p-values AIC use partially Bayesian method     produces maximum posteriori (MAP)     estimates using regularizing priors force     estimated random-effects variance-covariance matrices     away singularity (Chung et al 2013, blme package) use fully Bayesian method regularizes     model via informative priors gives estimates     credible intervals parameters average     uncertainty random effects parameters     (Gelman Hill 2006, McElreath 2015;     MCMCglmm, rstanarm brms packages)","code":""},{"path":"/reference/isSingular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test Fitted Model for (Near) Singularity — isSingular","text":"logical value","code":""},{"path":[]},{"path":"/reference/isSingular.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Test Fitted Model for (Near) Singularity — isSingular","text":"Dale J. Barr, Roger Levy, Christoph Scheepers, Harry J. Tily (2013).   Random effects structure confirmatory hypothesis testing: Keep maximal;   Journal Memory Language 68(3), 255–278. Douglas Bates, Reinhold Kliegl, Shravan Vasishth, Harald Baayen (2015).   Parsimonious Mixed Models; preprint (https://arxiv.org/abs/1506.04967). Yeojin Chung, Sophia Rabe-Hesketh, Vincent Dorie, Andrew Gelman, Jingchen Liu (2013).   nondegenerate penalized likelihood estimator variance parameters multilevel models;   Psychometrika 78, 685–709; doi:10.1007/S11336-013-9328-2 . Andrew Gelman Jennifer Hill (2006).   Data Analysis Using Regression Multilevel/Hierarchical Models.   Cambridge University Press. Hannes Matuschek, Reinhold Kliegl, Shravan Vasishth, Harald Baayen, Douglas Bates (2017).   Balancing type error power linear mixed models.   Journal Memory Language 94, 305–315. Richard McElreath (2015)   Statistical Rethinking: Bayesian Course Examples R Stan.   Chapman Hall/CRC.","code":""},{"path":"/reference/lmList.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit List of lm or glm Objects with a Common Model — lmList","title":"Fit List of lm or glm Objects with a Common Model — lmList","text":"Fit list lm glm objects   common model different subgroups data.","code":""},{"path":"/reference/lmList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit List of lm or glm Objects with a Common Model — lmList","text":"","code":"lmList(formula, data, family, subset, weights, na.action,        offset, pool = !isGLM || .hasScale(family2char(family)),        warn = TRUE, ...)"},{"path":"/reference/lmList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit List of lm or glm Objects with a Common Model — lmList","text":"formula linear formula object form     y ~ x1+...+xn | g.  formula object, y     represents response, x1,...,xn covariates,     g grouping factor specifying     partitioning data according different     lm fits performed. family optional family specification     generalized linear model (glm). data optional data frame containing     variables named formula.  default     variables taken environment     lmer called.  See Details. subset optional expression indicating     subset rows data used     fit.  can logical vector, numeric     vector indicating observation numbers     included, character vector row names     included.  observations included default. weights optional vector ‘prior       weights’ used fitting process.      NULL numeric vector. na.action function indicates     happen data contain NAs.  default     action (na.omit, inherited ‘factory     fresh’ value getOption(\"na.action\")) strips     observations missing values variables. offset can used specify       priori known component included linear     predictor fitting.  NULL     numeric vector length equal number cases.     One offset terms can included     formula instead well, one     specified sum used.  See     model.offset. pool logical scalar indicating variance estimate     pool residual sums squares.  default true model     scale parameter (includes linear, lmer(), ones). warn indicating errors single fits signal     “summary” warning. ... additional, optional arguments passed     model function family evaluation.","code":""},{"path":"/reference/lmList.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit List of lm or glm Objects with a Common Model — lmList","text":"object class lmList4 (see   , notably methods defined).","code":""},{"path":"/reference/lmList.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit List of lm or glm Objects with a Common Model — lmList","text":"data optional, package authors     strongly recommend use, especially later applying     methods update drop1 fitted model     (methods guaranteed work properly       data omitted).  data omitted, variables     taken environment formula (specified     formula) parent frame (specified character vector). Since lme4 version 1.1-16, errors (see     stop) single (lm() glm())     fits, summarized warning message returned     attribute \"warnMessage\" signalled warning()     warn argument true. previous lme4 versions, general (different) warning     signalled case.","code":""},{"path":[]},{"path":"/reference/lmList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit List of lm or glm Objects with a Common Model — lmList","text":"","code":"fm.plm  <- lmList(Reaction ~ Days | Subject, sleepstudy) coef(fm.plm) #>     (Intercept)      Days #> 308    244.1927 21.764702 #> 309    205.0549  2.261785 #> 310    203.4842  6.114899 #> 330    289.6851  3.008073 #> 331    285.7390  5.266019 #> 332    264.2516  9.566768 #> 333    275.0191  9.142045 #> 334    240.1629 12.253141 #> 335    263.0347 -2.881034 #> 337    290.1041 19.025974 #> 349    215.1118 13.493933 #> 350    225.8346 19.504017 #> 351    261.1470  6.433498 #> 352    276.3721 13.566549 #> 369    254.9681 11.348109 #> 370    210.4491 18.056151 #> 371    253.6360  9.188445 #> 372    267.0448 11.298073 fm.2  <- update(fm.plm, pool = FALSE) ## coefficients are the same, \"pooled or unpooled\": stopifnot( all.equal(coef(fm.2), coef(fm.plm)) )  (ci <- confint(fm.plm)) # print and rather *see* : #> An object of class \"lmList4.confint\" #> , , (Intercept) #>  #>        2.5 %   97.5 % #> 308 179.4339 308.9515 #> 309 193.0264 217.0834 #> 310 186.7857 220.1827 #> 330 259.4656 319.9046 #> 331 253.9831 317.4948 #> 332 181.7151 346.7882 #> 333 258.1329 291.9053 #> 334 212.3016 268.0243 #> 335 247.5990 278.4704 #> 337 267.9833 312.2249 #> 349 196.1192 234.1043 #> 350 192.8172 258.8520 #> 351 230.3022 291.9919 #> 352 241.7849 310.9592 #> 369 233.5099 276.4264 #> 370 177.7602 243.1379 #> 371 219.6541 287.6179 #> 372 251.7509 282.3387 #>  #> , , Days #>  #>            2.5 %    97.5 % #> 308  9.634266613 33.895138 #> 309  0.008641467  4.514929 #> 310  2.986982693  9.242815 #> 330 -2.652558845  8.668704 #> 331 -0.682394612 11.214432 #> 332 -5.893742346 25.027278 #> 333  5.978973800 12.305117 #> 334  7.034230035 17.472052 #> 335 -5.772399880  0.010332 #> 337 14.882372150 23.169576 #> 349  9.936302154 17.051563 #> 350 13.319294525 25.688739 #> 351  0.655729402 12.211266 #> 352  7.087781175 20.045317 #> 369  7.328617389 15.367601 #> 370 11.932968572 24.179333 #> 371  2.823051508 15.553838 #> 372  8.433264432 14.162882 #>  plot(ci)                # how widely they vary for the individuals"},{"path":"/reference/lmList4-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"Class \"lmList4\" S4 class basically   list objects class lm common   model (different data); see lmList() returns   . Package nlme's lmList() returns objects   S3 class \"lmList\" provides methods ,   methods partly build.","code":""},{"path":"/reference/lmList4-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class ","text":"Objects can created calls form   new(\"lmList4\", ...) , commonly, call   lmList().","code":""},{"path":"/reference/lmList4-class.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Class ","text":"dozen methods provided.  Currently, S4   methods show, coercion ((.,.))   others inherited via \"list\",  S3 methods   coef, confint, fitted,   fixef, formula, logLik,   pairs, plot, predict,   print, qqnorm, ranef,   residuals, sigma, summary,   update.  sigma(object) returns standard deviation       \\(\\hat{\\sigma}\\) (errors linear models), assuming       common variance \\(\\sigma^2\\) pooling (even       pool = FALSE used fit).","code":""},{"path":[]},{"path":"/reference/lmList4-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"if(getRversion() >= \"3.2.0\") {   (mm <- methods(class = \"lmList4\"))   ## The S3 (\"not S4\") ones :   mm[!attr(mm,\"info\")[,\"isS4\"]] } #>  [1] \"coef.lmList4\"      \"confint.lmList4\"   \"fitted.lmList4\"    #>  [4] \"fixef.lmList4\"     \"formula.lmList4\"   \"logLik.lmList4\"    #>  [7] \"pairs.lmList4\"     \"plot.lmList4\"      \"predict.lmList4\"   #> [10] \"qqnorm.lmList4\"    \"ranef.lmList4\"     \"residuals.lmList4\" #> [13] \"sigma.lmList4\"     \"summary.lmList4\"   \"update.lmList4\"    ## For more examples:  example(lmList)  i.e., ?lmList"},{"path":"/reference/lmResp-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Reference Classes for Response Modules, ","title":"Reference Classes for Response Modules, ","text":"Reference classes response modules, including linear   models, \"lmResp\", generalized linear models,   \"glmResp\", nonlinear models, \"nlsResp\"   linear mixed-effects models, \"lmerResp\".   reference class associated C++ class   name.  customary, generator object   class name class.","code":""},{"path":"/reference/lmResp-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Reference Classes for Response Modules, ","text":"reference classes extend inherit methods   \"envRefClass\".  Furthermore,   \"glmResp\", \"nlsResp\" \"lmerResp\"   extend \"lmResp\" class.","code":""},{"path":"/reference/lmResp-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Reference Classes for Response Modules, ","text":"Objects reference classes correspond   objects C++ classes.  Methods invoked C++   classes using external pointer ptr   field.  saving object external pointer   converted null pointer,   redundant fields containing enough information R   objects able regenerate C++ object.    convention field whose name begins   upper-case letter R object corresponding   field whose name begins lower-case letter   method.  Access external pointer   method, field.","code":""},{"path":[]},{"path":"/reference/lmResp-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reference Classes for Response Modules, ","text":"","code":"showClass(\"lmResp\") #> Class \"lmResp\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"envRefClass\", directly #> Class \".environment\", by class \"envRefClass\", distance 2 #> Class \"refClass\", by class \"envRefClass\", distance 2 #> Class \"environment\", by class \"envRefClass\", distance 3, with explicit coerce #> Class \"refObject\", by class \"envRefClass\", distance 3 #>  #> Known Subclasses: \"lmerResp\", \"glmResp\", \"nlsResp\" str(lmResp$new(y=1:4)) #> Reference class 'lmResp' [package \"lme4\"] with 8 fields #>  $ Ptr    :<externalptr>  #>  $ mu     : num [1:4] 0 0 0 0 #>  $ offset : num [1:4] 0 0 0 0 #>  $ sqrtXwt: num [1:4] 1 1 1 1 #>  $ sqrtrwt: num [1:4] 1 1 1 1 #>  $ weights: num [1:4] 1 1 1 1 #>  $ wtres  : num [1:4] 1 2 3 4 #>  $ y      : num [1:4] 1 2 3 4 #>  and 24 methods, of which 10 are  possibly relevant: #>    allInfo, copy#envRefClass, initialize, initializePtr, ptr, setOffset, #>    setResp, setWeights, updateMu, wrss showClass(\"glmResp\") #> Class \"glmResp\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"lmResp\", directly #> Class \"envRefClass\", by class \"lmResp\", distance 2 #> Class \".environment\", by class \"lmResp\", distance 3 #> Class \"refClass\", by class \"lmResp\", distance 3 #> Class \"environment\", by class \"lmResp\", distance 4, with explicit coerce #> Class \"refObject\", by class \"lmResp\", distance 4 str(glmResp$new(family=poisson(), y=1:4)) #> Reference class 'glmResp' [package \"lme4\"] with 11 fields #>  $ Ptr    :<externalptr>  #>  $ mu     : num [1:4] 0 0 0 0 #>  $ offset : num [1:4] 0 0 0 0 #>  $ sqrtXwt: num [1:4] 1 1 1 1 #>  $ sqrtrwt: num [1:4] 1 1 1 1 #>  $ weights: num [1:4] 1 1 1 1 #>  $ wtres  : num [1:4] 1 2 3 4 #>  $ y      : num [1:4] 1 2 3 4 #>  $ eta    : num [1:4] 0 0 0 0 #>  $ family :List of 13 #>   ..$ family    : chr \"poisson\" #>   ..$ link      : chr \"log\" #>   ..$ linkfun   :function (mu)   #>   ..$ linkinv   :function (eta)   #>   ..$ variance  :function (mu)   #>   ..$ dev.resids:function (y, mu, wt)   #>   ..$ aic       :function (y, n, mu, wt, dev)   #>   ..$ mu.eta    :function (eta)   #>   ..$ initialize:  expression({  if (any(y < 0))  stop(\"negative values not allowed for the 'Poisson' family\")  n <- rep.int(1, nobs| __truncated__ #>   ..$ validmu   :function (mu)   #>   ..$ valideta  :function (eta)   #>   ..$ simulate  :function (object, nsim)   #>   ..$ dispersion: num 1 #>   ..- attr(*, \"class\")= chr \"family\" #>  $ n      : num [1:4] 1 1 1 1 #>  and 43 methods, of which 29 are  possibly relevant: #>    Laplace, aic, allInfo, allInfo#lmResp, copy#envRefClass, devResid, fam, #>    initialize, initialize#lmResp, initializePtr, link, muEta, ptr, ptr#lmResp, #>    resDev, setOffset, setResp, setTheta, setWeights, sqrtWrkWt, theta, #>    updateMu, updateMu#lmResp, updateWts, variance, wrkResids, wrkResp, wrss, #>    wtWrkResp showClass(\"nlsResp\") #> Class \"nlsResp\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"lmResp\", directly #> Class \"envRefClass\", by class \"lmResp\", distance 2 #> Class \".environment\", by class \"lmResp\", distance 3 #> Class \"refClass\", by class \"lmResp\", distance 3 #> Class \"environment\", by class \"lmResp\", distance 4, with explicit coerce #> Class \"refObject\", by class \"lmResp\", distance 4 showClass(\"lmerResp\") #> Class \"lmerResp\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"lmResp\", directly #> Class \"envRefClass\", by class \"lmResp\", distance 2 #> Class \".environment\", by class \"lmResp\", distance 3 #> Class \"refClass\", by class \"lmResp\", distance 3 #> Class \"environment\", by class \"lmResp\", distance 4, with explicit coerce #> Class \"refObject\", by class \"lmResp\", distance 4 str(lmerResp$new(y=1:4)) #> Reference class 'lmerResp' [package \"lme4\"] with 9 fields #>  $ Ptr    :<externalptr>  #>  $ mu     : num [1:4] 0 0 0 0 #>  $ offset : num [1:4] 0 0 0 0 #>  $ sqrtXwt: num [1:4] 1 1 1 1 #>  $ sqrtrwt: num [1:4] 1 1 1 1 #>  $ weights: num [1:4] 1 1 1 1 #>  $ wtres  : num [1:4] 1 2 3 4 #>  $ y      : num [1:4] 1 2 3 4 #>  $ REML   : int 0 #>  and 28 methods, of which 14 are  possibly relevant: #>    allInfo, copy#envRefClass, initialize, initialize#lmResp, initializePtr, #>    initializePtr#lmResp, objective, ptr, ptr#lmResp, setOffset, setResp, #>    setWeights, updateMu, wrss"},{"path":"/reference/lmResp.html","id":null,"dir":"Reference","previous_headings":"","what":"Generator objects for the response classes — lmResp","title":"Generator objects for the response classes — lmResp","text":"generator objects   lmResp,   lmerResp,   glmResp   nlsResp reference classes.   objects primarily used new   methods.","code":""},{"path":"/reference/lmResp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generator objects for the response classes — lmResp","text":"","code":"lmResp(...)"},{"path":"/reference/lmResp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generator objects for the response classes — lmResp","text":"... List arguments (see Note).","code":""},{"path":"/reference/lmResp.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generator objects for the response classes — lmResp","text":"Arguments new methods must named   arguments. y numeric response vector family family object nlmod nonlinear model function nlenv environment holding data objects evaluation       nlmod pnames character vector parameter names gam numeric vector - initial linear predictor","code":""},{"path":"/reference/lmResp.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Generator objects for the response classes — lmResp","text":"new(y=y): Create new       lmResp       lmerResp object. new(family=family, y=y): Create new       glmResp object. new(y=y, nlmod=nlmod, nlenv=nlenv, \tpnames=pnames, gam=gam): Create new       nlsResp object.","code":""},{"path":[]},{"path":"/reference/lme4-package.html","id":null,"dir":"Reference","previous_headings":"","what":"Linear, generalized linear, and nonlinear mixed models — lme4-package","title":"Linear, generalized linear, and nonlinear mixed models — lme4-package","text":"lme4 provides functions fitting analyzing   mixed models: linear (lmer), generalized linear   (glmer) nonlinear (nlmer.)","code":""},{"path":"/reference/lme4-package.html","id":"differences-between-nlme-and-lme-","dir":"Reference","previous_headings":"","what":"Differences between nlme and lme4","title":"Linear, generalized linear, and nonlinear mixed models — lme4-package","text":"lme4 covers approximately ground earlier   nlme package.  important differences : lme4 uses modern, efficient linear algebra methods     implemented Eigen package, uses reference     classes avoid undue copying large objects; therefore likely     faster memory-efficient nlme. lme4 includes generalized linear mixed model (GLMM)     capabilities, via glmer function. lme4 currently implement nlme's     features modeling heteroscedasticity     correlation residuals. lme4 currently offer flexibility     nlme composing complex variance-covariance structures,     implement crossed random effects way     easier user much faster. lme4 offers built-facilities likelihood     profiling parametric bootstrapping. lme4 designed modular nlme,     making easier downstream package developers end-users     re-use components extensions basic mixed model     framework. also allows flexibility specifying     different functions optimizing random-effects     variance-covariance parameters. lme4 (yet) well-documented nlme.","code":""},{"path":"/reference/lme4-package.html","id":"differences-between-current-and-previous-versions-of-lme-","dir":"Reference","previous_headings":"","what":"Differences between current (1.0.+) and previous versions of   lme4","title":"Linear, generalized linear, and nonlinear mixed models — lme4-package","text":"[gn]lmer now produces objects class merMod   rather class mer new version uses combination S3 reference classes   (see ReferenceClasses, merPredD-class,   lmResp-class) well S4 classes; partly reason   interoperable nlme internal structure [gn]lmer now modular, allowing   finer control different steps argument checking; construction   design matrices data structures; parameter estimation; construction   final merMod object (see modular) profiling parametric bootstrapping new   current version new version lme4 provide   mcmcsamp (post-hoc MCMC sampling) method,   deemed unreliable.  Alternatives computing p-values   include parametric bootstrapping (bootMer) methods   implemented pbkrtest package leveraged   lmerTest package Anova function car package   (see pvalues details).","code":""},{"path":"/reference/lme4-package.html","id":"caveats-and-trouble-shooting","dir":"Reference","previous_headings":"","what":"Caveats and trouble-shooting","title":"Linear, generalized linear, and nonlinear mixed models — lme4-package","text":"users previously installed versions     RcppEigen minqa packages may encounter segmentation faults (!!);     solution make sure re-install packages     installing lme4.  (problem     explicit version packages, running     packages built different versions Rcpp     conjunction , simply making sure     latest version, using update.packages,     necessarily solve problem; must actually re-install     packages. problem likely minqa.)","code":""},{"path":"/reference/lme4_testlevel.html","id":null,"dir":"Reference","previous_headings":"","what":"Detect testing level for lme4 examples and tests — lme4_testlevel","title":"Detect testing level for lme4 examples and tests — lme4_testlevel","text":"Reads environment variable LME4_TEST_LEVEL determine   tests examples run","code":""},{"path":"/reference/lme4_testlevel.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Detect testing level for lme4 examples and tests — lme4_testlevel","text":"","code":"lme4_testlevel()"},{"path":"/reference/lme4_testlevel.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Detect testing level for lme4 examples and tests — lme4_testlevel","text":"numeric value: 1 standard/'light' testing, larger values   testing. Defaults 1 environment variable set.","code":""},{"path":"/reference/lmer.html","id":null,"dir":"Reference","previous_headings":"","what":"Fit Linear Mixed-Effects Models — lmer","title":"Fit Linear Mixed-Effects Models — lmer","text":"Fit linear mixed-effects model (LMM) data, via REML maximum   likelihood.","code":""},{"path":"/reference/lmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fit Linear Mixed-Effects Models — lmer","text":"","code":"lmer(formula, data = NULL, REML = TRUE, control = lmerControl(),      start = NULL, verbose = 0L, subset, weights, na.action,      offset, contrasts = NULL, devFunOnly = FALSE)"},{"path":"/reference/lmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fit Linear Mixed-Effects Models — lmer","text":"formula two-sided linear formula object describing     fixed-effects random-effects part model,     response left ~ operator terms, separated     + operators, right.  Random-effects terms     distinguished vertical bars (|) separating expressions     design matrices grouping factors.  Two vertical bars     (||) can used specify multiple uncorrelated random     effects grouping variable.      (way implemented, ||-syntax works        design matrices containing numeric (continuous) predictors;      fit models independent categorical effects, see dummy      lmer_alt function afex package.) data optional data frame containing variables named     formula.  default variables taken     environment lmer called. data     optional, package authors strongly recommend use,     especially later applying methods update     drop1 fitted model (methods     guaranteed work properly data omitted).     data omitted, variables taken environment     formula (specified formula) parent     frame (specified character vector). REML logical scalar - estimates chosen     optimize REML criterion (opposed log-likelihood)? control list (correct class, resulting     lmerControl() glmerControl()     respectively) containing control parameters, including nonlinear     optimizer used parameters passed     nonlinear optimizer, see *lmerControl documentation     details. start named list starting values     parameters model.  lmer can numeric     vector list one component named \"theta\". verbose integer scalar.  > 0 verbose output     generated optimization parameter estimates.      > 1 verbose output generated individual     penalized iteratively reweighted least squares (PIRLS) steps. subset optional expression indicating subset rows     data used fit. can logical     vector, numeric vector indicating observation numbers     included, character vector row names     included.  observations included default. weights optional vector ‘prior weights’ used     fitting process.  NULL numeric vector.     Prior weights normalized standardized     way.  particular, diagonal residual covariance     matrix squared residual standard deviation parameter     sigma times vector inverse weights.     Therefore, weights relatively large magnitudes,     order compensate, sigma parameter     also need relatively large magnitude. na.action function indicates happen     data contain NAs.  default action (na.omit,     inherited 'factory fresh' value     getOption(\"na.action\")) strips observations     missing values variables. offset can used specify priori known     component included linear predictor     fitting. NULL numeric vector length     equal number cases.  One offset     terms can included formula instead well,     one specified sum used.  See     model.offset. contrasts optional list. See contrasts.arg     model.matrix.default. devFunOnly logical - return deviance evaluation     function. Note deviance function operates     variables stored environment, may return     exactly values subsequent calls (results     always within machine tolerance).","code":""},{"path":"/reference/lmer.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Fit Linear Mixed-Effects Models — lmer","text":"object class merMod (specifically,   object subclass lmerMod), many methods   available (e.g. methods(class=\"merMod\"))","code":""},{"path":"/reference/lmer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fit Linear Mixed-Effects Models — lmer","text":"earlier version lme4 package, method argument   used.  functionality replaced REML argument. Also, lmer(.) allowed family argument (effectively   switch glmer(.)).  deprecated summer 2013,   disabled spring 2019.","code":""},{"path":"/reference/lmer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fit Linear Mixed-Effects Models — lmer","text":"formula argument specified character       vector, function attempt coerce formula.       However, recommended (users want construct       formulas pasting together components advised use       .formula reformulate); model fits       work subsequent methods drop1,       update may fail. handling perfectly collinear predictor variables       (.e. design matrices less full rank),       [gn]lmer quite sophisticated       simpler modeling frameworks       lm glm.       automatically drop collinear variables (message       rather warning), automatically fill       NA values dropped coefficients;       can added via       fixef(fitted.model,add.dropped=TRUE).       information can also retrieved via       attr(getME(fitted.model,\"X\"),\"col.dropped\"). deviance function returned devFunOnly       TRUE takes single numeric vector argument, representing       theta vector.  vector defines scaled       variance-covariance matrices random effects,       Cholesky parameterization.  models simple       (intercept-) random effects, theta vector       standard deviations random effects.  complex       multiple random effects, running getME(.,\"theta\")       retrieve theta vector fitted model examining       names vector probably easiest way determine       correspondence elements theta vector       elements lower triangles Cholesky factors       random effects.","code":""},{"path":[]},{"path":"/reference/lmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fit Linear Mixed-Effects Models — lmer","text":"","code":"## linear mixed models - reference values from older code (fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy #> REML criterion at convergence: 1743.628 #> Random effects: #>  Groups   Name        Std.Dev. Corr #>  Subject  (Intercept) 24.741        #>           Days         5.922   0.07 #>  Residual             25.592        #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      251.41        10.47   summary(fm1)# (with its own print method; see class?merMod % ./merMod-class.Rd #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy #>  #> REML criterion at convergence: 1743.6 #>  #> Scaled residuals:  #>     Min      1Q  Median      3Q     Max  #> -3.9536 -0.4634  0.0231  0.4634  5.1793  #>  #> Random effects: #>  Groups   Name        Variance Std.Dev. Corr #>  Subject  (Intercept) 612.10   24.741        #>           Days         35.07    5.922   0.07 #>  Residual             654.94   25.592        #> Number of obs: 180, groups:  Subject, 18 #>  #> Fixed effects: #>             Estimate Std. Error t value #> (Intercept)  251.405      6.825  36.838 #> Days          10.467      1.546   6.771 #>  #> Correlation of Fixed Effects: #>      (Intr) #> Days -0.138  str(terms(fm1)) #> Classes 'terms', 'formula'  language Reaction ~ Days #>   ..- attr(*, \"variables\")= language list(Reaction, Days) #>   ..- attr(*, \"factors\")= int [1:2, 1] 0 1 #>   .. ..- attr(*, \"dimnames\")=List of 2 #>   .. .. ..$ : chr [1:2] \"Reaction\" \"Days\" #>   .. .. ..$ : chr \"Days\" #>   ..- attr(*, \"term.labels\")= chr \"Days\" #>   ..- attr(*, \"order\")= int 1 #>   ..- attr(*, \"intercept\")= int 1 #>   ..- attr(*, \"response\")= int 1 #>   ..- attr(*, \".Environment\")=<environment: 0x55f09a249000>  #>   ..- attr(*, \"predvars\")= language list(Reaction, Days) stopifnot(identical(terms(fm1, fixed.only=FALSE),                     terms(model.frame(fm1)))) attr(terms(fm1, FALSE), \"dataClasses\") # fixed.only=FALSE needed for dataCl. #>  Reaction      Days   Subject  #> \"numeric\" \"numeric\"  \"factor\"   ## Maximum Likelihood (ML), and \"monitor\" iterations via 'verbose': fm1_ML <- update(fm1, REML=FALSE, verbose = 1) #> iteration: 1 #> \tf(x) = 1784.642296 #> iteration: 2 #> \tf(x) = 1790.125637 #> iteration: 3 #> \tf(x) = 1798.999624 #> iteration: 4 #> \tf(x) = 1803.853200 #> iteration: 5 #> \tf(x) = 1800.613981 #> iteration: 6 #> \tf(x) = 1798.604631 #> iteration: 7 #> \tf(x) = 1752.260737 #> iteration: 8 #> \tf(x) = 1797.587692 #> iteration: 9 #> \tf(x) = 1754.954110 #> iteration: 10 #> \tf(x) = 1753.695682 #> iteration: 11 #> \tf(x) = 1754.816999 #> iteration: 12 #> \tf(x) = 1753.106734 #> iteration: 13 #> \tf(x) = 1752.939377 #> iteration: 14 #> \tf(x) = 1752.256879 #> iteration: 15 #> \tf(x) = 1752.057448 #> iteration: 16 #> \tf(x) = 1752.022389 #> iteration: 17 #> \tf(x) = 1752.022728 #> iteration: 18 #> \tf(x) = 1751.971687 #> iteration: 19 #> \tf(x) = 1751.952603 #> iteration: 20 #> \tf(x) = 1751.948524 #> iteration: 21 #> \tf(x) = 1751.987176 #> iteration: 22 #> \tf(x) = 1751.983213 #> iteration: 23 #> \tf(x) = 1751.951971 #> iteration: 24 #> \tf(x) = 1751.946276 #> iteration: 25 #> \tf(x) = 1751.946698 #> iteration: 26 #> \tf(x) = 1751.947568 #> iteration: 27 #> \tf(x) = 1751.945312 #> iteration: 28 #> \tf(x) = 1751.944180 #> iteration: 29 #> \tf(x) = 1751.943533 #> iteration: 30 #> \tf(x) = 1751.942441 #> iteration: 31 #> \tf(x) = 1751.942170 #> iteration: 32 #> \tf(x) = 1751.942370 #> iteration: 33 #> \tf(x) = 1751.942278 #> iteration: 34 #> \tf(x) = 1751.942204 #> iteration: 35 #> \tf(x) = 1751.941309 #> iteration: 36 #> \tf(x) = 1751.940931 #> iteration: 37 #> \tf(x) = 1751.940567 #> iteration: 38 #> \tf(x) = 1751.940179 #> iteration: 39 #> \tf(x) = 1751.940082 #> iteration: 40 #> \tf(x) = 1751.940270 #> iteration: 41 #> \tf(x) = 1751.941501 #> iteration: 42 #> \tf(x) = 1751.939489 #> iteration: 43 #> \tf(x) = 1751.939392 #> iteration: 44 #> \tf(x) = 1751.939398 #> iteration: 45 #> \tf(x) = 1751.939425 #> iteration: 46 #> \tf(x) = 1751.939355 #> iteration: 47 #> \tf(x) = 1751.939490 #> iteration: 48 #> \tf(x) = 1751.939363 #> iteration: 49 #> \tf(x) = 1751.939345 #> iteration: 50 #> \tf(x) = 1751.939344 #> iteration: 51 #> \tf(x) = 1751.939345 #> iteration: 52 #> \tf(x) = 1751.939348 #> iteration: 53 #> \tf(x) = 1751.939344 (fm2 <- lmer(Reaction ~ Days + (Days || Subject), sleepstudy)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + ((1 | Subject) + (0 + Days | Subject)) #>    Data: sleepstudy #> REML criterion at convergence: 1743.669 #> Random effects: #>  Groups    Name        Std.Dev. #>  Subject   (Intercept) 25.051   #>  Subject.1 Days         5.988   #>  Residual              25.565   #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      251.41        10.47   anova(fm1, fm2) #> refitting model(s) with ML (instead of REML) #> Data: sleepstudy #> Models: #> fm2: Reaction ~ Days + ((1 | Subject) + (0 + Days | Subject)) #> fm1: Reaction ~ Days + (Days | Subject) #>     npar    AIC    BIC  logLik -2*log(L)  Chisq Df Pr(>Chisq) #> fm2    5 1762.0 1778.0 -876.00    1752.0                      #> fm1    6 1763.9 1783.1 -875.97    1751.9 0.0639  1     0.8004 sm2 <- summary(fm2) print(fm2, digits=7, ranef.comp=\"Var\") # the print.merMod()         method #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + ((1 | Subject) + (0 + Days | Subject)) #>    Data: sleepstudy #> REML criterion at convergence: 1743.669 #> Random effects: #>  Groups    Name        Variance  #>  Subject   (Intercept) 627.56905 #>  Subject.1 Days         35.85838 #>  Residual              653.58350 #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>   251.40510     10.46729   print(sm2, digits=3, corr=FALSE)       # the print.summary.merMod() method #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + ((1 | Subject) + (0 + Days | Subject)) #>    Data: sleepstudy #>  #> REML criterion at convergence: 1743.7 #>  #> Scaled residuals:  #>    Min     1Q Median     3Q    Max  #> -3.963 -0.463  0.020  0.465  5.186  #>  #> Random effects: #>  Groups    Name        Variance Std.Dev. #>  Subject   (Intercept) 627.6    25.05    #>  Subject.1 Days         35.9     5.99    #>  Residual              653.6    25.57    #> Number of obs: 180, groups:  Subject, 18 #>  #> Fixed effects: #>             Estimate Std. Error t value #> (Intercept)   251.41       6.89   36.51 #> Days           10.47       1.56    6.71  ## Fit sex-specific variances by constructing numeric dummy variables ## for sex and sex:age; in this case the estimated variance differences ## between groups in both intercept and slope are zero ... data(Orthodont,package=\"nlme\") Orthodont$nsex <- as.numeric(Orthodont$Sex==\"Male\") Orthodont$nsexage <- with(Orthodont, nsex*age) lmer(distance ~ age + (age|Subject) + (0+nsex|Subject) +      (0 + nsexage|Subject), data=Orthodont) #> boundary (singular) fit: see help('isSingular') #> Linear mixed model fit by REML ['lmerMod'] #> Formula: distance ~ age + (age | Subject) + (0 + nsex | Subject) + (0 +   #>     nsexage | Subject) #>    Data: Orthodont #> REML criterion at convergence: 442.6367 #> Random effects: #>  Groups    Name        Std.Dev.  Corr  #>  Subject   (Intercept) 2.3268096       #>            age         0.2264158 -0.61 #>  Subject.1 nsex        0.0001559       #>  Subject.2 nsexage     0.0000000       #>  Residual              1.3100560       #> Number of obs: 108, groups:  Subject, 27 #> Fixed Effects: #> (Intercept)          age   #>     16.7611       0.6602   #> optimizer (nloptwrap) convergence code: 0 (OK) ; 0 optimizer warnings; 1 lme4 warnings"},{"path":"/reference/lmerControl.html","id":null,"dir":"Reference","previous_headings":"","what":"Control of Mixed Model Fitting — lmerControl","title":"Control of Mixed Model Fitting — lmerControl","text":"Construct control structures mixed model fitting.  arguments   defaults, can grouped general control parameters, importantly optimizer,     restart_edge, etc; model- data-checking specifications, short     “checking options”, check.nobs.vs.rankZ,     check.rankX (currently nlmerControl); parameters passed optimizer, e.g.,     maximal number iterations, passed via optCtrl list     argument.","code":""},{"path":"/reference/lmerControl.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Control of Mixed Model Fitting — lmerControl","text":"","code":"lmerControl(optimizer = \"nloptwrap\",<!-- % was \"Nelder_Mead\" till Dec.2013, --> \t\t\t\t    <!-- % then \"bobyqa\" till Oct 2018; CRAN till 1.1-20 (2019-02-04) -->     restart_edge = TRUE,     boundary.tol = 1e-5,     calc.derivs = TRUE,     use.last.params = FALSE,     sparseX = FALSE,     standardize.X = FALSE,     ## input checking options     check.nobs.vs.rankZ = \"ignore\",     check.nobs.vs.nlev = \"stop\",     check.nlev.gtreq.5 = \"ignore\",     check.nlev.gtr.1 = \"stop\",     check.nobs.vs.nRE= \"stop\",     check.rankX = c(\"message+drop.cols\", \"silent.drop.cols\", \"warn+drop.cols\",                     \"stop.deficient\", \"ignore\"),     check.scaleX = c(\"warning\",\"stop\",\"silent.rescale\",                      \"message+rescale\",\"warn+rescale\",\"ignore\"),     check.formula.LHS = \"stop\",     ## convergence checking options     check.conv.grad     = .makeCC(\"warning\", tol = 2e-3, relTol = NULL),     check.conv.singular = .makeCC(action = \"message\", tol = formals(isSingular)$tol),     check.conv.hess     = .makeCC(action = \"warning\", tol = 1e-6),     ## optimizer args     optCtrl = list(),     mod.type = \"lmer\" )  glmerControl(optimizer = c(\"bobyqa\", \"Nelder_Mead\"),     restart_edge = FALSE,     boundary.tol = 1e-5,     calc.derivs = TRUE,     use.last.params = FALSE,     sparseX = FALSE,     standardize.X = FALSE,     ## input checking options     check.nobs.vs.rankZ = \"ignore\",     check.nobs.vs.nlev = \"stop\",     check.nlev.gtreq.5 = \"ignore\",     check.nlev.gtr.1 = \"stop\",     check.nobs.vs.nRE= \"stop\",     check.rankX = c(\"message+drop.cols\", \"silent.drop.cols\", \"warn+drop.cols\",                     \"stop.deficient\", \"ignore\"),     check.scaleX = c(\"warning\",\"stop\",\"silent.rescale\",                      \"message+rescale\",\"warn+rescale\",\"ignore\"),     check.formula.LHS = \"stop\",     ## convergence checking options     check.conv.grad     = .makeCC(\"warning\", tol = 2e-3, relTol = NULL),     check.conv.singular = .makeCC(action = \"message\", tol = formals(isSingular)$tol),     check.conv.hess     = .makeCC(action = \"warning\", tol = 1e-6),     ## optimizer args     optCtrl = list(),     mod.type = \"glmer\",     tolPwrss = 1e-7,     compDev = TRUE,     nAGQ0initStep = TRUE,     check.response.not.const = \"stop\"  )  nlmerControl(optimizer = \"Nelder_Mead\", tolPwrss = 1e-10,              optCtrl = list())  .makeCC(action, tol, relTol, ...)"},{"path":"/reference/lmerControl.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Control of Mixed Model Fitting — lmerControl","text":"optimizer character - name optimizing function(s).      character vector list functions: length 1     lmer glmer, possibly length 2 glmer).     Built-optimizers \"Nelder_Mead\",     \"bobyqa\" (minqa package),     \"nlminbwrap\" (using base R's nlminb)     default lmerControl(), \"nloptwrap\".      minimizing function allows box constraints can used provided     (1) takes input parameters fn (function         optimized), par (starting parameter values), lower         upper (parameter bounds) \tcontrol (control parameters, passed         control argument) (2) returns list (least) elements par         (best-fit parameters), fval (best-fit function value),         conv (convergence code, equal zero \tsuccessful convergence) (optionally) message         (informational message, explanation convergence failure). Special provisions made bobyqa,     Nelder_Mead, optimizers wrapped     optimx package; use optimx optimizers (including     L-BFGS-B base optim     nlminb), pass method argument     optim optCtrl argument (may     need load optimx package manually using     library(optimx)). glmer, length(optimizer)==2, first element     used preliminary (random effects parameters )     optimization, second used final (random     effects plus fixed effect parameters) phase.  See     modular information two phases. optimizer NULL (present lmer ),     model structures set , optimization     done (e.g. parameters returned NA). calc.derivs logical - compute gradient Hessian nonlinear     optimization solution? use.last.params logical - last value     parameters evaluated (TRUE), rather value     parameters corresponding minimum deviance, returned?     \"backward bug-compatibility\" option; use TRUE     trying match previous results. sparseX logical - sparse model matrix     used fixed-effects terms?     Currently inactive. restart_edge logical - optimizer     attempt restart finds solution     boundary (.e. zero random-effect variances perfect     +/-1 correlations)?  (Currently implemented     lmerControl.) boundary.tol numeric - within distance     boundary boundary checked better fit?     (Set zero disable boundary checking.) tolPwrss numeric scalar - tolerance declaring     convergence penalized iteratively weighted residual     sum--squares step. compDev logical scalar - compiled code     used deviance evaluation optimization     parameter estimates? nAGQ0initStep Run initial optimization phase     nAGQ = 0. initial optimization usually     provides good starting point subsequent fitting     (thus increasing overall computational speed),     setting option FALSE can useful cases     initial phase results bad fixed-effect estimates     (seen often binomial models link=\"cloglog\"     offsets). check.nlev.gtreq.5 character - rules     checking whether random effects >= 5 levels.     See action. check.nlev.gtr.1 character - rules checking     whether random effects > 1 level. See action. check.nobs.vs.rankZ character - rules     checking whether number observations greater     (greater equal ) rank random     effects design matrix (Z), usually necessary     identifiable variances.  action,     addition \"warningSmall\" \"stopSmall\", run     test dimensions Z < 1e6.     nobs > rank(Z) tested LMMs GLMMs     estimated scale parameters; nobs >= rank(Z) tested     GLMMs fixed scale parameter.     rank test done using     method=\"qr\" option rankMatrix     function. check.nobs.vs.nlev character - rules checking whether     number observations less (less equal )     number levels every grouping factor, usually necessary     identifiable variances.  action.     nobs<nlevels tested LMMs GLMMs estimated     scale parameters; nobs<=nlevels tested GLMMs     fixed scale parameter. check.nobs.vs.nRE character - rules     checking whether number observations greater     (greater equal ) number random-effects     levels term, usually necessary identifiable variances.     check.nobs.vs.nlev. check.conv.grad rules checking gradient deviance     function convergence.  list returned     .makeCC, character string action. check.conv.singular rules checking singular fit,     .e. one parameters boundary feasible     space (example, random effects variances equal 0     correlations random effects equal +/- 1.0);     check.conv.grad .  default use     isSingular(.., tol = *)'s default. check.conv.hess rules checking Hessian deviance     function convergence.; check.conv.grad     . check.rankX character - specifying rankMatrix(X)     compared ncol(X) columns design     matrix possibly dropped ensure full rank.     Sometimes needed make model identifiable.  options can     abbreviated; three \"*.drop.cols\" options drop     columns, \"stop.deficient\" gives error rank     smaller number columns \"ignore\"     rank computation, typically lead less easily     understandable errors, later. check.scaleX character - check problematic scaling     columns fixed-effect model matrix, e.g. parameters measured     different scales. check.formula.LHS check whether specified formula     left-hand side. Primarily internal use within     simulate.merMod;     use risk may allow generation     unstable merMod objects check.response..const character - check     response constant. optCtrl list additional arguments     passed nonlinear optimizer (see Nelder_Mead,     bobyqa).  particular,     Nelder_Mead bobyqa use maxfun     specify maximum number function evaluations     try giving - contrast     optim optimx-wrapped optimizers,     use maxit. (Also see convergence     details stopping tolerances different optimizers.) Note: lmer(), glmer()     nlmer() optional integer argument verbose     raise (positive value) order get diagnostic     console output optimization progress. action character - generic choices severity level     test, possible values \"ignore\": skip test. \"warning\": warn test fails. \"message\": print message test fails. \"stop\": throw error test fails.  tol (numeric) tolerance checking gradient, scaled     relative curvature (.e., testing gradient scale     defined Wald standard deviation) relTol (numeric) tolerance gradient, scaled     relative magnitude estimated coefficient mod.type model type (internal use) standardize.X scale columns X matrix? (yet implemented) ... elements include check specification","code":""},{"path":"/reference/lmerControl.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Control of Mixed Model Fitting — lmerControl","text":"*Control functions return list (inheriting class   \"merControl\") containing general control parameters, optimizer, restart_edge; (currently nlmerControl:)     \"checkControl\", list data-checking     specifications, e.g., check.nobs.vs.rankZ; parameters passed optimizer, .e., optCtrl     list, may contain maxiter. .makeCC returns list containing check specification   (action, tolerance, optionally relative tolerance).","code":""},{"path":"/reference/lmerControl.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Control of Mixed Model Fitting — lmerControl","text":"Note (!) pre-fitting “checking options”   (.e., starting \"check.\"   including convergence checks (\"check.conv.*\")   rank-checking (\"check.rank*\") options)   may also set globally via options.   case, (g)lmerControl use rather   default values, override values passed   explicit arguments. example, options(lmerControl=list(check.nobs.vs.rankZ = \"ignore\"))   suppress warnings number observations less   rank random effects model matrix Z.","code":""},{"path":[]},{"path":"/reference/lmerControl.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Control of Mixed Model Fitting — lmerControl","text":"","code":"str(lmerControl()) #> List of 8 #>  $ optimizer      : chr \"nloptwrap\" #>  $ restart_edge   : logi TRUE #>  $ boundary.tol   : num 1e-05 #>  $ calc.derivs    : logi TRUE #>  $ use.last.params: logi FALSE #>  $ checkControl   :List of 8 #>   ..$ check.nobs.vs.rankZ: chr \"ignore\" #>   ..$ check.nobs.vs.nlev : chr \"stop\" #>   ..$ check.nlev.gtreq.5 : chr \"ignore\" #>   ..$ check.nlev.gtr.1   : chr \"stop\" #>   ..$ check.nobs.vs.nRE  : chr \"stop\" #>   ..$ check.rankX        : chr \"message+drop.cols\" #>   ..$ check.scaleX       : chr \"warning\" #>   ..$ check.formula.LHS  : chr \"stop\" #>  $ checkConv      :List of 3 #>   ..$ check.conv.grad    :List of 3 #>   .. ..$ action: chr \"warning\" #>   .. ..$ tol   : num 0.002 #>   .. ..$ relTol: NULL #>   ..$ check.conv.singular:List of 2 #>   .. ..$ action: chr \"message\" #>   .. ..$ tol   : num 1e-04 #>   ..$ check.conv.hess    :List of 2 #>   .. ..$ action: chr \"warning\" #>   .. ..$ tol   : num 1e-06 #>  $ optCtrl        : list() #>  - attr(*, \"class\")= chr [1:2] \"lmerControl\" \"merControl\" str(glmerControl()) #> List of 11 #>  $ optimizer      : chr [1:2] \"bobyqa\" \"Nelder_Mead\" #>  $ restart_edge   : logi FALSE #>  $ boundary.tol   : num 1e-05 #>  $ calc.derivs    : logi TRUE #>  $ use.last.params: logi FALSE #>  $ checkControl   :List of 9 #>   ..$ check.nobs.vs.rankZ     : chr \"ignore\" #>   ..$ check.nobs.vs.nlev      : chr \"stop\" #>   ..$ check.nlev.gtreq.5      : chr \"ignore\" #>   ..$ check.nlev.gtr.1        : chr \"stop\" #>   ..$ check.nobs.vs.nRE       : chr \"stop\" #>   ..$ check.rankX             : chr \"message+drop.cols\" #>   ..$ check.scaleX            : chr \"warning\" #>   ..$ check.formula.LHS       : chr \"stop\" #>   ..$ check.response.not.const: chr \"stop\" #>  $ checkConv      :List of 3 #>   ..$ check.conv.grad    :List of 3 #>   .. ..$ action: chr \"warning\" #>   .. ..$ tol   : num 0.002 #>   .. ..$ relTol: NULL #>   ..$ check.conv.singular:List of 2 #>   .. ..$ action: chr \"message\" #>   .. ..$ tol   : num 1e-04 #>   ..$ check.conv.hess    :List of 2 #>   .. ..$ action: chr \"warning\" #>   .. ..$ tol   : num 1e-06 #>  $ optCtrl        : list() #>  $ tolPwrss       : num 1e-07 #>  $ compDev        : logi TRUE #>  $ nAGQ0initStep  : logi TRUE #>  - attr(*, \"class\")= chr [1:2] \"glmerControl\" \"merControl\" ## fit with default algorithm [nloptr version of BOBYQA] ... fm0 <- lmer(Reaction ~ Days +   ( 1 | Subject), sleepstudy) fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy) ## or with \"bobyqa\" (default 2013 - 2019-02) ... fm1_bobyqa <- update(fm1, control = lmerControl(optimizer=\"bobyqa\")) ## or with \"Nelder_Mead\" (the default till 2013) ... fm1_NMead <- update(fm1, control = lmerControl(optimizer=\"Nelder_Mead\")) ## or with the nlminb function used in older (<1.0) versions of lme4; ## this will usually replicate older results if (require(optimx)) {     fm1_nlminb <- update(fm1,                          control = lmerControl(optimizer= \"optimx\",                                                optCtrl  = list(method=\"nlminb\")))     ## The other option here is method=\"L-BFGS-B\". } #> Loading required package: optimx  ## Or we can wrap base::optim(): optimwrap <- function(fn,par,lower,upper,control=list(),                       ...) {     if (is.null(control$method)) stop(\"must specify method in optCtrl\")     method <- control$method     control$method <- NULL     ## \"Brent\" requires finite upper values (lower bound will always     ##  be zero in this case)     if (method==\"Brent\") upper <- pmin(1e4,upper)     res <- optim(par=par, fn=fn, lower=lower,upper=upper,                  control=control,method=method,...)     with(res, list(par  = par,                    fval = value,                    feval= counts[1],                    conv = convergence,                    message = message)) } fm0_brent <- update(fm0,                     control = lmerControl(optimizer = \"optimwrap\",                                           optCtrl = list(method=\"Brent\"))) #> Error in getOptfun(optimizer): couldn't find optimizer function optimwrap  ## You can also use functions (in addition to the lmerControl() default \"NLOPT_BOBYQA\") ## from the 'nloptr' package, see also  '?nloptwrap' : if (require(nloptr)) {     fm1_nloptr_NM <- update(fm1, control=lmerControl(optimizer=\"nloptwrap\",                                       optCtrl=list(algorithm=\"NLOPT_LN_NELDERMEAD\")))     fm1_nloptr_COBYLA <- update(fm1, control=lmerControl(optimizer=\"nloptwrap\",                                       optCtrl=list(algorithm=\"NLOPT_LN_COBYLA\",                                                    xtol_rel=1e-6,                                                    xtol_abs=1e-10,                                                    ftol_abs=1e-10))) } #> Loading required package: nloptr ## other algorithm options include NLOPT_LN_SBPLX"},{"path":"/reference/merMod-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"mixed-effects model represented   merPredD object response   module class inherits class   lmResp.  model   lmerResp response class lmerMod;   glmResp response class glmerMod;   nlsResp response class nlmerMod.","code":""},{"path":"/reference/merMod-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class ","text":"","code":"# S3 method for class 'merMod' anova(object, ..., refit = TRUE, model.names=NULL) # S3 method for class 'merMod' as.function(x, ...) # S3 method for class 'merMod' coef(object, ...) # S3 method for class 'merMod' deviance(object, REML = NULL, ...) REMLcrit(object) # S3 method for class 'merMod' extractAIC(fit, scale = 0, k = 2, ...) # S3 method for class 'merMod' family(object, ...) # S3 method for class 'merMod' formula(x, fixed.only = FALSE, random.only = FALSE, ...) # S3 method for class 'merMod' fitted(object, ...) # S3 method for class 'merMod' logLik(object, REML = NULL, ...) # S3 method for class 'merMod' nobs(object, ...) # S3 method for class 'merMod' ngrps(object, ...) # S3 method for class 'merMod' terms(x, fixed.only = TRUE, random.only = FALSE, ...) # S3 method for class 'merMod' model.frame(formula, fixed.only = FALSE, ...) # S3 method for class 'merMod' model.matrix(object, type = c(\"fixed\", \"random\", \"randomListRaw\"), ...) # S3 method for class 'merMod' print(x, digits = max(3, getOption(\"digits\") - 3),       correlation = NULL, symbolic.cor = FALSE,       signif.stars = getOption(\"show.signif.stars\"),        ranef.comp = \"Std.Dev.\",       ranef.corr = any(ranef.comp == \"Std.Dev.\"), ...)  # S3 method for class 'merMod' summary(object, correlation = , use.hessian = NULL, ...) # S3 method for class 'summary.merMod' print(x, digits = max(3, getOption(\"digits\") - 3),       correlation = NULL, symbolic.cor = FALSE,       signif.stars = getOption(\"show.signif.stars\"),       ranef.comp = c(\"Variance\", \"Std.Dev.\"),       ranef.corr = any(ranef.comp == \"Std.Dev.\"), show.resids = TRUE, ...) # S3 method for class 'merMod' update(object, formula., ..., evaluate = TRUE) # S3 method for class 'merMod' weights(object, type = c(\"prior\", \"working\"), ...)"},{"path":"/reference/merMod-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class ","text":"object R object class merMod, .e.,     resulting lmer(), glmer(),     etc. x R object class merMod summary.merMod,     respectively, latter resulting summary(<merMod>). fit R object class merMod. formula case model.frame,     merMod object. refit logical indicating objects class lmerMod     refitted ML comparing models. default     TRUE prevent common mistake inappropriately     comparing REML-fitted models different fixed effects,     whose likelihoods directly comparable. model.names character vectors model names used     anova table. scale currently used (see extractAIC). k see extractAIC. REML Logical. TRUE, return restricted log-likelihood     rather log-likelihood.  NULL (default),     set REML isREML(object) (see isREML). fixed.logical indicating fixed effects     components (terms formula elements) sought.  false,     components, including random ones, returned. random.complement fixed.; indicates     whether random components sought. (Trying specify     fixed.random.time     produce error.) correlation (logical)     summary.merMod, indicates whether correlation matrix     computed stored along covariance;     print.summary.merMod, indicates whether correlation     matrix fixed-effects parameters printed.      latter case, NULL (default), correlation matrix     printed computed summary(.),     \\(p <= 12\\), cutoff 12 may modified     options(lme4.summary.cor.max = <n>) use.hessian (logical) indicates whether use     finite-difference Hessian deviance function compute     standard errors fixed effects; see vcov.merMod   details digits number significant digits printing symbolic.cor symbolic encoding fixed-effects correlation     matrix printed?  , symnum function used. signif.stars (logical) significance stars used? ranef.comp character vector length one two, indicating     random-effects parameters reported variance /    standard deviation scale. show.resids quantiles scaled residuals printed? formula. see update.formula. evaluate see update. type weights(), type weights returned; either \"prior\" \tinitially supplied weights \"working\" weights \tfinal iteration penalized iteratively reweighted least \tsquares algorithm (PIRLS). model.matrix(), type model matrix \treturn: one \"fixed\" giving fixed effects model matrix, \t\"random\" giving random effects model matrix, \t\"randomListRaw\" giving list raw random effects model \tmatrices associated random effects term. ranef.corr (logical) print correlations (rather covariances)     random effects? ... potentially arguments passed methods.","code":""},{"path":"/reference/merMod-class.html","id":"objects-from-the-class","dir":"Reference","previous_headings":"","what":"Objects from the Class","title":"Class ","text":"Objects class merMod created calls   lmer, glmer nlmer.","code":""},{"path":"/reference/merMod-class.html","id":"s-methods","dir":"Reference","previous_headings":"","what":"S3 methods","title":"Class ","text":"following S3 methods arguments given exist (list currently complete): anova: returns sequential decomposition contributions     fixed-effects terms , multiple arguments, model comparison statistics.     objects class lmerMod default behavior refit models     ML fitted REML = TRUE, can controlled via     refit argument. See also anova. .function: returns deviance function,     lmer(*, devFunOnly=TRUE), mkLmerDevfun()     mkGlmerDevfun(), respectively. coef: Computes sum random fixed effects     coefficients explanatory variable level     grouping factor. extractAIC: Computes (generalized) Akaike     Information Criterion. isREML(fit), fit     refitted using maximum likelihood. family: family fitted     GLMM. (Warning: accessor may work properly     customized families/link functions.) fitted: Fitted values, given conditional modes     random effects.  flexible access fitted values, use     predict.merMod. logLik: Log-likelihood fitted value     parameters.  Note GLMMs, returned value     proportional log probability density (distribution)     response variable.  See logLik. model.frame: returns frame slot merMod. model.matrix: returns fixed effects model matrix. nobs, ngrps: Number observations vector     numbers levels grouping factor.  See ngrps. summary: Computes returns list summary statistics       fitted model, amount output can controlled via print method,       see also summary. print.summary: Controls output summary      method. update: See update.","code":""},{"path":"/reference/merMod-class.html","id":"deviance-and-log-likelihood-of-glmms","dir":"Reference","previous_headings":"","what":"Deviance and log-likelihood of GLMMs","title":"Class ","text":"One must careful defining deviance GLM.  example,   deviance defined minus twice log-likelihood   involve subtracting deviance saturated model?    distinguish two possibilities refer absolute deviance   (minus twice log-likelihood) relative deviance (relative   saturated model, e.g. Section 2.3.1 McCullagh Nelder 1989). GLMMs however, additional complication involving   distinction likelihood conditional likelihood.   latter likelihood obtained conditioning estimates   conditional modes spherical random effects coefficients,   whereas likelihood (.e. unconditional likelihood)   involves integrating coefficients.  following table   summarizes extract various types deviance   glmerMod object:  table requires two caveats:  link function involves scale parameter     (e.g. Gamma) object@resp$aic() - 2 * getME(object,     \"devcomp\")$dims[\"useSc\"] required absolute-conditional     case. adaptive Gauss-Hermite quadrature used,     logLik(object) currently proportional     absolute-unconditional log-likelihood. information topic see misc/logLikGLMM   directory package source.","code":""},{"path":"/reference/merMod-class.html","id":"slots","dir":"Reference","previous_headings":"","what":"Slots","title":"Class ","text":"resp: reference class object lme4       response module (lmResp-class). Gp: See getME. call: matched call. frame: model frame containing variables       required parse model formula. flist: See getME. cnms: See getME. lower: See getME. theta: Covariance parameter vector. beta: Fixed effects coefficients. u: Conditional model spherical random effects       coefficients. devcomp: See getME. pp: reference class object lme4       predictor module (merPredD-class). optinfo: List containing information       nonlinear optimization.","code":""},{"path":[]},{"path":"/reference/merMod-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"showClass(\"merMod\") #> Class \"merMod\" [package \"lme4\"] #>  #> Slots: #>                                                                          #> Name:          Gp       call      frame      flist       cnms      lower #> Class:    integer       call data.frame       list       list    numeric #>                                                                          #> Name:       theta       beta          u    devcomp         pp    optinfo #> Class:    numeric    numeric    numeric       list   merPredD       list #>  #> Known Subclasses: \"lmerMod\", \"glmerMod\", \"nlmerMod\" methods(class=\"merMod\")## over 30  (S3) methods available #>  [1] PBmodcomp                PBrefdist                VarCorr                  #>  [4] anova                    as.function              coef                     #>  [7] confint                  cooks.distance           deviance                 #> [10] df.residual              drop1                    extractAIC               #> [13] family                   fitted                   fixef                    #> [16] formula                  getData                  getL                     #> [19] getME                    hatvalues                influence                #> [22] isGLMM                   isLMM                    isNLMM                   #> [25] isREML                   logLik                   model.frame              #> [28] model.matrix             model2restriction_matrix na.action                #> [31] ngrps                    nobs                     plot                     #> [34] predict                  print                    profile                  #> [37] qqmath                   ranef                    rePCA                    #> [40] refit                    refitML                  residuals                #> [43] rstudent                 show                     sigma                    #> [46] simulate                 summary                  terms                    #> [49] update                   vcov                     weights                  #> see '?methods' for accessing help and source code  m1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy) print(m1, ranef.corr = TRUE)   ## print correlations of REs #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy #> REML criterion at convergence: 1743.628 #> Random effects: #>  Groups   Name        Std.Dev. Corr #>  Subject  (Intercept) 24.741        #>           Days         5.922   0.07 #>  Residual             25.592        #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      251.41        10.47   print(m1, ranef.corr = FALSE)  ## print covariances of REs #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy #> REML criterion at convergence: 1743.628 #> Random effects: #>  Groups   Name        Std.Dev. Cov    #>  Subject  (Intercept) 24.741          #>           Days         5.922     9.60 #>  Residual             25.592          #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      251.41        10.47"},{"path":"/reference/merPredD-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"reference class (see mother class definition   \"envRefClass\" mixed-effects model predictor   module dense model matrix fixed-effects parameters.   reference class associated C++ class name.   customary, generator object, merPredD,   class name class.","code":""},{"path":"/reference/merPredD-class.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Class ","text":"Objects reference class correspond objects C++   class.  Methods invoked C++ class object using external   pointer Ptr field.  saving object   external pointer converted null pointer,   redundant fields containing enough information R objects   able regenerate C++ object.  convention field   whose name begins upper-case letter R object   corresponding field, whose name begins lower-case letter   method.  References external pointer   method, directly Ptr field.","code":""},{"path":[]},{"path":"/reference/merPredD-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"showClass(\"merPredD\") #> Class \"merPredD\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"envRefClass\", directly #> Class \".environment\", by class \"envRefClass\", distance 2 #> Class \"refClass\", by class \"envRefClass\", distance 2 #> Class \"environment\", by class \"envRefClass\", distance 3, with explicit coerce #> Class \"refObject\", by class \"envRefClass\", distance 3 pp <- slot(lmer(Yield ~ 1|Batch, Dyestuff), \"pp\") stopifnot(is(pp, \"merPredD\")) str(pp) # an overview of all fields and methods' names. #> Reference class 'merPredD' [package \"lme4\"] with 18 fields #>  $ Lambdat:Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ i       : int [1:6] 0 1 2 3 4 5 #>   .. ..@ p       : int [1:7] 0 1 2 3 4 5 6 #>   .. ..@ Dim     : int [1:2] 6 6 #>   .. ..@ Dimnames:List of 2 #>   .. .. ..$ : NULL #>   .. .. ..$ : NULL #>   .. ..@ x       : num [1:6] 0.848 0.848 0.848 0.848 0.848 ... #>   .. ..@ factors : list() #>  $ LamtUt :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ i       : int [1:30] 0 0 0 0 0 1 1 1 1 1 ... #>   .. ..@ p       : int [1:31] 0 1 2 3 4 5 6 7 8 9 ... #>   .. ..@ Dim     : int [1:2] 6 30 #>   .. ..@ Dimnames:List of 2 #>   .. .. ..$ : NULL #>   .. .. ..$ : chr [1:30] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..@ x       : num [1:30] 0.848 0.848 0.848 0.848 0.848 ... #>   .. ..@ factors : list() #>  $ Lind   : int [1:6] 1 1 1 1 1 1 #>  $ Ptr    :<externalptr>  #>  $ RZX    : num [1:6, 1] 1.98 1.98 1.98 1.98 1.98 ... #>  $ Ut     :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ i       : int [1:30] 0 0 0 0 0 1 1 1 1 1 ... #>   .. ..@ p       : int [1:31] 0 1 2 3 4 5 6 7 8 9 ... #>   .. ..@ Dim     : int [1:2] 6 30 #>   .. ..@ Dimnames:List of 2 #>   .. .. ..$ : chr [1:6] \"A\" \"B\" \"C\" \"D\" ... #>   .. .. ..$ : chr [1:30] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..@ x       : num [1:30] 1 1 1 1 1 1 1 1 1 1 ... #>   .. ..@ factors : list() #>  $ Utr    : num [1:6] 6384 6481 6634 6354 6787 ... #>  $ V      : num [1:30, 1] 1 1 1 1 1 1 1 1 1 1 ... #>  $ VtV    : num [1, 1] 30 #>  $ Vtr    : num 45825 #>  $ X      : num [1:30, 1] 1 1 1 1 1 1 1 1 1 1 ... #>   ..- attr(*, \"dimnames\")=List of 2 #>   .. ..$ : chr [1:30] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..$ : chr \"(Intercept)\" #>   ..- attr(*, \"assign\")= int 0 #>   ..- attr(*, \"msgScaleX\")= chr(0)  #>  $ Xwts   : num [1:30] 1 1 1 1 1 1 1 1 1 1 ... #>  $ Zt     :Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots #>   .. ..@ i       : int [1:30] 0 0 0 0 0 1 1 1 1 1 ... #>   .. ..@ p       : int [1:31] 0 1 2 3 4 5 6 7 8 9 ... #>   .. ..@ Dim     : int [1:2] 6 30 #>   .. ..@ Dimnames:List of 2 #>   .. .. ..$ : chr [1:6] \"A\" \"B\" \"C\" \"D\" ... #>   .. .. ..$ : chr [1:30] \"1\" \"2\" \"3\" \"4\" ... #>   .. ..@ x       : num [1:30] 1 1 1 1 1 1 1 1 1 1 ... #>   .. ..@ factors : list() #>  $ beta0  : num 0 #>  $ delb   : num 1528 #>  $ delu   : num [1:6] -20.755 0.461 33.669 -27.212 66.877 ... #>  $ theta  : num 0.848 #>  $ u0     : num [1:6] 0 0 0 0 0 0 #>  and 45 methods, of which 31 are  possibly relevant: #>    CcNumer, L, P, RX, RXdiag, RXi, b, beta, copy#envRefClass, initialize, #>    initializePtr, installPars, ldL2, ldRX2, linPred, ptr, setBeta0, setDelb, #>    setDelu, setTheta, setZt, solve, solveU, sqrL, u, unsc, updateDecomp, #>    updateL, updateLamtUt, updateRes, updateXwts"},{"path":"/reference/merPredD.html","id":null,"dir":"Reference","previous_headings":"","what":"Generator object for the merPredD class — merPredD","title":"Generator object for the merPredD class — merPredD","text":"generator object   merPredD reference class.   object primarily used new method.","code":""},{"path":"/reference/merPredD.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generator object for the merPredD class — merPredD","text":"","code":"merPredD(...)"},{"path":"/reference/merPredD.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generator object for the merPredD class — merPredD","text":"... List arguments (see Note).","code":""},{"path":"/reference/merPredD.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generator object for the merPredD class — merPredD","text":"merPredD(...) short form new(\"merPredD\", ...)   create new merPredD object   ... must named arguments, (X, Zt, Lambdat, Lind,     theta,n): X: dense model matrix fixed-effects parameters,       stored X field. Zt: transpose sparse model matrix random       effects.  stored Zt field. Lambdat: transpose sparse lower triangular relative       variance factor (stored Lambdat field). Lind: integer vector length x slot       Lambdat field.  elements range 1       length theta field. theta: numeric vector variance component parameters (stored       theta field). n: sample size, usually nrow(X).","code":""},{"path":[]},{"path":"/reference/mkMerMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a 'merMod' Object — mkMerMod","title":"Create a 'merMod' Object — mkMerMod","text":"Create object (subclass ) class merMod   environment objective function value returned   optimizer.","code":""},{"path":"/reference/mkMerMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a 'merMod' Object — mkMerMod","text":"","code":"mkMerMod(rho, opt, reTrms, fr, mc, lme4conv = NULL)"},{"path":"/reference/mkMerMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a 'merMod' Object — mkMerMod","text":"rho environment objective function opt optimization result returned optimizer     (list: see lmerControl required elements) reTrms random effects structure calling function        (see mkReTrms required elements) fr model frame (see model.frame) mc matched call calling function lme4conv lme4-specific convergence information     (results checkConv)","code":""},{"path":"/reference/mkMerMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a 'merMod' Object — mkMerMod","text":"object class inherits merMod.","code":""},{"path":"/reference/mkNewReTrms.html","id":null,"dir":"Reference","previous_headings":"","what":"Make new random effect terms for prediction — mkNewReTrms","title":"Make new random effect terms for prediction — mkNewReTrms","text":"Rebuilds random effect terms","code":""},{"path":"/reference/mkNewReTrms.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make new random effect terms for prediction — mkNewReTrms","text":"","code":"mkNewReTrms(object, newdata, re.form=NULL,                      na.action=na.pass,                      allow.new.levels=FALSE,                      sparse = max(lengths(orig.random.levs)) > 100)"},{"path":"/reference/mkNewReTrms.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make new random effect terms for prediction — mkNewReTrms","text":"object fitted merMod object newdata data frame create     new RE terms object re.form (formula, NULL, NA) specify random effects condition predicting.  NULL,     include random effects; NA ~0,     include random effects na.action function determining done     missing values fixed effects newdata allow.new.levels (logical) new levels (NA values)     newdata allowed. FALSE (default), new values     newdata trigger error; TRUE, prediction     use unconditional (population-level) values data     previously unobserved levels (NAs) sparse generate sparse contrast matrices?","code":""},{"path":"/reference/mkNewReTrms.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make new random effect terms for prediction — mkNewReTrms","text":"list components Zt transpose sparse model matrix random effects theta initial values covariance parameters Lind integer vector indices determining mapping     elements theta vector \"x\" slot     Lambdat Gp vector indexing association     elements conditional mode vector     random-effect terms; nb vector numbers     conditional modes per term (.e. number groups times number     effects per group), Gp c(0,cumsum(nb))     (conversely nb diff(Gp)) lower lower bounds covariance parameters Lambdat transpose sparse relative covariance factor flist list grouping factors used     random-effects terms cnms list column names     random effects according grouping factors Ztlist list components transpose     random-effects model matrix, separated random-effects term nl names terms (order Zt,     .e. reflecting reorder.terms argument)","code":""},{"path":"/reference/mkNewReTrms.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Make new random effect terms for prediction — mkNewReTrms","text":"mkNewReTrms used context prediction,   generate new \"random effects terms\" object already fitted   model","code":""},{"path":[]},{"path":"/reference/mkNewReTrms.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Make new random effect terms for prediction — mkNewReTrms","text":"","code":"fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy) nd <- data.frame(Days = 5, Subject = \"new\") try(mkNewReTrms(fm1, newdata = nd)) #> Error in levelfun(r, n, allow.new.levels = allow.new.levels) :  #>   new levels detected in newdata: new t1 <- mkNewReTrms(fm1, newdata = nd, allow.new.levels = TRUE)"},{"path":"/reference/mkRespMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Create an lmerResp, glmResp or nlsResp instance — mkRespMod","title":"Create an lmerResp, glmResp or nlsResp instance — mkRespMod","text":"Create lmerResp, glmResp nlsResp instance","code":""},{"path":"/reference/mkRespMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create an lmerResp, glmResp or nlsResp instance — mkRespMod","text":"","code":"mkRespMod(fr, REML = NULL, family = NULL, nlenv = NULL,     nlmod = NULL, ...)"},{"path":"/reference/mkRespMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create an lmerResp, glmResp or nlsResp instance — mkRespMod","text":"fr model frame REML logical scalar, value REML lmerResp   instance family optional glm family (glmResp ) nlenv nonlinear model evaluation environment   (nlsResp ) nlmod nonlinear model function (nlsResp ) ... look response information   fr missing.  Can contain model response,   y, offset, offset, weights,   weights.","code":""},{"path":"/reference/mkRespMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create an lmerResp, glmResp or nlsResp instance — mkRespMod","text":"lmerResp glmResp nlsResp instance","code":""},{"path":[]},{"path":"/reference/mkSimulationTemplate.html","id":null,"dir":"Reference","previous_headings":"","what":"Make templates suitable for guiding mixed model simulations — mkSimulateTemplate","title":"Make templates suitable for guiding mixed model simulations — mkSimulateTemplate","text":"Make data parameter templates suitable guiding mixed model   simulations, specifying model formula information   (EXPERIMENTAL).  useful simulating balanced designs   getting started unbalanced simulations.","code":""},{"path":"/reference/mkSimulationTemplate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make templates suitable for guiding mixed model simulations — mkSimulateTemplate","text":"","code":"mkParsTemplate(formula, data) mkDataTemplate(formula, data, nGrps = 2, nPerGrp = 1, rfunc = NULL, ...)"},{"path":"/reference/mkSimulationTemplate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make templates suitable for guiding mixed model simulations — mkSimulateTemplate","text":"formula mixed model formula (see lmer). data data frame containing names formula. nGrps Number levels grouping factor. nPerGrp Number observations per level. rfunc Function generating covariate data (e.g. rnorm. ... Additional parameters rfunc.","code":""},{"path":[]},{"path":"/reference/mkVarCorr.html","id":null,"dir":"Reference","previous_headings":"","what":"Make Variance and Correlation Matrices from theta — mkVarCorr","title":"Make Variance and Correlation Matrices from theta — mkVarCorr","text":"Make variance correlation matrices theta","code":""},{"path":"/reference/mkVarCorr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Make Variance and Correlation Matrices from theta — mkVarCorr","text":"","code":"mkVarCorr(sc, cnms, nc, theta, nms)"},{"path":"/reference/mkVarCorr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Make Variance and Correlation Matrices from theta — mkVarCorr","text":"sc scale factor (residual standard deviation). cnms component names. nc numeric vector: number terms RE component. theta theta vector (lower-triangle Cholesky factors). nms component names (FIXME: nms/cnms redundant:   nms=names(cnms)?)","code":""},{"path":"/reference/mkVarCorr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Make Variance and Correlation Matrices from theta — mkVarCorr","text":"matrix","code":""},{"path":[]},{"path":"/reference/modular.html","id":null,"dir":"Reference","previous_headings":"","what":"Modular Functions for Mixed Model Fits — modular","title":"Modular Functions for Mixed Model Fits — modular","text":"Modular functions mixed model fits","code":""},{"path":"/reference/modular.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Modular Functions for Mixed Model Fits — modular","text":"","code":"lFormula(formula, data = NULL, REML = TRUE,     subset, weights, na.action, offset, contrasts = NULL,     control = lmerControl(), ...)  mkLmerDevfun(fr, X, reTrms, REML = TRUE, start = NULL,     verbose = 0, control = lmerControl(), ...)  optimizeLmer(devfun,              optimizer    = formals(lmerControl)$optimizer,              restart_edge = formals(lmerControl)$restart_edge,              boundary.tol = formals(lmerControl)$boundary.tol,              start = NULL, verbose = 0L,              control = list(), ...)  glFormula(formula, data = NULL, family = gaussian,     subset, weights, na.action, offset, contrasts = NULL,     start, mustart, etastart, control = glmerControl(), ...)  mkGlmerDevfun(fr, X, reTrms, family, nAGQ = 1L,               verbose = 0L, maxit = 100L, control = glmerControl(), ...)  optimizeGlmer(devfun,     optimizer = if(stage == 1) \"bobyqa\" else \"Nelder_Mead\",     restart_edge = FALSE,     boundary.tol = formals(glmerControl)$boundary.tol,     verbose = 0L, control = list(),     nAGQ = 1L, stage = 1, start = NULL, ...)  updateGlmerDevfun(devfun, reTrms, nAGQ = 1L)"},{"path":"/reference/modular.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Modular Functions for Mixed Model Fits — modular","text":"formula two-sided linear formula object     describing fixed-effects random-effects parts     model, response left ~     operator terms, separated + operators,     right.  Random-effects terms distinguished     vertical bars (\"|\") separating expressions     design matrices grouping factors. data optional data frame containing     variables named formula.  default     variables taken environment     lmer called. data optional,     package authors strongly recommend use,     especially later applying methods     update drop1 fitted model     (methods guaranteed work properly       data omitted). data omitted,     variables taken environment     formula (specified formula)     parent frame (specified character vector). REML (logical) indicating fit restricted maximum     likelihood model. subset optional expression indicating     subset rows data used     fit. can logical vector, numeric     vector indicating observation numbers     included, character vector row names     included.  observations included default. weights optional vector ‘prior weights’ used     fitting process.  NULL numeric vector. na.action function indicates     happen data contain NAs.  default     action (na.omit, inherited 'factory     fresh' value getOption(\"na.action\")) strips     observations missing values variables. offset can used specify priori known     component included linear predictor     fitting.  NULL numeric vector length     equal number cases.  One offset     terms can included formula instead well,     one specified sum used.  See     model.offset. contrasts optional list.  See     contrasts.arg model.matrix.default. control list giving [g]lFormula: \toptions running model, see lmerControl; mkLmerDevfun,mkGlmerDevfun: options \tinner optimization step; optimizeLmer optimizeGlmer: control \tparameters nonlinear optimizer (typically inherited \t... argument lmerControl).  fr model frame containing variables needed create     lmerResp glmResp instance. X fixed-effects design matrix reTrms information random effects structure (see     mkReTrms). start starting values (see lmer;     glFormula, just numeric vector     fixed-effect coefficients) verbose print output? maxit maximal number Pwrss update iterations. devfun deviance function, generated mkLmerDevfun nAGQ number Gauss-Hermite quadrature points stage optimization stage (1: nAGQ=0, optimize theta ;     2: nAGQ possibly >0, optimize theta beta) optimizer character - name optimizing     function(s).  character vector list functions:     length 1 lmer glmer, possibly length     2 glmer.  built-optimizers     \"Nelder_Mead\" \"bobyqa\"     (minqa package).  minimizing function     allows box constraints can used provided takes input parameters fn (function \toptimized), par (starting parameter values), \tlower (lower bounds) control (control \tparameters, passed control \targument) returns list (least) elements \tpar (best-fit parameters), fval (best-fit \tfunction value), conv (convergence code) \t(optionally) message (informational message, \texplanation convergence failure). Special provisions made bobyqa,     Nelder_Mead, optimizers wrapped     optimx package; use optimx optimizers     (including L-BFGS-B base optim     nlminb), pass method     argument optim control argument. glmer, length(optimizer)==2,     first element used preliminary (random     effects parameters ) optimization, second     used final (random effects plus fixed     effect parameters) phase. See modular     information two phases. restart_edge see lmerControl boundary.tol see lmerControl family GLM family; see glm     family. mustart optional starting values scale     conditional mean; see glm details. etastart optional starting values scale     unbounded predictor; see glm details. ... potential arguments; optimizeLmer     optimizeGlmer, passed internal function     optwrap, relevant parameters calc.derivs     use.last.params (see lmerControl).","code":""},{"path":"/reference/modular.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Modular Functions for Mixed Model Fits — modular","text":"lFormula glFormula return list containing   components:  fr model frame X fixed-effect design matrix reTrms list containing information random effects structure:      result mkReTrms REML (lFormula ): logical indicating restricted maximum      likelihood used (Copy argument.) mkLmerDevfun mkGlmerDevfun return function       calculate deviance (restricted deviance) function       theta (random-effect) parameters.  updateGlmerDevfun       returns function calculate deviance function       concatenation theta beta (fixed-effect) parameters.       deviance functions environment containing objects required       evaluation. CAUTION: environment       functions returned mk(Gl|L)merDevfun contains reference       class objects (see ReferenceClasses,       merPredD-class, lmResp-class),       behave ways may surprise many users. example,       output mk(Gl|L)merDevfun naively copied,       modifications original also appear copy (      vice versa). avoid behavior one must make deep copy (see       ReferenceClasses details). optimizeLmer optimizeGlmer return results   optimization.","code":""},{"path":"/reference/modular.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Modular Functions for Mixed Model Fits — modular","text":"functions make internal components [gn]lmer fit. [g]lFormula takes arguments normally     passed [g]lmer, checking errors processing     formula data input create list objects required fit     mixed model. mk(Gl|L)merDevfun takes output previous     step (minus formula component) creates     deviance function optimize(Gl|L)mer takes     deviance function optimizes theta (    theta beta, stage set     2 optimizeGlmer updateGlmerDevfun takes first stage GLMM     optimization (nAGQ=0, optimizing theta )     produces second-stage deviance function mkMerMod takes environment     deviance function, results optimization, list     random-effect terms, model frame, model produces     [g]lmerMod object.","code":""},{"path":"/reference/modular.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Modular Functions for Mixed Model Fits — modular","text":"","code":"### Fitting a linear mixed model in 4 modularized steps  ## 1.  Parse the data and formula: lmod <- lFormula(Reaction ~ Days + (Days|Subject), sleepstudy) names(lmod) #> [1] \"fr\"      \"X\"       \"reTrms\"  \"REML\"    \"formula\" \"wmsgs\"   ## 2.  Create the deviance function to be optimized: (devfun <- do.call(mkLmerDevfun, lmod)) #> function (theta)  #> .Call(lmer_Deviance, pp$ptr(), resp$ptr(), as.double(theta)) #> <environment: 0x55f0a0b16990> ls(environment(devfun)) # the environment of 'devfun' contains objects #> [1] \"lmer_Deviance\" \"lower\"         \"pp\"            \"resp\"                                  # required for its evaluation ## 3.  Optimize the deviance function: opt <- optimizeLmer(devfun) opt[1:3] #> $par #> [1] 0.96674177 0.01516906 0.23090995 #>  #> $fval #> [1] 1743.628 #>  #> $feval #> [1] 43 #>  ## 4.  Package up the results: mkMerMod(environment(devfun), opt, lmod$reTrms, fr = lmod$fr) #> Linear mixed model fit by REML ['lmerMod'] #> REML criterion at convergence: 1743.628 #> Random effects: #>  Groups   Name        Std.Dev. Corr #>  Subject  (Intercept) 24.741        #>           Days         5.922   0.07 #>  Residual             25.592        #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      251.41        10.47     ### Same model in one line lmer(Reaction ~ Days + (Days|Subject), sleepstudy) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy #> REML criterion at convergence: 1743.628 #> Random effects: #>  Groups   Name        Std.Dev. Corr #>  Subject  (Intercept) 24.741        #>           Days         5.922   0.07 #>  Residual             25.592        #> Number of obs: 180, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      251.41        10.47     ### Fitting a generalized linear mixed model in six modularized steps  ## 1.  Parse the data and formula: glmod <- glFormula(cbind(incidence, size - incidence) ~ period + (1 | herd),                    data = cbpp, family = binomial)     #.... see what've got : str(glmod, max=1, give.attr=FALSE) #> List of 6 #>  $ fr     :'data.frame':\t56 obs. of  3 variables: #>  $ X      : num [1:56, 1:4] 1 1 1 1 1 1 1 1 1 1 ... #>  $ reTrms :List of 10 #>  $ family :List of 13 #>  $ formula:Class 'formula'  language cbind(incidence, size - incidence) ~ period + (1 | herd) #>  $ wmsgs  : chr(0)  ## 2.  Create the deviance function for optimizing over theta: (devfun <- do.call(mkGlmerDevfun, glmod)) #> function (theta)  #> { #>     resp$updateMu(lp0) #>     pp$setTheta(theta) #>     p <- pwrssUpdate(pp, resp, tol = tolPwrss, GQmat = GHrule(0L),  #>         compDev = compDev, maxit = maxit, verbose = verbose) #>     resp$updateWts() #>     p #> } #> <environment: 0x55f09bfb5e18> ls(environment(devfun)) # the environment of devfun contains lots of info #> [1] \"compDev\"     \"lower\"       \"lp0\"         \"maxit\"       \"pp\"          #> [6] \"pwrssUpdate\" \"resp\"        \"tolPwrss\"    \"verbose\"     ## 3.  Optimize over theta using a rough approximation (i.e. nAGQ = 0): (opt <- optimizeGlmer(devfun)) #> parameter estimates: 0.641838555326752  #> objective: 184.108693002453  #> number of function evaluations: 18  ## 4.  Update the deviance function for optimizing over theta and beta: (devfun <- updateGlmerDevfun(devfun, glmod$reTrms)) #> function (pars)  #> { #>     resp$setOffset(baseOffset) #>     resp$updateMu(lp0) #>     pp$setTheta(as.double(pars[dpars])) #>     spars <- as.numeric(pars[-dpars]) #>     offset <- if (length(spars) == 0)  #>         baseOffset #>     else baseOffset + pp$X %*% spars #>     resp$setOffset(offset) #>     p <- pwrssUpdate(pp, resp, tol = tolPwrss, GQmat = GQmat,  #>         compDev = compDev, grpFac = fac, maxit = maxit, verbose = verbose) #>     resp$updateWts() #>     p #> } #> <environment: 0x55f09bfb5e18> ## 5.  Optimize over theta and beta: opt <- optimizeGlmer(devfun, stage=2) str(opt, max=1) # seeing what we'got #> List of 7 #>  $ fval       : num 184 #>  $ par        : num [1:5] 0.642 -1.398 -0.992 -1.128 -1.58 #>  $ convergence: num 0 #>  $ NM.result  : int 3 #>  $ message    : chr \"parameter values converged to within tolerance\" #>  $ control    :List of 17 #>  $ feval      : num 285 #>  - attr(*, \"optimizer\")= chr \"Nelder_Mead\" #>  - attr(*, \"control\")=List of 3 #>  - attr(*, \"warnings\")= list() #>  - attr(*, \"derivs\")=List of 2 ## 6.  Package up the results: (fMod <- mkMerMod(environment(devfun), opt, glmod$reTrms, fr = glmod$fr)) #> Generalized linear mixed model fit by maximum likelihood (Laplace #>   Approximation) [glmerMod] #>  Family: binomial  ( logit ) #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  194.0531  204.1799  -92.0266  184.0531        51  #> Random effects: #>  Groups Name        Std.Dev. #>  herd   (Intercept) 0.6421   #> Number of obs: 56, groups:  herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>     -1.3983      -0.9919      -1.1282      -1.5797    ### Same model in one line fM <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),             data = cbpp, family = binomial) all.equal(fMod, fM, check.attributes=FALSE, tolerance = 1e-12) #> [1] TRUE         # ----  --  even tolerance = 0  may work"},{"path":"/reference/namedList.html","id":null,"dir":"Reference","previous_headings":"","what":"Self-naming list function — namedList","title":"Self-naming list function — namedList","text":"function takes list arguments combines   list; unnamed arguments automatically named   match symbols.  tibble::lst() function offers   similarly functionality.","code":""},{"path":"/reference/namedList.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Self-naming list function — namedList","text":"","code":"namedList(...)"},{"path":"/reference/namedList.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Self-naming list function — namedList","text":"... comma-separated arguments","code":""},{"path":"/reference/namedList.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Self-naming list function — namedList","text":"","code":"a <- 1 b <- 2 c <- 3 str(namedList(a, b, d = c)) #> List of 3 #>  $ a: num 1 #>  $ b: num 2 #>  $ d: num 3"},{"path":"/reference/ngrps.html","id":null,"dir":"Reference","previous_headings":"","what":"Number of Levels of a Factor or a ","title":"Number of Levels of a Factor or a ","text":"Returns number levels factor set   factors, currently e.g., grouping factors   lmer(), glmer(), etc.","code":""},{"path":"/reference/ngrps.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Number of Levels of a Factor or a ","text":"","code":"ngrps(object, ...)"},{"path":"/reference/ngrps.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Number of Levels of a Factor or a ","text":"object R object, see Details. ... currently ignored.","code":""},{"path":"/reference/ngrps.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Number of Levels of a Factor or a ","text":"number levels (factor) vector number levels   “grouping factor” ","code":""},{"path":"/reference/ngrps.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Number of Levels of a Factor or a ","text":"Currently methods objects class   merMod, .e., result lmer() etc,   factor objects.","code":""},{"path":"/reference/ngrps.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Number of Levels of a Factor or a ","text":"","code":"ngrps(factor(seq(1,10,2))) #> [1] 5 ngrps(lmer(Reaction ~ 1|Subject, sleepstudy)) #> Subject  #>      18   ## A named vector if there's more than one grouping factor : ngrps(lmer(strength ~ (1|batch/cask), Pastes)) #> cask:batch      batch  #>         30         10  ## cask:batch      batch ##         30         10  methods(ngrps) # -> \"factor\" and \"merMod\" #> [1] ngrps.default* ngrps.factor*  ngrps.merMod*  #> see '?methods' for accessing help and source code"},{"path":"/reference/nlformula.html","id":null,"dir":"Reference","previous_headings":"","what":"Manipulate a Nonlinear Model Formula — nlformula","title":"Manipulate a Nonlinear Model Formula — nlformula","text":"Check manipulate formula nonlinear model,   specified nlmer.","code":""},{"path":"/reference/nlformula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Manipulate a Nonlinear Model Formula — nlformula","text":"","code":"nlformula(mc)"},{"path":"/reference/nlformula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Manipulate a Nonlinear Model Formula — nlformula","text":"mc matched call calling function, typically     nlmer().  arguments named formula: formula form resp ~ nlmod ~ meform \tresp expression response, \tnlmod nonlinear model expression \tmeform mixed-effects model formula. \tresp can omitted , e.g., optimizing design. data: data frame evaluate model function start: either numeric vector containing initial estimates \tnonlinear model parameters list components nlpars: initial estimates nonlinear \t    model parameters theta: initial estimates variance \t    component parameters","code":""},{"path":"/reference/nlformula.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Manipulate a Nonlinear Model Formula — nlformula","text":"list components \"respMod\" response module class \"nlsResp\" \"frame\" model frame, including terms attribute \"X\" fixed-effects model matrix \"reTrms\" random-effects terms object","code":""},{"path":"/reference/nlformula.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Manipulate a Nonlinear Model Formula — nlformula","text":"model formula nonlinear mixed-effects model   form resp ~ nlmod ~ mixed   resp expression (usually just name)   response, nlmod call nonlinear   model function, mixed mixed-effects   formula defining linear predictor parameter   matrix.  formula used optimizing   designs, resp part can omitted.","code":""},{"path":[]},{"path":"/reference/nlmer.html","id":null,"dir":"Reference","previous_headings":"","what":"Fitting Nonlinear Mixed-Effects Models — nlmer","title":"Fitting Nonlinear Mixed-Effects Models — nlmer","text":"Fit nonlinear mixed-effects model (NLMM) data, via maximum   likelihood.","code":""},{"path":"/reference/nlmer.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Fitting Nonlinear Mixed-Effects Models — nlmer","text":"","code":"nlmer(formula, data = NULL, control = nlmerControl(),       start = NULL, verbose = 0L, nAGQ = 1L, subset, weights, na.action,       offset, contrasts = NULL, devFunOnly = FALSE)"},{"path":"/reference/nlmer.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Fitting Nonlinear Mixed-Effects Models — nlmer","text":"formula three-part “nonlinear mixed model” formula,     form resp ~ Nonlin(...) ~ fixed + random, third     part similar RHS formula , e.g., lmer.          Currently, Nonlin(..) formula part must return     numeric vector, also must \"gradient\" attribute,     matrix.  functions SSbiexp,     SSlogis, etc, see selfStart, provide     ().  Alternatively, can use deriv()     automatically produce functions expressions. data optional data frame containing variables named     formula.  default variables taken     environment lmer called.  data     optional, package authors strongly recommend use,     especially later applying methods update     drop1 fitted model (methods     guaranteed work properly data omitted).      data omitted, variables taken environment     formula (specified formula) parent     frame (specified character vector). control list (correct class, resulting     lmerControl() glmerControl()     respectively) containing control parameters, including nonlinear     optimizer used parameters passed     nonlinear optimizer, see *lmerControl documentation     details. start starting estimates nonlinear model parameters,     named numeric vector list components nlpars required numeric vector starting values \tnonlinear model parameters theta optional numeric vector starting values \tcovariance parameters  verbose integer scalar.  > 0 verbose output     generated optimization parameter estimates.      > 1 verbose output generated individual PIRLS steps     (PIRLS aka PRSS, e.g. C++ sources). nAGQ integer scalar - number points per axis     evaluating adaptive Gauss-Hermite approximation     log-likelihood.  Defaults 1, corresponding Laplace     approximation.  Values greater 1 produce greater accuracy     evaluation log-likelihood expense speed.      value zero uses faster less exact form parameter     estimation GLMMs optimizing random effects     fixed-effects coefficients penalized iteratively reweighted     least squares (PIRLS) step. subset optional expression indicating subset rows     data used fit.  can     logical vector, numeric vector indicating observation     numbers included, character vector row names     included.  observations included default. weights optional vector ‘prior weights’ used     fitting process.  NULL numeric vector. na.action function indicates happen     data contain NAs.  default action (na.omit,     inherited ‘factory fresh’ value     getOption(\"na.action\")) strips observations     missing values variables. offset can used specify priori known     component included linear predictor fitting.     NULL numeric vector length equal     number cases.  One offset terms can     included formula instead well, one     specified sum used.  See model.offset. contrasts optional list.  See     contrasts.arg model.matrix.default. devFunOnly logical - return deviance evaluation     function.  Note deviance function operates     variables stored environment, may return     exactly values subsequent calls (results     always within machine tolerance).","code":""},{"path":"/reference/nlmer.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Fitting Nonlinear Mixed-Effects Models — nlmer","text":"Fit nonlinear mixed-effects models, used   population pharmacokinetics.","code":""},{"path":"/reference/nlmer.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Fitting Nonlinear Mixed-Effects Models — nlmer","text":"Adaptive Gauss-Hermite quadrature (nAGQ > 1)   currently implemented nlmer.  Several   methods, simulation prediction new data,   unimplemented lightly tested. method argument used earlier versions lme4   package.  functionality replaced nAGQ argument.","code":""},{"path":"/reference/nlmer.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Fitting Nonlinear Mixed-Effects Models — nlmer","text":"","code":"## nonlinear mixed models --- 3-part formulas --- ## 1. basic nonlinear fit. Use stats::SSlogis for its ## implementation of the 3-parameter logistic curve. ## \"SS\" stands for \"self-starting logistic\", but the ## \"self-starting\" part is not currently used by nlmer ... 'start' is ## necessary startvec <- c(Asym = 200, xmid = 725, scal = 350) (nm1 <- nlmer(circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym|Tree,              Orange, start = startvec)) #> Nonlinear mixed model fit by maximum likelihood  ['nlmerMod'] #> Formula: circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym | Tree #>    Data: Orange #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  273.1438  280.9205 -131.5719  263.1438        30  #> Random effects: #>  Groups   Name Std.Dev. #>  Tree     Asym 31.646   #>  Residual       7.843   #> Number of obs: 35, groups:  Tree, 5 #> Fixed Effects: #>  Asym   xmid   scal   #> 192.1  727.9  348.1   ## 2. re-run with \"quick and dirty\" PIRLS step (nm1a <- update(nm1, nAGQ = 0L)) #> Nonlinear mixed model fit by maximum likelihood  ['nlmerMod'] #> Formula: circumference ~ SSlogis(age, Asym, xmid, scal) ~ Asym | Tree #>    Data: Orange #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  273.1689  280.9456 -131.5844  263.1689        30  #> Random effects: #>  Groups   Name Std.Dev. #>  Tree     Asym 31.63    #>  Residual       7.84    #> Number of obs: 35, groups:  Tree, 5 #> Fixed Effects: #>  Asym   xmid   scal   #> 191.1  722.6  344.2    ## 3. Fit the same model with a user-built function: ## a. Define formula nform <- ~Asym/(1+exp((xmid-input)/scal)) ## b. Use deriv() to construct function: nfun <- deriv(nform,namevec=c(\"Asym\",\"xmid\",\"scal\"),               function.arg=c(\"input\",\"Asym\",\"xmid\",\"scal\")) nm1b <- update(nm1,circumference ~ nfun(age, Asym, xmid, scal)  ~ Asym | Tree)  ## 4. User-built function without using deriv(): ##    derivatives could be computed more efficiently ##    by pre-computing components, but these are essentially ##    the gradients as one would derive them by hand nfun2 <- function(input, Asym, xmid, scal) {     value <- Asym/(1+exp((xmid-input)/scal))     grad <- cbind(Asym=1/(1+exp((xmid-input)/scal)),               xmid=-Asym/(1+exp((xmid-input)/scal))^2*1/scal*                     exp((xmid-input)/scal),               scal=-Asym/(1+exp((xmid-input)/scal))^2*                      -(xmid-input)/scal^2*exp((xmid-input)/scal))     attr(value,\"gradient\") <- grad     value } stopifnot(all.equal(attr(nfun(2,1,3,4),\"gradient\"),                     attr(nfun(2,1,3,4),\"gradient\"))) nm1c <- update(nm1,circumference ~ nfun2(age, Asym, xmid, scal)  ~ Asym | Tree)"},{"path":"/reference/nloptwrap.html","id":null,"dir":"Reference","previous_headings":"","what":"Wrappers for additional optimizers — nloptwrap","title":"Wrappers for additional optimizers — nloptwrap","text":"Wrappers allow use alternative optimizers, NLopt   library (via nloptr) elsewhere, nonlinear optimization stage.","code":""},{"path":"/reference/nloptwrap.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Wrappers for additional optimizers — nloptwrap","text":"","code":"nloptwrap (par, fn, lower, upper, control = list(), ...) nlminbwrap(par, fn, lower, upper, control = list(), ...)"},{"path":"/reference/nloptwrap.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Wrappers for additional optimizers — nloptwrap","text":"par starting parameter vector fn objective function lower, upper numeric vector lower upper bounds. control list control parameters, corresponding     optCtrl = *, e.g., lmerControl().      nloptwrap, see defaultControl ‘Details’. ... additional arguments passed objective function","code":""},{"path":"/reference/nloptwrap.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Wrappers for additional optimizers — nloptwrap","text":"par estimated parameters fval objective function value minimum feval number function evaluations conv convergence code (0 error) message convergence message","code":""},{"path":"/reference/nloptwrap.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Wrappers for additional optimizers — nloptwrap","text":"Using alternative optimizers important trouble-shooting tool mixed models.  wrappers provide convenient access optimizers provided Steven Johnson's NLopt library (via nloptr R package), nlminb optimizer base R.  nlminb also available via optimx package; wrapper provides access nlminb() without need install/link package, without additional post-fitting checks implemented optimx (see examples ). One important difference nloptr-provided   implementation BOBYQA minqa-provided version   accessible via optimizer=\"bobyqa\" provides simpler   access optimization tolerances.  bobyqa provides   rhoend parameter (“[t]smallest value   trust region radius allowed”), nloptr provides   standard set tolerances relative absolute change   objective function parameter values (ftol_rel,   ftol_abs, xtol_rel, xtol_abs). default (empty) control list corresponds following settings: nlminbwrap: control exactly corresponds       nlminb()'s defaults, see . nloptwrap: environment(nloptwrap)$defaultControl       contains defaults, notably algorithm = \"NLOPT_LN_BOBYQA\". nloptr::nloptr.print.options() shows explains many       possible algorithm options.","code":""},{"path":"/reference/nloptwrap.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Wrappers for additional optimizers — nloptwrap","text":"Gabor Grothendieck (nlminbwrap)","code":""},{"path":"/reference/nloptwrap.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Wrappers for additional optimizers — nloptwrap","text":"","code":"library(lme4) ls.str(environment(nloptwrap)) # 'defaultControl' algorithm \"NLOPT_LN_BOBYQA\" #> defaultControl : List of 4 #>  $ algorithm: chr \"NLOPT_LN_BOBYQA\" #>  $ xtol_abs : num 1e-08 #>  $ ftol_abs : num 1e-08 #>  $ maxeval  : num 1e+05 ## Note that  'optimizer =  \"nloptwrap\"' is now the default for lmer() : fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy) ## tighten tolerances fm1B <- update(fm1, control= lmerControl(optCtrl = list(xtol_abs=1e-8, ftol_abs=1e-8))) ## run for longer (no effect in this case) fm1C <- update(fm1,control = lmerControl(optCtrl = list(maxeval=10000)))    logLik(fm1B) - logLik(fm1)  ## small difference in log likelihood #> 'log Lik.' 0 (df=6) c(logLik(fm1C) - logLik(fm1)) ## no difference in LL #> [1] 0 ## Nelder-Mead fm1_nloptr_NM <- update(fm1, control=                   lmerControl(optimizer = \"nloptwrap\",                               optCtrl = list(algorithm = \"NLOPT_LN_NELDERMEAD\"))) ## other nlOpt algorithm options include NLOPT_LN_COBYLA, NLOPT_LN_SBPLX, see if(interactive())   nloptr::nloptr.print.options()  fm1_nlminb <- update(fm1, control=lmerControl(optimizer = \"nlminbwrap\")) if (require(optimx)) { ## the 'optimx'-based nlminb :   fm1_nlminb2 <- update(fm1, control=                 lmerControl(optimizer = \"optimx\",                             optCtrl = list(method=\"nlminb\", kkt=FALSE)))   cat(\"Likelihood difference (typically zero):  \",       c(logLik(fm1_nlminb) - logLik(fm1_nlminb2)), \"\\n\") } #> Likelihood difference (typically zero):   0"},{"path":"/reference/plot.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Diagnostic Plots for 'merMod' Fits — plot.merMod","title":"Diagnostic Plots for 'merMod' Fits — plot.merMod","text":"diagnostic plots merMod fits","code":""},{"path":"/reference/plot.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Diagnostic Plots for 'merMod' Fits — plot.merMod","text":"","code":"# S3 method for class 'merMod' plot(x,      form = resid(., type = \"pearson\") ~ fitted(.), abline,      id = NULL, idLabels = NULL, grid, ...) # S3 method for class 'merMod' qqmath(x, data = NULL, id = NULL, idLabels = NULL, ...)"},{"path":"/reference/plot.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Diagnostic Plots for 'merMod' Fits — plot.merMod","text":"x fitted [ng]lmer model form optional formula specifying desired   type plot. variable present original data   frame used obtain x can referenced.   addition, x can referenced   formula using symbol \".\". Conditional   expressions right | operator can   used define separate panels lattice display.   Default resid(., type = \"pearson\") ~ fitted(.),   corresponding plot standardized residuals   versus fitted values. abline optional numeric value, numeric   vector length two. given single value,   horizontal line added plot   coordinate; else, given vector, values   used intercept slope line added   plot. missing, lines added plot. id optional numeric value, one-sided   formula. given value, used   significance level two-sided outlier test   standardized, normalized residuals. Observations   absolute standardized (normalized) residuals greater   \\(1-value/2\\) quantile standard normal   distribution identified plot using   idLabels. given one-sided formula,   right hand side must evaluate logical, integer,   character vector used identify observations   plot. missing, observations identified. idLabels optional vector, one-sided formula.   given vector, converted character   used label observations identified according   id. given vector, converted   character used label observations identified   according id. given one-sided formula,   right hand side must evaluate vector   converted character used label identified   observations. Default interaction   grouping variables data frame.  special   formula idLabels=~.obs label observations   according observation number. data ignored: required S3 method compatibility grid optional logical value indicating whether   grid added plot. Default depends   type lattice plot used: xyplot defaults   TRUE, else defaults FALSE. ... optional arguments passed lattice   plot function.","code":""},{"path":"/reference/plot.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Diagnostic Plots for 'merMod' Fits — plot.merMod","text":"Diagnostic plots linear mixed-effects fit   obtained. form argument gives considerable   flexibility type plot specification.   conditioning expression (right side |   operator) always implies different panels used   level conditioning factor, according   lattice display. form one-sided formula,   histograms variable right hand side   formula, | operator, displayed (  lattice function histogram used).   form two-sided left right hand   side variables numeric, scatter plots displayed   (lattice function xyplot used). Finally,   form two-sided left side variable   factor, box-plots right hand side variable   levels left hand side variable displayed   (lattice function bwplot used). qqmath produces Q-Q plot residuals   (see qqmath.ranef.mer Q-Q plots   conditional mode values).","code":""},{"path":[]},{"path":"/reference/plot.merMod.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Diagnostic Plots for 'merMod' Fits — plot.merMod","text":"original version nlme package Jose Pinheiro   Douglas Bates.","code":""},{"path":"/reference/plot.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Diagnostic Plots for 'merMod' Fits — plot.merMod","text":"","code":"data(Orthodont,package=\"nlme\") fm1 <- lmer(distance ~ age + (age|Subject), data=Orthodont) ## standardized residuals versus fitted values by gender plot(fm1, resid(., scaled=TRUE) ~ fitted(.) | Sex, abline = 0)  ## box-plots of residuals by Subject plot(fm1, Subject ~ resid(., scaled=TRUE))  ## observed versus fitted values by Subject plot(fm1, distance ~ fitted(.) | Subject, abline = c(0,1))  ## residuals by age, separated by Subject plot(fm1, resid(., scaled=TRUE) ~ age | Sex, abline = 0)  ## scale-location plot, with red smoothed line scale_loc_plot <- function(m, line.col = \"red\", line.lty = 1,                            line.lwd = 2) {   plot(fm1, sqrt(abs(resid(.))) ~ fitted(.),        type = c(\"p\", \"smooth\"),        par.settings = list(plot.line =                              list(alpha=1, col = line.col,                                   lty = line.lty, lwd = line.lwd))) } scale_loc_plot(fm1)  ## Q-Q plot lattice::qqmath(fm1, id=0.05)  ggp.there <- \"package:ggplot2\" %in% search() if (ggp.there || require(\"ggplot2\")) {     ## we can create the same plots using ggplot2 and the fortify() function     fm1F <- fortify.merMod(fm1)     ggplot(fm1F, aes(.fitted, .resid)) + geom_point(colour=\"blue\") +            facet_grid(. ~ Sex) + geom_hline(yintercept=0)     ## note: Subjects are ordered by mean distance     ggplot(fm1F, aes(Subject,.resid)) + geom_boxplot() + coord_flip()     ggplot(fm1F, aes(.fitted,distance)) + geom_point(colour=\"blue\") +         facet_wrap(~Subject) +geom_abline(intercept=0,slope=1)     ggplot(fm1F, aes(age,.resid)) + geom_point(colour=\"blue\") + facet_grid(.~Sex) +         geom_hline(yintercept=0)+ geom_line(aes(group=Subject),alpha=0.4) +         geom_smooth(method=\"loess\")     ## (warnings about loess are due to having only 4 unique x values)     if(!ggp.there) detach(\"package:ggplot2\") } #> Loading required package: ggplot2"},{"path":"/reference/plots.thpr.html","id":null,"dir":"Reference","previous_headings":"","what":"Mixed-Effects Profile Plots (Regular / Density / Pairs) — plots.thpr","title":"Mixed-Effects Profile Plots (Regular / Density / Pairs) — plots.thpr","text":"Xyplot, Densityplot, Pairs plot methods mixed-effects model   profile. xyplot() draws “zeta diagrams”, also visualizing   confidence intervals asymmetry. densityplot() draws profile densities. splom() draws profile pairs plots.  Contours   marginal two-dimensional regions (.e. using df = 2).","code":""},{"path":"/reference/plots.thpr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Mixed-Effects Profile Plots (Regular / Density / Pairs) — plots.thpr","text":"","code":"# S3 method for class 'thpr' xyplot(x, data = NULL,        levels = sqrt(qchisq(pmax.int(0, pmin.int(1, conf)), df = 1)),        conf = c(50, 80, 90, 95, 99)/100,        absVal = FALSE, scales=NULL,        which = 1:nptot, ...)  # S3 method for class 'thpr' densityplot(x, data, npts = 201, upper = 0.999, ...)  # S3 method for class 'thpr' splom(x, data,       levels = sqrt(qchisq(pmax.int(0, pmin.int(1, conf)), 2)),       conf = c(50, 80, 90, 95, 99)/100,  which = 1:nptot,       draw.lower = TRUE, draw.upper = TRUE, ...)"},{"path":"/reference/plots.thpr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Mixed-Effects Profile Plots (Regular / Density / Pairs) — plots.thpr","text":"x mixed-effects profile, .e., class \"thpr\",     typically resulting profile(fm) fm     fitted model lmer (generalizations). data unused - compatibility generic. npts number points use densityplot(). upper number \\((0,1)\\) specify upper (lower)       boundaries +/- qnorm(upper). levels contour levels shown; usually     derived conf. conf numeric vector confidence levels     shown contours. absVal logical indicating abs(.)olute values       plotted, often preferred confidence interval       visualization. scales plotting options passed xyplot integer character vector indicating parameters     profile: default parameters (see     profile-methods     details). draw.lower (logical) draw lower-triangle (zeta scale) panels? draw.upper (logical) draw upper-triangle (standard dev/cor scale) panels? ... arguments passed xyplot,     densityplot, splom package     lattice, respectively.","code":""},{"path":[]},{"path":"/reference/plots.thpr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Mixed-Effects Profile Plots (Regular / Density / Pairs) — plots.thpr","text":"xyplot: density plot, \"trellis\" object (lattice package)       print()ed produces plots current       graphic device. densityplot: density plot, \"trellis\" object, see . splom: pairs plot, aka scatterplot       matrix, \"trellis\" object, see .","code":""},{"path":"/reference/plots.thpr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Mixed-Effects Profile Plots (Regular / Density / Pairs) — plots.thpr","text":"","code":"## see   example(\"profile.merMod\")"},{"path":"/reference/predict.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Predictions from a model at new data values — predict.merMod","title":"Predictions from a model at new data values — predict.merMod","text":"predict method merMod   objects, .e. results lmer(), glmer(), etc.","code":""},{"path":"/reference/predict.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predictions from a model at new data values — predict.merMod","text":"","code":"# S3 method for class 'merMod' predict(object, newdata = NULL, newparams = NULL,     re.form = NULL,     random.only=FALSE, terms = NULL,     type = c(\"link\", \"response\"), allow.new.levels = FALSE,     na.action = na.pass,     se.fit = FALSE,     ...)"},{"path":"/reference/predict.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predictions from a model at new data values — predict.merMod","text":"object fitted model object newdata data frame evaluate     predictions. newparams new parameters use evaluating predictions,     specified start parameter lmer     glmer – list components theta /    (GLMMs) beta. re.form (formula, NULL, NA) specify random effects condition predicting.  NULL,     include random effects; NA ~0,     include random effects. random.(logical) ignore fixed effects, making predictions     using random effects? terms terms object - unused present. type character string - either \"link\", default,     \"response\" indicating type prediction object returned. allow.new.levels logical new levels (NA values)     newdata allowed. FALSE (default), new values     newdata trigger error; TRUE, prediction     use unconditional (population-level) values data     previously unobserved levels (NAs). na.action function determining done     missing values fixed effects newdata.     default predict NA: see na.pass. se.fit (Experimental) logical value indicating whether standard errors included . Default FALSE. ... optional additional parameters.  None used present.","code":""},{"path":"/reference/predict.merMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predictions from a model at new data values — predict.merMod","text":"numeric vector predicted values","code":""},{"path":"/reference/predict.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Predictions from a model at new data values — predict.merMod","text":"random effects included re.form     (.e. ~0 NA),     newdata must contain columns     corresponding grouping variables     random effects used original model, even     used prediction; however, can safely set NA     case. option computing standard errors     predictions difficult define     efficient method incorporates uncertainty     variance parameters; recommend bootMer     task.","code":""},{"path":"/reference/predict.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predictions from a model at new data values — predict.merMod","text":"","code":"(gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 |herd), cbpp, binomial)) #> Generalized linear mixed model fit by maximum likelihood (Laplace #>   Approximation) [glmerMod] #>  Family: binomial  ( logit ) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) #>    Data: cbpp #>       AIC       BIC    logLik -2*log(L)  df.resid  #>  194.0531  204.1799  -92.0266  184.0531        51  #> Random effects: #>  Groups Name        Std.Dev. #>  herd   (Intercept) 0.6421   #> Number of obs: 56, groups:  herd, 15 #> Fixed Effects: #> (Intercept)      period2      period3      period4   #>     -1.3983      -0.9919      -1.1282      -1.5797   str(p0 <- predict(gm1))            # fitted values #>  Named num [1:56] -0.809 -1.801 -1.937 -2.388 -1.697 ... #>  - attr(*, \"names\")= chr [1:56] \"1\" \"2\" \"3\" \"4\" ... str(p1 <- predict(gm1,re.form=NA))  # fitted values, unconditional (level-0) #>  Named num [1:56] -1.4 -2.39 -2.53 -2.98 -1.4 ... #>  - attr(*, \"names\")= chr [1:56] \"1\" \"2\" \"3\" \"4\" ... newdata <- with(cbpp, expand.grid(period=unique(period), herd=unique(herd))) str(p2 <- predict(gm1,newdata))    # new data, all RE #>  Named num [1:60] -0.809 -1.801 -1.937 -2.388 -1.697 ... #>  - attr(*, \"names\")= chr [1:60] \"1\" \"2\" \"3\" \"4\" ... str(p3 <- predict(gm1,newdata,re.form=NA)) # new data, level-0 #>  Named num [1:60] -1.4 -2.39 -2.53 -2.98 -1.4 ... #>  - attr(*, \"names\")= chr [1:60] \"1\" \"2\" \"3\" \"4\" ... str(p4 <- predict(gm1,newdata,re.form= ~(1|herd))) # explicitly specify RE #>  Named num [1:60] -0.809 -1.801 -1.937 -2.388 -1.697 ... #>  - attr(*, \"names\")= chr [1:60] \"1\" \"2\" \"3\" \"4\" ... stopifnot(identical(p2, p4)) #> boundary (singular) fit: see help('isSingular')"},{"path":"/reference/profile-methods.html","id":null,"dir":"Reference","previous_headings":"","what":"Profile method for merMod objects — profile-methods","title":"Profile method for merMod objects — profile-methods","text":"Methods profile() [ng]lmer fitted   models. log() method flexible logProf()   utility transform lmer profile one logarithms standard deviations   used, varianceProf converts   standard-deviation variance scale; see Details.","code":""},{"path":"/reference/profile-methods.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Profile method for merMod objects — profile-methods","text":"","code":"# S3 method for class 'merMod' profile(fitted, which = NULL, alphamax = 0.01,   maxpts = 100, delta = NULL,     delta.cutoff = 1/8, verbose = 0, devtol = 1e-09,     devmatchtol = 1e-5,     maxmult = 10, startmethod = \"prev\", optimizer = NULL,     control=NULL, signames = TRUE,     parallel = c(\"no\", \"multicore\", \"snow\"),     ncpus = getOption(\"profile.ncpus\", 1L), cl = NULL,     prof.scale = c(\"sdcor\",\"varcov\"),     ...) # S3 method for class 'thpr' as.data.frame (x, ...) # S3 method for class 'thpr' log(x, base = exp(1)) logProf(x, base = exp(1), ranef = TRUE,            sigIni = if(ranef) \"sig\" else \"sigma\") varianceProf(x, ranef = TRUE)"},{"path":"/reference/profile-methods.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Profile method for merMod objects — profile-methods","text":"fitted fitted model, e.g., result lmer(..). NULL value,     integer character vector indicating parameters     profile: default (NULL) parameters.  integer, .e., indexing,     parameters ordered follows: (1) random effects (theta) parameters; ordered \tgetME(.,\"theta\"), .e., lower triangle \tmatrix standard deviations diagonal correlations \tdiagonal. (2) residual standard deviation (scale parameter GLMMs         appropriate). (3) fixed effect (beta) parameters. Alternatively, may character, containing     \"beta_\" \"theta_\" denoting fixed random     effects parameters, respectively, also containing parameter     names, \".sigma\" \"(Intercept)\". alphamax number \\((0,1)\\), 1 - alphamax     maximum alpha value likelihood ratio confidence     regions; used establish range values profiled. maxpts maximum number points (direction,     parameter) evaluate attempting construct profile. delta stepping scale deciding next point profile.     code uses local derivative profile current     step establish change focal parameter lead     step delta square-root-deviance scale.     NULL, delta.cutoff parameter used     determine stepping scale. delta.cutoff stepping scale (see delta)     expressed fraction     target maximum value profile square-root-deviance     scale.  Thus delta.cutoff setting 1/n     lead profile approximately 2*n calculated points     parameter (.e., n points direction,     estimate parameter). verbose level output internal calculations. devtol tolerance fitted deviances less     baseline (supposedly minimum) deviance. devmatchtol tolerance match original deviance     computation value returned auxiliary deviance function maxmult maximum multiplier original step size allowed,     defaults 10. startmethod method picking starting conditions     optimization (STUB). optimizer (character function) optimizer use (see     lmer details); default use optimizer     original model fit. control list options controlling     profiling (see lmerControl): default use     control settings original model fit. signames logical indicating abbreviated names form     .sigNN used; otherwise, names meaningful     (longer) form (sd|cor)_(effects)|(group).  Note     code profile transformations (e.g., log()     varianceProf) depends signames==TRUE. ... potential arguments various methods. x object class thpr (.e., output     profile) base base logarithm.  Defaults natural     logarithms. ranef logical indicating sigmas random effects     log() transformed well.  false,     \\(\\sigma\\) (standard deviation errors) transformed. sigIni character string specifying initial part     sigma parameters log transformed. parallel type parallel operation used ().     missing,     default taken option \"profile.parallel\" (    set, \"\"). ncpus integer: number processes used parallel operation:     typically one choose number available CPUs. cl optional parallel snow cluster use     parallel = \"snow\".  supplied, cluster     local machine created duration profile     call. prof.scale whether profile standard     deviation-correlation scale (\"sdcor\")     variance-covariance scale (\"varcov\")","code":""},{"path":"/reference/profile-methods.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Profile method for merMod objects — profile-methods","text":"profile(<merMod>) returns object S3 class   \"thpr\",    data.frame-like.   Notable methods profile object   confint(), returns   confidence intervals based profile,   three plotting methods   (require lattice package),   xyplot, densityplot,   splom. addition,   log() (see ) .data.frame()   methods can transform \"thpr\" objects useful ways.","code":""},{"path":"/reference/profile-methods.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Profile method for merMod objects — profile-methods","text":"log method flexible logProf()   function transform profile one \\(\\log(\\sigma)\\)   used instead \\(\\sigma\\).   default sigmas including standard deviations random   effects transformed .e., methods return profile   .sigNN   parameters replaced .lsigNN.  ranef false,   \".sigma\", standard deviation errors, transformed   (never zero, whereas random effect standard   deviations (.sigNN) can reasonably zero).      forward backward splines log-transformed parameters   recalculated.   Note correlation parameters handled sensibly present   (.e., logged rather taking applicable   transformation arc-hyperbolic tangent,   atanh(x)=\\(\\log((1+x)/(1-x))/2\\)). varianceProf function works similarly, including   non-sensibility correlation parameters, squaring   parameter values, changing names appending sq   appropriately (e.g. .sigNN .sigsqNN).   Setting prof.scale=\"varcov\" original   profile() call computationally   intensive, correct, way compute confidence   intervals covariance parameters. Methods function profile (package   stats), profiling (fitted) mixed effect models.","code":""},{"path":[]},{"path":"/reference/profile-methods.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Profile method for merMod objects — profile-methods","text":"","code":"fm01ML <- lmer(Yield ~ 1|Batch, Dyestuff, REML = FALSE) system.time(   tpr  <- profile(fm01ML, optimizer=\"Nelder_Mead\", which=\"beta_\") )## fast; as only *one* beta parameter is profiled over -> 0.09s (2022) #>    user  system elapsed  #>   0.099   0.000   0.099   ## full profiling (default which means 'all') needs longer: system.time( tpr  <- profile(fm01ML, signames=FALSE)) #>    user  system elapsed  #>   0.250   0.002   0.252  ## ~ 0.26s (2022) + possible warning about convergence (confint(tpr) -> CIpr) #>                           2.5 %     97.5 % #> sd_(Intercept)|Batch   12.19854   84.06305 #> sigma                  38.22998   67.65770 #> (Intercept)          1486.45150 1568.54849 # too much precision (etc). but just FYI:  trgt <- array(c(12.19854, 38.22998, 1486.451,                  84.06305, 67.6577,  1568.548), dim = 3:2)  stopifnot(all.equal(trgt, unname(CIpr), tol = .0001)) # had 3.1e-7  if (interactive()) {  library(\"lattice\")  xyplot(tpr)  xyplot(tpr, absVal=TRUE) # easier to see conf.int.s (and check symmetry)  xyplot(tpr, conf = c(0.95, 0.99), # (instead of all five 50, 80,...)         main = \"95% and 99% profile() intervals\")  xyplot(logProf(tpr, ranef=FALSE),         main = expression(\"lmer profile()s\"~~ log(sigma)*\" (only log)\"))  densityplot(tpr, main=\"densityplot( profile(lmer(..)) )\")  densityplot(varianceProf(tpr), main=\" varianceProf( profile(lmer(..)) )\")  splom(tpr)  splom(logProf(tpr, ranef=FALSE))  doMore <- lme4:::testLevel() > 2   if(doMore) { ## not typically, for time constraint reasons    ## Batch and residual variance only    system.time(tpr2 <- profile(fm01ML, which=1:2)) # , optimizer=\"Nelder_Mead\" gives warning    print( xyplot(tpr2) )    print( xyplot(log(tpr2)) )# log(sigma) is better    print( xyplot(logProf(tpr2, ranef=FALSE)) )     ## GLMM example    gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),                data = cbpp, family = binomial)    ## running ~ 10 seconds on a modern machine {-> \"verbose\" while you wait}:    print( system.time(pr4 <- profile(gm1, verbose=TRUE)) )    print( xyplot(pr4, layout=c(5,1), as.table=TRUE) )    print( xyplot(log(pr4), absVal=TRUE) ) # log(sigma_1)    print( splom(pr4) )    print( system.time( # quicker: only sig01 and one fixed effect        pr2 <- profile(gm1, which=c(\"theta_\", \"period2\"))))    print( confint(pr2) )    ## delta..: higher underlying resolution, only for 'sigma_1':    print( system.time(        pr4.hr <- profile(gm1, which=\"theta_\", delta.cutoff=1/16)))    print( xyplot(pr4.hr) )  } } # only if interactive()"},{"path":"/reference/pvalues.html","id":null,"dir":"Reference","previous_headings":"","what":"Getting p-values for fitted models — pvalues","title":"Getting p-values for fitted models — pvalues","text":"One frequently asked questions   lme4 \"calculate p-values estimated   parameters?\" Previous versions lme4 provided   mcmcsamp function, efficiently generated   Markov chain Monte Carlo sample posterior   distribution parameters, assuming flat (scaled   likelihood) priors. Due difficulty constructing   version mcmcsamp reliable even   cases estimated random effect variances   near zero (e.g.   https://stat.ethz.ch/pipermail/r-sig-mixed-models/2009q4/003115.html),   mcmcsamp withdrawn (precisely,   updated work lme4 versions >=1.0.0). Many users, including users aovlmer.fnc function   languageR package relies mcmcsamp,   deeply disappointed lacuna. Users need p-values   variety options. list , methods marked MC   provide explicit model comparisons; CI denotes confidence   intervals; P denotes parameter-level sequential tests   effects model. starred (*) suggestions provide   finite-size corrections (important number groups <50);   marked (+) support GLMMs well LMMs.  likelihood ratio tests via anova drop1 (MC,+) profile confidence intervals via profile.merMod       confint.merMod (CI,+) parametric bootstrap confidence intervals model comparisons via       bootMer (PBmodcomp       pbkrtest package) (MC/CI,*,+) random effects, simulation tests via RLRsim package       (MC,*) fixed effects, F tests via Kenward-Roger       approximation using KRmodcomp       pbkrtest package (MC,*) car::Anova       lmerTest::anova provide wrappers       Kenward-Roger-corrected tests using pbkrtest:       lmerTest::anova also provides t tests via       Satterthwaite approximation (P,*) afex::mixed another wrapper       pbkrtest anova providing       \"Type 3\" tests effects (P,*,+) arm::sim, bootMer, can used   compute confidence intervals predictions. glmer models, summary output provides p-values   based asymptotic Wald tests (P); standard practice   generalized linear models, tests make assumptions   shape log-likelihood surface accuracy   chi-squared approximation differences log-likelihoods. else fails, forget keep p-values   perspective:   https://phdcomics.com/comics/archive.php?comicid=905","code":""},{"path":"/reference/ranef.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract the modes of the random effects — ranef","title":"Extract the modes of the random effects — ranef","text":"generic function extract conditional modes   random effects fitted model object.    linear mixed models conditional modes random   effects also conditional means.","code":""},{"path":"/reference/ranef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract the modes of the random effects — ranef","text":"","code":"# S3 method for class 'merMod' ranef (object, condVar = TRUE,       drop = FALSE, whichel = names(ans), postVar = FALSE, ...) # S3 method for class 'ranef.mer' dotplot (x, data, main = TRUE, transf = I, level = 0.95, ...) # S3 method for class 'ranef.mer' qqmath (x, data, main = TRUE, level = 0.95, ...) # S3 method for class 'ranef.mer' as.data.frame (x, ...)"},{"path":"/reference/ranef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract the modes of the random effects — ranef","text":"object object class fitted models     random effects, typically     merMod object. condVar logical argument indicating     conditional variance-covariance matrices random effects     added attribute. drop components return value data frames     single column, usually column called     ‘(Intercept)’, returned named     vectors instead? whichel character vector names     grouping factors random effects     returned. postVar (deprecated) synonym condVar x random-effects object (class ranef.mer)     produced ranef main include main title, indicating grouping factor,     sub-plot? transf transformation random effects: example,     exp plotting parameters (generalized)     logistic regression odds rather log-odds scale data argument required dotplot     qqmath generic methods, actually used. level confidence level confidence intervals ... methods generic functions     require additional arguments.","code":""},{"path":"/reference/ranef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract the modes of the random effects — ranef","text":"ranef:       object class ranef.mer composed       list data frames, one grouping factor       random effects.  number rows data frame       number levels grouping factor.        number columns dimension random effect       associated level factor.      condVar TRUE data frames       attribute called \"postVar\". \tsingle random-effects term given grouping factor, \tattribute \tthree-dimensional array symmetric faces; face \tcontains variance-covariance matrix particular \tlevel grouping factor. one random-effects term \tgiven grouping factor (e.g. (1|f) + (0+x|f)), \tattribute list arrays described , \tone term. .data.frame:      function converts random effects \"long format\"       data frame columns grpvar grouping variable term random-effects term, e.g. “(Intercept)” \t  “Days” grp level grouping variable (e.g., Subject) condval value conditional mean condsd conditional standard deviation","code":""},{"path":"/reference/ranef.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract the modes of the random effects — ranef","text":"grouping factor k levels j random effects   per level ith component list returned   ranef data frame k rows j columns.   condVar TRUE \"postVar\"   attribute array dimension j j k (list   arrays).  kth   face array positive definite symmetric j   j matrix.  one grouping factor   model variance-covariance matrix entire   random effects vector, conditional estimates   model parameters data, block   diagonal; j j matrix kth diagonal   block.  multiple grouping factors faces   \"postVar\" attributes still diagonal blocks   conditional variance-covariance matrix   matrix longer block diagonal.","code":""},{"path":"/reference/ranef.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Extract the modes of the random effects — ranef","text":"produce (list ) “caterpillar plots” random   effects apply dotplot   result call ranef condVar =     TRUE; qqmath generate   list Q-Q plots.","code":""},{"path":"/reference/ranef.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract the modes of the random effects — ranef","text":"","code":"library(lattice) ## for dotplot, qqmath fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy) fm2 <- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy) fm3 <- lmer(diameter ~ (1|plate) + (1|sample), Penicillin) ranef(fm1) #> $Subject #>     (Intercept)        Days #> 308   2.2585509   9.1989758 #> 309 -40.3987381  -8.6196806 #> 310 -38.9604090  -5.4488565 #> 330  23.6906196  -4.8143503 #> 331  22.2603126  -3.0699116 #> 332   9.0395679  -0.2721770 #> 333  16.8405086  -0.2236361 #> 334  -7.2326151   1.0745816 #> 335  -0.3336684 -10.7521652 #> 337  34.8904868   8.6282652 #> 349 -25.2102286   1.1734322 #> 350 -13.0700342   6.6142178 #> 351   4.5778642  -3.0152621 #> 352  20.8636782   3.5360011 #> 369   3.2754656   0.8722149 #> 370 -25.6129993   4.8224850 #> 371   0.8070461  -0.9881562 #> 372  12.3145921   1.2840221 #>  #> with conditional variances for “Subject”  str(rr1 <- ranef(fm1)) #> List of 1 #>  $ Subject:'data.frame':\t18 obs. of  2 variables: #>   ..$ (Intercept): num [1:18] 2.26 -40.4 -38.96 23.69 22.26 ... #>   ..$ Days       : num [1:18] 9.2 -8.62 -5.45 -4.81 -3.07 ... #>   ..- attr(*, \"postVar\")= num [1:2, 1:2, 1:18] 145.71 -21.44 -21.44 5.31 145.71 ... #>  - attr(*, \"class\")= chr \"ranef.mer\" dotplot(rr1)  ## default #> $Subject  #>  qqmath(rr1) #> $Subject  #>  ## specify free scales in order to make Day effects more visible dotplot(rr1,scales = list(x = list(relation = 'free')))[[\"Subject\"]]  ## plot options: ... can specify appearance of vertical lines with ## lty.v, col.line.v, lwd.v, etc.. dotplot(rr1, lty = 3, lty.v = 2, col.line.v = \"purple\",         col = \"red\", col.line.h = \"gray\") #> $Subject  #>  ranef(fm2) #> $Subject #>     (Intercept)        Days #> 308   1.5126648   9.3234970 #> 309 -40.3738728  -8.5991757 #> 310 -39.1810279  -5.3877944 #> 330  24.5189244  -4.9686503 #> 331  22.9144470  -3.1939378 #> 332   9.2219759  -0.3084939 #> 333  17.1561243  -0.2872078 #> 334  -7.4517382   1.1159911 #> 335   0.5787623 -10.9059754 #> 337  34.7679030   8.6276228 #> 349 -25.7543312   1.2806892 #> 350 -13.8650598   6.7564064 #> 351   4.9159912  -3.0751356 #> 352  20.9290332   3.5122123 #> 369   3.2586448   0.8730514 #> 370 -26.4758468   4.9837910 #> 371   0.9056510  -1.0052938 #> 372  12.4217547   1.2584037 #>  #> with conditional variances for “Subject”  op <- options(digits = 4) ranef(fm3, drop = TRUE) #> $plate #>        a        b        c        d        e        f        g        h  #>  0.80455  0.80455  0.18167  0.33739  0.02595 -0.44120 -1.37552  0.80455  #>        i        j        k        l        m        n        o        p  #> -0.75264 -0.75264  0.96027  0.49311  1.42742  0.49311  0.96027  0.02595  #>        q        r        s        t        u        v        w        x  #> -0.28548 -0.28548 -1.37552  0.96027 -0.90836 -0.28548 -0.59692 -1.21980  #> attr(,\"postVar\") #>  [1] 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 #> [10] 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 #> [19] 0.07364 0.07364 0.07364 0.07364 0.07364 0.07364 #>  #> $sample #>        A        B        C        D        E        F  #>  2.18706 -1.01048  1.93790 -0.09689 -0.01384 -3.00374  #> attr(,\"postVar\") #> [1] 0.04087 0.04087 0.04087 0.04087 0.04087 0.04087 #>  #> with conditional variances for “plate” “sample”  options(op) ## as.data.frame() provides RE's and conditional standard deviations: str(dd <- as.data.frame(rr1)) #> 'data.frame':\t36 obs. of  5 variables: #>  $ grpvar : chr  \"Subject\" \"Subject\" \"Subject\" \"Subject\" ... #>  $ term   : Factor w/ 2 levels \"(Intercept)\",..: 1 1 1 1 1 1 1 1 1 1 ... #>  $ grp    : Factor w/ 18 levels \"309\",\"310\",\"370\",..: 9 1 2 17 16 12 14 6 7 18 ... #>  $ condval: num  2.26 -40.4 -38.96 23.69 22.26 ... #>  $ condsd : num  12.1 12.1 12.1 12.1 12.1 ... if (require(ggplot2)) {     ggplot(dd, aes(y=grp,x=condval)) +         geom_point() + facet_wrap(~term,scales=\"free_x\") +         geom_errorbarh(aes(xmin=condval -2*condsd,                            xmax=condval +2*condsd), height=0) } #> Loading required package: ggplot2"},{"path":"/reference/rePCA.html","id":null,"dir":"Reference","previous_headings":"","what":"PCA of random-effects covariance matrix — rePCA","title":"PCA of random-effects covariance matrix — rePCA","text":"PCA random-effects variance-covariance estimates","code":""},{"path":"/reference/rePCA.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"PCA of random-effects covariance matrix — rePCA","text":"","code":"rePCA(x)"},{"path":"/reference/rePCA.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"PCA of random-effects covariance matrix — rePCA","text":"x merMod object","code":""},{"path":"/reference/rePCA.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"PCA of random-effects covariance matrix — rePCA","text":"prcomplist object","code":""},{"path":"/reference/rePCA.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"PCA of random-effects covariance matrix — rePCA","text":"Perform Principal Components Analysis (PCA) random-effects   variance-covariance estimates fitted mixed-effects model.   allows user detect diagnose overfitting problems   random effects model (see Bates et al. 2015 details).","code":""},{"path":"/reference/rePCA.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"PCA of random-effects covariance matrix — rePCA","text":"Douglas Bates","code":""},{"path":[]},{"path":"/reference/rePCA.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"PCA of random-effects covariance matrix — rePCA","text":"Douglas Bates, Reinhold Kliegl, Shravan Vasishth, Harald Baayen.     Parsimonious Mixed Models. arXiv:1506.04967 [stat], June 2015. arXiv:     1506.04967.","code":""},{"path":"/reference/rePCA.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"PCA of random-effects covariance matrix — rePCA","text":"","code":"fm1 <- lmer(Reaction~Days+(Days|Subject), sleepstudy)   rePCA(fm1) #> $Subject #> Standard deviations (1, .., p=2): #> [1] 0.9668680 0.2308798 #>  #> Rotation (n x k) = (2 x 2): #>             [,1]        [,2] #> [1,] -0.99986158 -0.01663769 #> [2,] -0.01663769  0.99986158 #>  #> attr(,\"class\") #> [1] \"prcomplist\""},{"path":"/reference/rePos-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class ","title":"Class ","text":"reference class determining positions   random-effects vector correspond particular   random-effects terms model formula","code":""},{"path":"/reference/rePos-class.html","id":"extends","dir":"Reference","previous_headings":"","what":"Extends","title":"Class ","text":"reference classes extend inherit methods   \"envRefClass\".","code":""},{"path":"/reference/rePos-class.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Class ","text":"","code":"showClass(\"rePos\") #> Class \"rePos\" [package \"lme4\"] #>  #> Slots: #>                    #> Name:       .xData #> Class: environment #>  #> Extends:  #> Class \"envRefClass\", directly #> Class \".environment\", by class \"envRefClass\", distance 2 #> Class \"refClass\", by class \"envRefClass\", distance 2 #> Class \"environment\", by class \"envRefClass\", distance 3, with explicit coerce #> Class \"refObject\", by class \"envRefClass\", distance 3"},{"path":"/reference/rePos.html","id":null,"dir":"Reference","previous_headings":"","what":"Generator object for the rePos (random-effects positions) class — rePos","title":"Generator object for the rePos (random-effects positions) class — rePos","text":"generator object rePos   class used determine positions orders   random effects associated particular random-effects   terms model.","code":""},{"path":"/reference/rePos.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generator object for the rePos (random-effects positions) class — rePos","text":"","code":"rePos(...)"},{"path":"/reference/rePos.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generator object for the rePos (random-effects positions) class — rePos","text":"... Argument list (see Note).","code":""},{"path":"/reference/rePos.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Generator object for the rePos (random-effects positions) class — rePos","text":"Arguments new methods must named   arguments. mer, object class   \"merMod\",   required/expected argument.","code":""},{"path":"/reference/rePos.html","id":"methods","dir":"Reference","previous_headings":"","what":"Methods","title":"Generator object for the rePos (random-effects positions) class — rePos","text":"new(mer=mer) Create new   rePos object.","code":""},{"path":[]},{"path":"/reference/refit.html","id":null,"dir":"Reference","previous_headings":"","what":"Refit a (merMod) Model with a Different Response — refit","title":"Refit a (merMod) Model with a Different Response — refit","text":"Refit model, possibly modifying response vector.     makes use model representation directly goes    optimization.","code":""},{"path":"/reference/refit.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refit a (merMod) Model with a Different Response — refit","text":"","code":"refit(object, newresp, ...)  # S3 method for class 'merMod' refit(object, newresp = NULL, newweights = NULL,       rename.response = FALSE,       maxit = 100, ...)"},{"path":"/reference/refit.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refit a (merMod) Model with a Different Response — refit","text":"object fitted model, usually class     lmerMod, refit new response. newresp (optional) numeric vector providing new     response, length original response (see     Details information NA handling).  May also data     frame single numeric column, e.g. produced     simulate(object). newweights (optional) numeric vector new weights rename.response refitting model, name     response variable formula model frame replaced     name newresp? maxit scalar integer, currently GLMMs: maximal     number Pwrss update iterations. ... optional additional parameters.  merMod     method, control.","code":""},{"path":"/reference/refit.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refit a (merMod) Model with a Different Response — refit","text":"object like x, fit different response vector \\(Y\\).","code":""},{"path":[]},{"path":"/reference/refit.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refit a (merMod) Model with a Different Response — refit","text":"Refit model, possibly modifying response vector.    done using update(), refit()   approach faster bypasses creation   model representation goes directly optimization step. Setting rename.response = TRUE may necessary one   wants operations (update) fitted   model.  However, refitted model still slightly different   equivalent model fitted via update; particular,   terms component updated reflect new response   variable, different name original. newresp na.action attribute,   assumed NA values already removed numeric   vector; allows results simulate(object)   used even original response vector contained NA values.   Otherwise, length newresp must   original length response.","code":""},{"path":"/reference/refit.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Refit a (merMod) Model with a Different Response — refit","text":"","code":"## Ex. 1: using refit() to fit each column in a matrix of responses ------- set.seed(101) Y <- matrix(rnorm(1000),ncol=10) ## combine first column of responses with predictor variables d <- data.frame(y=Y[,1],x=rnorm(100),f=rep(1:10,10)) ## (use check.conv.grad=\"ignore\" to disable convergence checks because we ##  are using a fake example) ## fit first response fit1 <- lmer(y ~ x+(1|f), data = d,              control= lmerControl(check.conv.grad=\"ignore\",                                   check.conv.hess=\"ignore\")) ## combine fit to first response with fits to remaining responses res <- c(fit1, lapply(as.data.frame(Y[,-1]), refit, object=fit1)) #> boundary (singular) fit: see help('isSingular') #> boundary (singular) fit: see help('isSingular') #> boundary (singular) fit: see help('isSingular') #> boundary (singular) fit: see help('isSingular') #> boundary (singular) fit: see help('isSingular')  ## Ex. 2: refitting simulated data using data that contain NA values ------ sleepstudyNA <- sleepstudy sleepstudyNA$Reaction[1:3] <- NA fm0 <- lmer(Reaction ~ Days + (1|Subject), sleepstudyNA) ## the special case of refitting with a single simulation works ... ss0 <- refit(fm0, simulate(fm0)) ## ... but if simulating multiple responses (for efficiency), ## need to use na.action=na.exclude in order to have proper length of data fm1 <- lmer(Reaction ~ Days + (1|Subject), sleepstudyNA, na.action=na.exclude) ss <- simulate(fm1, 5) res2 <- refit(fm1, ss[[5]])"},{"path":"/reference/refitML.html","id":null,"dir":"Reference","previous_headings":"","what":"Refit a Model by Maximum Likelihood Criterion — refitML","title":"Refit a Model by Maximum Likelihood Criterion — refitML","text":"Refit (merMod) model using maximum likelihood criterion.","code":""},{"path":"/reference/refitML.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Refit a Model by Maximum Likelihood Criterion — refitML","text":"","code":"refitML(x, ...) # S3 method for class 'merMod' refitML (x, optimizer = \"bobyqa\", ...)"},{"path":"/reference/refitML.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Refit a Model by Maximum Likelihood Criterion — refitML","text":"x fitted model, usually class     \"lmerMod\", refit according maximum     likelihood criterion. ... optional additional parameters.  None used     present. optimizer string indicating optimizer used.","code":""},{"path":"/reference/refitML.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Refit a Model by Maximum Likelihood Criterion — refitML","text":"object like x fit maximum likelihood","code":""},{"path":"/reference/refitML.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Refit a Model by Maximum Likelihood Criterion — refitML","text":"function primarily used get maximum likelihood fit   linear mixed-effects model anova comparison.","code":""},{"path":[]},{"path":"/reference/residuals.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"residuals of merMod objects — residuals.merMod","title":"residuals of merMod objects — residuals.merMod","text":"residuals merMod objects","code":""},{"path":"/reference/residuals.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"residuals of merMod objects — residuals.merMod","text":"","code":"# S3 method for class 'merMod' residuals (object,     type = if (isGLMM(object)) \"deviance\" else \"response\",     scaled = FALSE, ...)    # S3 method for class 'lmResp' residuals (object,     type = c(\"working\", \"response\", \"deviance\", \"pearson\", \"partial\"),     ...)    # S3 method for class 'glmResp' residuals (object,     type = c(\"deviance\", \"pearson\", \"working\", \"response\", \"partial\"),     ...)"},{"path":"/reference/residuals.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"residuals of merMod objects — residuals.merMod","text":"object fitted [g]lmer (merMod) object type type residuals scaled scale residuals residual standard   deviation (=scale parameter)? ... additional arguments (ignored: method   compatibility)","code":""},{"path":"/reference/residuals.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"residuals of merMod objects — residuals.merMod","text":"default residual type varies   lmerMod glmerMod objects: try   mimic residuals.lm   residuals.glm respectively. particular,   default type \"response\", .e.   (observed-fitted) lmerMod objects vs.   \"deviance\" glmerMod objects.   type=\"partial\" yet implemented either   type. Note meaning \"pearson\"   residuals differs residuals.lm   residuals.lme.  former returns values   scaled square root user-specified weights (  ), residual standard deviation,   latter returns values scaled estimated   standard deviation (include effects   variance structure specified weights   argument).  replicate lme behaviour, use   type=\"pearson\", scaled=TRUE.","code":""},{"path":"/reference/sigma.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract Residual Standard Deviation 'Sigma' — sigma","title":"Extract Residual Standard Deviation 'Sigma' — sigma","text":"Extract estimated standard deviation errors,   “residual standard deviation” (also misnamed   “residual standard error”), fitted model.","code":""},{"path":"/reference/sigma.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract Residual Standard Deviation 'Sigma' — sigma","text":"","code":"# S3 method for class 'merMod' sigma(object, ...)"},{"path":"/reference/sigma.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract Residual Standard Deviation 'Sigma' — sigma","text":"object fitted model. ... additional, optional arguments, passed     methods. (None currently two methods.)","code":""},{"path":"/reference/sigma.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract Residual Standard Deviation 'Sigma' — sigma","text":"Typically number, estimated standard deviation   errors (“residual standard deviation”) Gaussian   models, - less interpretably - square root residual   deviance per degree freedom general models.","code":""},{"path":"/reference/sigma.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract Residual Standard Deviation 'Sigma' — sigma","text":"Package lme4 provides methods mixed-effects models class   merMod lists linear models, lmList4.","code":""},{"path":"/reference/sigma.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract Residual Standard Deviation 'Sigma' — sigma","text":"","code":"methods(sigma)# from R 3.3.0 on, shows methods from pkgs 'stats' *and* 'lme4' #> [1] sigma.default* sigma.glm*     sigma.gls*     sigma.lmList*  sigma.lmList4* #> [6] sigma.lme*     sigma.merMod*  sigma.mlm*     #> see '?methods' for accessing help and source code"},{"path":"/reference/simulate.formula.html","id":null,"dir":"Reference","previous_headings":"","what":"A simulate Method for formula objects that dispatches based on the Left-Hand Side — simulate.formula","title":"A simulate Method for formula objects that dispatches based on the Left-Hand Side — simulate.formula","text":"method evaluates left-hand side (LHS) given formula dispatches appropriate method based result setting nonce class name formula.","code":""},{"path":"/reference/simulate.formula.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A simulate Method for formula objects that dispatches based on the Left-Hand Side — simulate.formula","text":"","code":"# S3 method for class 'formula' simulate(object, nsim = 1 , seed = NULL, ..., basis, newdata, data)"},{"path":"/reference/simulate.formula.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"A simulate Method for formula objects that dispatches based on the Left-Hand Side — simulate.formula","text":"object one- two-sided formula. nsim,seed number realisations simulate random   seed use; see simulate ... additional arguments methods basis given, overrides LHS formula   purposes dispatching newdata,data passed, object's LHS evaluated   environment; one two may passed.","code":""},{"path":"/reference/simulate.formula.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A simulate Method for formula objects that dispatches based on the Left-Hand Side — simulate.formula","text":"dispatching works follows: basis passed, formula LHS    expression LHS formula object    evaluated environment newdata data (given),    case enclosed environment object. Otherwise,    basis used. result set attribute \".Basis\" object.    basis LHS, set. class vector object c(\"formula_lhs_CLASS\",    \"formula_lhs\") prepended , CLASS class    LHS value basis. LHS basis multiple    classes, prepended; LHS basis,    c(\"formula_lhs_\", \"formula_lhs\") . simulate generic evaluated new object,    arguments passed , excluding basis; newdata data    missing, passed . evaluation takes    place parent's environment. \"method\" receive formula whose LHS evaluates CLASS can therefore implemented function simulate.formula_lhs_CLASS(). function can expect formula object, additional attribute .Basis giving evaluated LHS (need evaluated ).","code":""},{"path":"/reference/simulate.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Responses From merMod Object — simulate.merMod","title":"Simulate Responses From merMod Object — simulate.merMod","text":"Simulate responses \"merMod\" fitted model object, .e.,   model represented .","code":""},{"path":"/reference/simulate.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Responses From merMod Object — simulate.merMod","text":"","code":"# S3 method for class 'merMod' simulate(object, nsim = 1, seed = NULL,    use.u = FALSE, re.form = NA,    newdata=NULL, newparams=NULL, family=NULL, cluster.rand=rnorm,    allow.new.levels = FALSE, na.action = na.pass, ...)  .simulateFun(object, nsim = 1, seed = NULL, use.u = FALSE,              re.form = NA,              newdata=NULL, newparams=NULL,              formula=NULL, family=NULL,               cluster.rand=rnorm,              weights=NULL, offset=NULL,              allow.new.levels = FALSE, na.action = na.pass,              cond.sim = TRUE, ...)"},{"path":"/reference/simulate.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Responses From merMod Object — simulate.merMod","text":"object (simulate.merMod) fitted model object     (simulate.formula) (one-sided) mixed model formula,     described lmer. nsim positive integer scalar - number responses simulate. seed optional seed used set.seed     immediately simulation generate reproducible sample. use.u (logical) TRUE, generate simulation     conditional current random-effects estimates; FALSE     generate new Normally distributed random-effects values. (Redundant     re.form, preferred: TRUE corresponds     re.form = NULL (condition random effects),     FALSE corresponds re.form = ~0 (condition none     random effects).) re.form formula random effects condition .      NULL, condition random effects; NA ~0,     condition random effects.  See Details. newdata data frame evaluate predictions. newparams new parameters use evaluating predictions,     specified start parameter lmer     glmer – list components theta     beta (LMMs GLMMs estimate scale parameter)     sigma formula (one-sided) mixed model formula, described     lmer. family GLM family, glmer. cluster.rand Function generates standardized random cluster effects.  function takes one     argument, number random values generate. weights prior weights, lmer     glmer. offset offset, glmer. allow.new.levels (logical) FALSE (default), new     levels (NA values) detected newdata trigger     error; TRUE, prediction use unconditional     (population-level) values data previously unobserved levels     (NAs). na.action NA values new data: see     na.fail cond.sim (experimental) simulate conditional     distribution?  FALSE, simulate random effects;     simulate conditional distribution, rather return     predicted group-level values ... optional additional arguments (none used     .simulateFormula)","code":""},{"path":[]},{"path":"/reference/simulate.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Simulate Responses From merMod Object — simulate.merMod","text":"ordinarily simulate used generate new       values existing, fitted model (merMod object):       however, formula, newdata, newparams       specified, simulate generates appropriate model       structure simulate . formula must       one-sided formula (.e. empty left-hand side);       general, f two-sided       formula, f[-2] can used drop LHS. re.form argument allows user specify       random effects incorporated simulation.        random effects terms included re.form       conditioned - , conditional modes       random effects included deterministic part       simulation. (new levels used (allow.new.levels       TRUE), conditional modes levels       set population mode, .e. values zero used       random effects.)  Conversely, random effect terms       included re.form simulated       - , new values chosen group based       estimated random-effects variances.      default behaviour (using re.form=NA) condition       none random effects, simulating new values       random effects. Gaussian fits, sigma specifies residual       standard deviation; Gamma fits, specifies shape       parameter (rate parameter observation       calculated shape/mean()).  negative binomial fits,       overdispersion parameter specified via family,       e.g. simulate(..., family=negative.binomial(theta=1.5)). binomial models, simulate.formula looks       binomial size first weights argument (supplied),       second left-hand side formula (formula       specified success/failure form), defaults 1 neither       supplied.       Simulated responses given proportions, unless supplied       formula matrix-valued left-hand side, case       given matrix form. left-hand side given, variables       expression must available newdata. negative binomial models, use negative.binomial       family (MASS package)       specify overdispersion parameter via       theta (sic) parameter family function, e.g.       simulate(...,family=negative.binomial(theta=1)) simulate       geometric distribution (negative binomial       overdispersion parameter 1). cluster.rand allows one test effects departures normality distribution cluster random effects, example using heavy-tailed distribution mixture distribution.  One can also use truncated normal investigate true false flagging rates; case generated effects mean 0 standard deviation 1; still considered standardized simulation multiply estimated standard deviation cluster random effects.","code":""},{"path":"/reference/simulate.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Responses From merMod Object — simulate.merMod","text":"","code":"## test whether fitted models are consistent with the ##  observed number of zeros in CBPP data set: gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),              data = cbpp, family = binomial) gg <- simulate(gm1,1000) zeros <- sapply(gg,function(x) sum(x[,\"incidence\"]==0)) plot(table(zeros)) abline(v=sum(cbpp$incidence==0),col=2)  ## ## simulate from a non-fitted model; in this case we are just ## replicating the previous model, but starting from scratch params <- list(theta=0.5,beta=c(2,-1,-2,-3)) simdat <- with(cbpp,expand.grid(herd=levels(herd),period=factor(1:4))) simdat$size <- 15 simdat$incidence <- sample(0:1,size=nrow(simdat),replace=TRUE) form <- formula(gm1)[-2]  ## RHS of equation only simulate(form,newdata=simdat,family=binomial,     newparams=params) #>    sim_1 #> 1      1 #> 2      1 #> 3      0 #> 4      1 #> 5      1 #> 6      1 #> 7      1 #> 8      1 #> 9      1 #> 10     1 #> 11     1 #> 12     0 #> 13     1 #> 14     1 #> 15     1 #> 16     0 #> 17     0 #> 18     0 #> 19     1 #> 20     0 #> 21     1 #> 22     0 #> 23     1 #> 24     1 #> 25     1 #> 26     1 #> 27     1 #> 28     0 #> 29     1 #> 30     1 #> 31     0 #> 32     0 #> 33     0 #> 34     0 #> 35     0 #> 36     0 #> 37     1 #> 38     0 #> 39     1 #> 40     1 #> 41     1 #> 42     1 #> 43     0 #> 44     1 #> 45     1 #> 46     0 #> 47     0 #> 48     0 #> 49     0 #> 50     1 #> 51     0 #> 52     0 #> 53     1 #> 54     1 #> 55     0 #> 56     0 #> 57     0 #> 58     0 #> 59     0 #> 60     0 ## simulate from negative binomial distribution instead simulate(form,newdata=simdat,family=negative.binomial(theta=2.5),     newparams=params) #>    sim_1 #> 1     11 #> 2      2 #> 3      7 #> 4      6 #> 5     18 #> 6      8 #> 7     47 #> 8     11 #> 9      6 #> 10    25 #> 11     7 #> 12     7 #> 13     1 #> 14    14 #> 15     2 #> 16     9 #> 17     1 #> 18     0 #> 19     1 #> 20     0 #> 21     3 #> 22     1 #> 23     2 #> 24     2 #> 25     9 #> 26     2 #> 27     7 #> 28     0 #> 29     3 #> 30     6 #> 31     5 #> 32     1 #> 33     0 #> 34     0 #> 35     0 #> 36     0 #> 37     9 #> 38     1 #> 39     0 #> 40     1 #> 41     3 #> 42     0 #> 43     1 #> 44     6 #> 45     1 #> 46     1 #> 47     1 #> 48     1 #> 49     0 #> 50     0 #> 51     0 #> 52     2 #> 53     0 #> 54     0 #> 55     0 #> 56     0 #> 57     0 #> 58     0 #> 59     1 #> 60     0"},{"path":"/reference/sleepstudy.html","id":null,"dir":"Reference","previous_headings":"","what":"Reaction times in a sleep deprivation study — sleepstudy","title":"Reaction times in a sleep deprivation study — sleepstudy","text":"average reaction time per day (milliseconds) subjects sleep   deprivation study. Days 0-1 adaptation training (T1/T2), day 2 baseline (B);   sleep deprivation started day 2.","code":""},{"path":"/reference/sleepstudy.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reaction times in a sleep deprivation study — sleepstudy","text":"data frame 180 observations following 3 variables. Reaction Average reaction time (ms) Days Number days sleep deprivation Subject Subject number observation made.","code":""},{"path":"/reference/sleepstudy.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Reaction times in a sleep deprivation study — sleepstudy","text":"data study described Belenky et al.   (2003), sleep-deprived group (3 hours time--bed)   first 10 days study, recovery period.   original study analyzed speed (1/(reaction time)) treated   day categorical rather continuous predictor.","code":""},{"path":"/reference/sleepstudy.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Reaction times in a sleep deprivation study — sleepstudy","text":"Gregory Belenky, Nancy J. Wesensten, David R. Thorne,   Maria L. Thomas, Helen C. Sing, Daniel P. Redmond,   Michael B. Russo Thomas J. Balkin (2003) Patterns   performance degradation restoration sleep   restriction subsequent recovery: sleep   dose-response study. Journal Sleep Research   12, 1–12.","code":""},{"path":"/reference/sleepstudy.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Reaction times in a sleep deprivation study — sleepstudy","text":"","code":"str(sleepstudy) #> 'data.frame':\t180 obs. of  3 variables: #>  $ Reaction: num  250 259 251 321 357 ... #>  $ Days    : num  0 1 2 3 4 5 6 7 8 9 ... #>  $ Subject : Factor w/ 18 levels \"308\",\"309\",\"310\",..: 1 1 1 1 1 1 1 1 1 1 ... require(lattice) xyplot(Reaction ~ Days | Subject, sleepstudy, type = c(\"g\",\"p\",\"r\"),        index = function(x,y) coef(lm(y ~ x))[1],        xlab = \"Days of sleep deprivation\",        ylab = \"Average reaction time (ms)\", aspect = \"xy\")  (fm1 <- lmer(Reaction ~ Days + (Days|Subject), sleepstudy, subset=Days>=2)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy #>  Subset: Days >= 2 #> REML criterion at convergence: 1404.094 #> Random effects: #>  Groups   Name        Std.Dev. Corr  #>  Subject  (Intercept) 31.507         #>           Days         6.766   -0.25 #>  Residual             25.526         #> Number of obs: 144, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      245.10        11.44   ## independent model (fm2 <- lmer(Reaction ~ Days + (1|Subject) + (0+Days|Subject), sleepstudy, subset=Days>=2)) #> Linear mixed model fit by REML ['lmerMod'] #> Formula: Reaction ~ Days + (1 | Subject) + (0 + Days | Subject) #>    Data: sleepstudy #>  Subset: Days >= 2 #> REML criterion at convergence: 1404.626 #> Random effects: #>  Groups    Name        Std.Dev. #>  Subject   (Intercept) 28.843   #>  Subject.1 Days         6.285   #>  Residual              25.747   #> Number of obs: 144, groups:  Subject, 18 #> Fixed Effects: #> (Intercept)         Days   #>      245.10        11.44"},{"path":"/reference/troubleshooting.html","id":null,"dir":"Reference","previous_headings":"","what":"Troubleshooting — troubleshooting","title":"Troubleshooting — troubleshooting","text":"page attempts summarize common problems   fitting [gn]lmer models troubleshoot . symptoms/diagnoses/workarounds listed due   various issues actual mixed model fitting process. may   run problems due multicollinearity variables   incorrectly typed (e.g. variable accidentally coded character   factor rather numeric). problems can often isolated   trying lm glm fit attempting construct   design matrix via model.matrix() (case random   effects model excluded). tests fail problem   likely specifically lme4 issue.  failure converge (xxxx) evaluations     optimizer hit maximum limit function evaluations.      increase , use optControl argument     [g]lmerControl – Nelder_Mead bobyqa     relevant parameter maxfun; optim     optimx-wrapped optimizers, including     nlminbwrap, maxit;     nloptwrap, maxeval. Model failed converge max|grad| ... scaled     gradient fitted (RE)ML estimates     worryingly large. Try refitting parameters starting current       estimates: getting consistent results (warning)       suggests false positive switching optimizers: getting consistent       results suggests really problem; getting similar       log-likelihood different parameter estimates suggests       parameters poorly determined (possibly result       misspecified overfitted model) compute values deviance neighbourhood estimated       parameters double-check lme4 really found       local optimum. Hessian numerically singular: parameters       uniquely determined     Hessian (inverse curvature matrix) maximum likelihood REML     estimates large eigenvalue, indicating (within numerical     tolerances) surface completely flat direction.     model may misspecified, extremely badly scaled (see     \"Model nearly unidentifiable\"). Model nearly unidentifiable ... Rescale variables?     Hessian (inverse curvature matrix) maximum likelihood REML     estimates large eigenvalue, indicating surface     nearly flat direction. Consider centering /scaling     continuous predictor variables. Contrasts can applied factors 2 levels     One categorical predictors model fewer two     levels. may due user error converting predictors     factors prior modeling, may result factor levels     eliminated due NAs predictors. Double-check number     data points factor level see one culprit:     lapply(na.omit(df[,vars]), table) (df     data.frame vars column names predictor     variables).","code":""},{"path":"/reference/utilities.html","id":null,"dir":"Reference","previous_headings":"","what":"Print and Summary Method Utilities for Mixed Effects — prt-utilities","title":"Print and Summary Method Utilities for Mixed Effects — prt-utilities","text":"print, summary methods (including   print summary() result) lme4   modular, using ten small utility functions.  packages,   building lme4 can use utilities ease   programming consistency output. Notably see Examples. llikAIC() extracts  log likelihood, AIC, related   statics Fitted LMM. formatVC() “format()”s VarCorr matrix   random effects – print()ing   show()ing; also “workhorse”   .prt.VC(), returns character matrix. .prt.*() use cat print   produce output.","code":""},{"path":"/reference/utilities.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Print and Summary Method Utilities for Mixed Effects — prt-utilities","text":"","code":"llikAIC(object, devianceFUN = devCrit, chkREML = TRUE,         devcomp = object@devcomp)  methTitle(dims)  .prt.methTit(mtit, class) .prt.family (famL) .prt.resids (resids, digits, title = \"Scaled residuals:\", ...) .prt.call   (call, long = TRUE) .prt.aictab (aictab, digits = 1) .prt.grps   (ngrps, nobs) .prt.warn   (optinfo, summary = FALSE, ...)  .prt.VC (varcor, digits, comp = \"Std.Dev.\", corr = any(comp == \"Std.Dev.\"),          formatter = format, ...) formatVC(varcor, digits = max(3, getOption(\"digits\") - 2),          comp = \"Std.Dev.\", corr = any(comp == \"Std.Dev.\"),          formatter = format,          useScale = attr(varcor, \"useSc\"), ...)"},{"path":"/reference/utilities.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Print and Summary Method Utilities for Mixed Effects — prt-utilities","text":"object LMM model fit devianceFUN function used computing deviance;     changed lme4 created objects. chkREML optional logical indicating object maybe REML     fit.  devcomp lme4 always equivalent     object@devcomp; list   dims lme4 always equivalent     object@devcomp$dims, named vector list components     \"GLMM\", \"NLMM\", \"REML\", \"nAGQ\"     first two logical scalars, latter     two typically FALSE numeric.  mtit result methTitle(object) class typically class(object).  famL list components family     link, character string; note standard     R family objects can used directly, well.  resids numeric vector model residuals. digits non-negative integer (significant) digits print minimally. title character string. ... optional arguments passed , e.g., residuals().  call call model fit; e.g., available     via (generic) function getCall(). long logical indicating output may long, e.g.,     printing control part call one.  aictab typically AICtab component result     llikAIC().  varcor typically result VarCorr(). comp optional character vector length 1 2,     containing \"Std.Dev.\" /\"Variance\", indicating     columns use. corr logical indicating correlations     covariances used vector random effects. formatter function used formatting numbers.  ngrps integer (vector), typically result     ngrps(object). nobs integer; number observations, e.g., result     nobs.  optinfo typically object @ optinfo, optimization     infos, including warnings . summary logical  useScale (logical) whether parent model estimates scale parameter.","code":""},{"path":"/reference/utilities.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Print and Summary Method Utilities for Mixed Effects — prt-utilities","text":"llikAIC() returns list components  logLik logLik(object), AICtab “table” AIC, BIC,     logLik, deviance df.residual() values.","code":""},{"path":"/reference/utilities.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Print and Summary Method Utilities for Mixed Effects — prt-utilities","text":"","code":"## Create a few \"lme4 standard\" models ------------------------------ fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy) fmM <- update(fm1, REML=FALSE) # -> Maximum Likelihood fmQ <- update(fm1, . ~ Days + (Days | Subject))  gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),              data = cbpp, family = binomial) gmA <- update(gm1, nAGQ = 5)   (lA1 <- llikAIC(fm1)) #> $logLik #> 'log Lik.' -871.8141 (df=6) #>  #> $AICtab #>     REML  #> 1743.628  #>  (lAM <- llikAIC(fmM)) #> $logLik #> 'log Lik.' -875.9697 (df=6) #>  #> $AICtab #>       AIC       BIC    logLik -2*log(L)  df.resid  #> 1763.9393 1783.0971 -875.9697 1751.9393  174.0000  #>  (lAg <- llikAIC(gmA)) #> $logLik #> 'log Lik.' -50.00568 (df=5) #>  #> $AICtab #>       AIC       BIC    logLik -2*log(L)  df.resid  #> 110.01137 120.13813 -50.00568 100.01137  51.00000  #>   (m1 <- methTitle(fm1 @ devcomp $ dims)) #> [1] \"Linear mixed model fit by REML\" (mM <- methTitle(fmM @ devcomp $ dims)) #> [1] \"Linear mixed model fit by maximum likelihood \" (mG <- methTitle(gm1 @ devcomp $ dims)) #> [1] \"Generalized linear mixed model fit by maximum likelihood (Laplace Approximation)\" (mA <- methTitle(gmA @ devcomp $ dims)) #> [1] \"Generalized linear mixed model fit by maximum likelihood (Adaptive Gauss-Hermite Quadrature, nAGQ = 5)\"  .prt.methTit(m1, class(fm1)) #> Linear mixed model fit by REML ['lmerMod'] .prt.methTit(mA, class(gmA)) #> Generalized linear mixed model fit by maximum likelihood (Adaptive #>   Gauss-Hermite Quadrature, nAGQ = 5) [glmerMod]  .prt.family(gaussian()) #>  Family: gaussian  ( identity ) .prt.family(binomial()) #>  Family: binomial  ( logit ) .prt.family( poisson()) #>  Family: poisson  ( log )  .prt.resids(residuals(fm1), digits = 4) #> Scaled residuals:  #>      Min       1Q   Median       3Q      Max  #> -101.179  -11.859    0.592   11.859  132.547  #>  .prt.resids(residuals(fmM), digits = 2) #> Scaled residuals:  #>    Min     1Q Median     3Q    Max  #> -100.9  -11.9    0.7   11.9  132.5  #>   .prt.call(getCall(fm1)) #> Formula: Reaction ~ Days + (Days | Subject) #>    Data: sleepstudy .prt.call(getCall(gm1)) #> Formula: cbind(incidence, size - incidence) ~ period + (1 | herd) #>    Data: cbpp  .prt.aictab ( lA1 $ AICtab ) # REML #> REML criterion at convergence: 1743.6 .prt.aictab ( lAM $ AICtab ) # ML --> AIC, BIC, ... #>       AIC       BIC    logLik -2*log(L)  df.resid  #>    1763.9    1783.1    -876.0    1751.9       174   V1 <- VarCorr(fm1) m <- formatVC(V1) stopifnot(is.matrix(m), is.character(m), ncol(m) == 4) print(m, quote = FALSE) ## prints all but the first line of .prt.VC() below: #>  Groups   Name        Std.Dev. Corr  #>  Subject  (Intercept) 24.7407        #>           Days         5.9221  0.066 #>  Residual             25.5918        .prt.VC( V1, digits = 4) #> Random effects: #>  Groups   Name        Std.Dev. Corr #>  Subject  (Intercept) 24.741        #>           Days         5.922   0.07 #>  Residual             25.592        ## Random effects: ##  Groups   Name        Std.Dev. Corr ##  Subject  (Intercept) 24.740 ##           Days         5.922   0.07 ##  Residual             25.592 p1 <- capture.output(V1) p2 <- capture.output( print(m, quote=FALSE) ) pX <- capture.output( .prt.VC(V1, digits = max(3, getOption(\"digits\")-2)) ) stopifnot(identical(p1, p2),           identical(p1, pX[-1])) # [-1] : dropping 1st line  (Vq <- VarCorr(fmQ)) # default print() #>  Groups   Name        Std.Dev. Corr  #>  Subject  (Intercept) 24.7407        #>           Days         5.9221  0.066 #>  Residual             25.5918        print(Vq, comp = c(\"Std.Dev.\", \"Variance\")) #>  Groups   Name        Std.Dev. Variance Corr  #>  Subject  (Intercept) 24.7407  612.100        #>           Days         5.9221   35.072  0.066 #>  Residual             25.5918  654.940        print(Vq, comp = c(\"Std.Dev.\", \"Variance\"), corr=FALSE) #>  Groups   Name        Std.Dev. Variance Cov     #>  Subject  (Intercept) 24.7407  612.100          #>           Days         5.9221   35.072    9.604 #>  Residual             25.5918  654.940          print(Vq, comp = \"Variance\") #>  Groups   Name        Variance Cov     #>  Subject  (Intercept) 612.100          #>           Days         35.072    9.604 #>  Residual             654.940           .prt.grps(ngrps = ngrps(fm1),           nobs  = nobs (fm1)) #> Number of obs: 180, groups:  Subject, 18 ## --> Number of obs: 180, groups:  Subject, 18  .prt.warn(fm1 @ optinfo) # nothing .. had no warnings .prt.warn(fmQ @ optinfo) # (ditto)"},{"path":"/reference/vcconv.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert between representations of (co-)variance structures — vcconv","title":"Convert between representations of (co-)variance structures — vcconv","text":"Convert representations (co-)variance structures   (EXPERIMENTAL).  See source code details.","code":""},{"path":"/reference/vcconv.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert between representations of (co-)variance structures — vcconv","text":"","code":"mlist2vec(L)   vec2mlist(v, n = NULL, symm = TRUE)   vec2STlist(v, n = NULL)   sdcor2cov(m)   cov2sdcor(V)   Vv_to_Cv(v, n = NULL, s = 1)   Sv_to_Cv(v, n = NULL, s = 1)   Cv_to_Vv(v, n = NULL, s = 1)   Cv_to_Sv(v, n = NULL, s = 1)"},{"path":"/reference/vcconv.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert between representations of (co-)variance structures — vcconv","text":"L List symmetric, upper-triangular, lower-triangular     square matrices. v Concatenated vector containing elements     lower-triangle (including diagonal) symmetric triangular     matrix. n Number rows (columns) resulting matrix. symm Return symmetric matrix TRUE lower-triangular     FALSE. m Standard deviation-correlation matrix. V Covariance matrix. s Scale parameter.","code":""},{"path":"/reference/vcconv.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert between representations of (co-)variance structures — vcconv","text":"(Co-)variance structure","code":""},{"path":"/reference/vcconv.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Convert between representations of (co-)variance structures — vcconv","text":"mlist2vec Convert list matrices concatenated       vector lower triangles attribute gives       dimension matrix original list. attribute may       used reconstruct matrices.  Returns concatenation       elements one triangle matrix. attribute       \"clen\" gives dimension matrix. vec2mlist Convert concatenated vector list matrices (lower       triangle symmetric). matrices represent Cholesky       factors, covariance matrices, correlation matrices (      standard deviations diagonal). vec2STlist Convert concatenated vector list ST       matrices. sdcor2cov Standard deviation-correlation matrix       covariance matrix convert 'sdcor' format (std dev diagonal,       cor -diag) variance-covariance matrix. cov2sdcor Covariance matrix standard       deviation-correlation matrix (.e. standard deviations       diagonal correlations diagonal). Vv_to_Cv Variance-covariance relative covariance       factor. Returns vector elements lower triangle       relative covariance factor. Sv_to_Cv Standard-deviation-correlation relative covariance       factor. Returns vector elements lower triangle       relative covariance factor. Cv_to_Vv Relative covariance factor       variance-covariance. unscaled Cholesky vector (possibly       scaled) variance-covariance vector. Returns vector elements       lower triangle variance-covariance matrix. Cv_to_Sv Relative covariance factor       standard-deviation-correlation.  unscaled Chol sd-cor       vector. Returns vector elements lower triangle       standard-deviation-correlation matrix.","code":""},{"path":"/reference/vcconv.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert between representations of (co-)variance structures — vcconv","text":"","code":"vec2mlist(1:6) #> $`1` #>      [,1] [,2] [,3] #> [1,]    1    2    3 #> [2,]    2    4    5 #> [3,]    3    5    6 #>  mlist2vec(vec2mlist(1:6)) # approximate inverse #> 11 12 13 14 15 16  #>  1  2  3  4  5  6  #> attr(,\"clen\") #> 1  #> 3"},{"path":"/reference/vcov.merMod.html","id":null,"dir":"Reference","previous_headings":"","what":"Covariance matrix of estimated parameters — vcov.merMod","title":"Covariance matrix of estimated parameters — vcov.merMod","text":"Compute variance-covariance matrix estimated paramers.   Optionally also computes correlations, full (joint)   covariance matrix fixed-effect coefficients conditional   modes random effects.","code":""},{"path":"/reference/vcov.merMod.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Covariance matrix of estimated parameters — vcov.merMod","text":"","code":"# S3 method for class 'merMod' vcov(object, correlation = TRUE, sigm = sigma(object),     use.hessian = NULL, full = FALSE, ...)"},{"path":"/reference/vcov.merMod.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Covariance matrix of estimated parameters — vcov.merMod","text":"object R object class merMod, .e.,     resulting lmer(), glmer(),     etc. correlation (logical)     indicates whether correlation matrix well     variance-covariance matrix desired sigm residual standard error; default sigma(object). use.hessian (logical) indicates whether use     finite-difference Hessian deviance function compute     standard errors fixed effects. See Details. full return 'full' covariance matrix, .e. joint     covariance matrix conditional distribution conditional     modes (getME(., \"b\")) fixed-effect     parameters. (correlation use.hessian     ignored case.) Note option may slow models large numbers   random-effect levels! ... extra arguments method compatibility (ignored)","code":""},{"path":"/reference/vcov.merMod.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Covariance matrix of estimated parameters — vcov.merMod","text":"use.hessian = FALSE, code estimates   covariance matrix based internal information inverse   model matrix (see getME(.,\"RX\")). exact   linear mixed models, approximate GLMMs.   default use Hessian whenever   fixed effect parameters arguments deviance   function (.e. GLMMs nAGQ>0), use   getME(.,\"RX\") whenever fixed effect parameters   profiled (.e. GLMMs nAGQ==0 LMMs). use.hessian=FALSE backward-compatible older versions   lme4, may give less accurate SE estimates   estimates fixed-effect (see getME(.,\"beta\"))   random-effect (see getME(.,\"theta\")) parameters   correlated. However, use.hessian=TRUE always accurate:   numerically unstable fits, approximation using RX   actually reliable (Hessian computed   finite difference approximation, also error-prone): see   e.g. https://github.com/lme4/lme4/issues/720","code":""},{"path":"/reference/vcov.merMod.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Covariance matrix of estimated parameters — vcov.merMod","text":"covariance matrix (sparse full=TRUE)","code":""},{"path":"/reference/vcov.merMod.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Covariance matrix of estimated parameters — vcov.merMod","text":"","code":"fm1 <- lmer(Reaction ~ Days + (Days | Subject), sleepstudy) gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),              data = cbpp, family = binomial) (v1 <- vcov(fm1)) #> 2 x 2 Matrix of class \"dpoMatrix\" #>             (Intercept)      Days #> (Intercept)   46.575120 -1.451088 #> Days          -1.451088  2.389466 v2 <- vcov(fm1, correlation = TRUE) # extract the hidden 'correlation' entry in @factors as(v2, \"corMatrix\") #> 2 x 2 Matrix of class \"corMatrix\" #>             (Intercept)       Days #> (Intercept)   1.0000000 -0.1375519 #> Days         -0.1375519  1.0000000 v3 <- vcov(gm1) v3X <- vcov(gm1, use.hessian  = FALSE) #> Warning: variance-covariance matrix computed from finite-difference Hessian #> and from RX differ by >1e-04: consider 'use.hessian=TRUE' all.equal(v3, v3X) #> [1] \"Mean relative difference: 0.02937752\" ## full correlatiom matrix cv <- vcov(fm1, full = TRUE) image(cv, xlab = \"\", ylab = \"\",       scales = list(y = list(labels = rownames(cv)),                     at = seq(nrow(cv)),                     x = list(labels = NULL)))"},{"path":[]},{"path":"/news/index.html","id":"user-visible-changes-1-1-37-9000","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-37.9000 (2025-05-06)","text":"lme4 now depends completely reformulas package formula processing etc.; corresponding functions (expandDoubleVerts, subbars, findbars, nobars, etc.) longer implemented within/exported package","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-37-2025-03-26","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-37 (2025-03-26)","title":"CHANGES IN lme4 VERSION 1.1-37 (2025-03-26)","text":"CRAN release: 2025-03-26","code":""},{"path":"/news/index.html","id":"new-features-1-1-37","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-37 (2025-03-26)","text":"simulate.merMod .simulateFun gain cluster.rand argument allow specifying non-Normal cluster random effects simulations. simulation.Rmd, derived .md .html files misc/notes/, trace flow simulation just change. Likely interest developers.","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-37","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-37 (2025-03-26)","text":"headline print summary output glmer fits now labels minimum objective function (correctly) “-2*log(L)” rather “deviance” (inspired glmmTMB GH #1156)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-36","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-36","title":"CHANGES IN lme4 VERSION 1.1-36","text":"CRAN release: 2025-01-11","code":""},{"path":"/news/index.html","id":"new-features-1-1-36","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-36","text":"full (joint) conditional covariance matrix fixed effects conditional modes now available via vcov(fitted_model, full = TRUE) Random effects formulas now processed code reformulas package, meaning extended random effects formulas ((1|f*g) crossed random effects) now work","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-36","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-36","text":"simulate newparams longer prints message individual parameter vectors unnamed","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-36","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-36","text":"floating-point errors leading slightly negative deviances lead NaN deviance residuals (Wolfgang Viechtbauer, GH #812)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-355-2024-07-03","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-35.5 (2024-07-03)","title":"CHANGES IN lme4 VERSION 1.1-35.5 (2024-07-03)","text":"CRAN release: 2024-07-03","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-35-5","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-35.5 (2024-07-03)","text":"predict, synonyms ReForm, REForm, REform re.form now hard-deprecated, giving error (10 years soft deprecation)","code":""},{"path":"/news/index.html","id":"other-changes-1-1-35-5","dir":"Changelog","previous_headings":"","what":"OTHER CHANGES","title":"CHANGES IN lme4 VERSION 1.1-35.5 (2024-07-03)","text":"minor adjustments test tolerances correct Matrix dependency >= 1.2-3","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-354-2024-06-19","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-35.4 (2024-06-19)","title":"CHANGES IN lme4 VERSION 1.1-35.4 (2024-06-19)","text":"CRAN release: 2024-06-19","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-35-4","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-35.4 (2024-06-19)","text":"predict(., re.form=…) works wider range cases (GH #691) Gamma simulation now uses correct shape parameter (GH #782) Avoid triggering RcppEigen UBSAN bug(?) case profiling fixed effects merMod object single fixed effect parameter (GH #794: lots help Dirk Eddelbuettel Mikael Jagan) fix bug plot methods (cbind’ing zero-length objects)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-353-2024-04-16","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-35.3 (2024-04-16)","title":"CHANGES IN lme4 VERSION 1.1-35.3 (2024-04-16)","text":"CRAN release: 2024-04-16","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-35-3","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-35.3 (2024-04-16)","text":"bug-fix ASAN/memory access problem CholmodDecomposition (Mikael Jagan)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-352-2024-03-28","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-35.2 (2024-03-28)","title":"CHANGES IN lme4 VERSION 1.1-35.2 (2024-03-28)","text":"CRAN release: 2024-03-28","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-35-2","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-35.2 (2024-03-28)","text":"simulate works () re.form=NULL NA values present data (GH #737, @frousseu)","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-35-2","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-35.2 (2024-03-28)","text":"updated tests upstream Matrix version; now warn ABI incompatibility, package version mismatch alone","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-351-2023-11-05","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-35.1 (2023-11-05)","title":"CHANGES IN lme4 VERSION 1.1-35.1 (2023-11-05)","text":"CRAN release: 2023-11-05","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-35-1","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-35.1 (2023-11-05)","text":"lFormula glFormula allow matrix-valued responses (use downstream packages like galamm)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-35-2023-11-03","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-35 (2023-11-03)","title":"CHANGES IN lme4 VERSION 1.1-35 (2023-11-03)","text":"CRAN release: 2023-11-03","code":""},{"path":"/news/index.html","id":"new-features-1-1-35","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-35 (2023-11-03)","text":"predict.merMod now se.fit method, computes standard errors predictions, conditional estimated theta (variance-covariance) parameters","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-35","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-35 (2023-11-03)","text":"using lmer matrix-valued response now throws informative error message, directing user ?refit","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-34-2023-07-04","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-34 (2023-07-04)","title":"CHANGES IN lme4 VERSION 1.1-34 (2023-07-04)","text":"CRAN release: 2023-07-04","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-34","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-34 (2023-07-04)","text":"summary() now records correlation specified explicitly ; print() method takes account; notably summary(, correlation=TRUE) default print correlation (matrix fixed effects) fixing GH #725","code":""},{"path":"/news/index.html","id":"new-features-1-1-34","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-34 (2023-07-04)","text":"refit gains newweights argument","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-33-2023-04-25","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-33 (2023-04-25)","title":"CHANGES IN lme4 VERSION 1.1-33 (2023-04-25)","text":"CRAN release: 2023-04-25","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-33","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-33 (2023-04-25)","text":"boundary check fail occasionally large data produced NA value computed gradient; now warns instead (GH #719, Mathias Ambuehl) allFit now works better optimx dfoptim packages installed (GH #724) refit reset internal degrees freedom component incorrectly REML fits (resulted incorrect reported REML criteria, otherwise harmless: side effect GH #678)","code":""},{"path":"/news/index.html","id":"new-features-1-1-33","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-33 (2023-04-25)","text":"dotplot qqmath methods gain level argument set width confidence intervals dotplot method now flexible, using “.v” options (lty.v, col.line.v, lwd.v) set appearance vertical lines (Iago Giné Vázquez) refit gains newweights argument (GH #678)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-32-2023-03-14","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-32 (2023-03-14)","title":"CHANGES IN lme4 VERSION 1.1-32 (2023-03-14)","text":"CRAN release: 2023-03-14","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-32","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-32 (2023-03-14)","text":"formatVC() gets new optional argument corr indicating correlations covariances used vector random effects; corresponds print(, ranef.corr = …) . default, FALSE comp = “Variance”, fixing (GH #707). qqmath.merMod adds (useless) data argument S3 compatibility. Going forward, id idLabels arguments always specified name. added code try detect/warn done.","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-32","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-32 (2023-03-14)","text":"nobars now retains environment formula argument (GH #713, Mikael Jagan)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-31-2022-11-01","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-31 (2022-11-01)","title":"CHANGES IN lme4 VERSION 1.1-31 (2022-11-01)","text":"CRAN release: 2022-10-31","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-31","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-31 (2022-11-01)","text":"confint(fm, ) now works (years broken) . simulating binomial model factor response, simulated response contains single factor level, now works (Daniel Kennedy)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-30-2022-07-08","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-30 (2022-07-08)","title":"CHANGES IN lme4 VERSION 1.1-30 (2022-07-08)","text":"CRAN release: 2022-07-08","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-30","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-30 (2022-07-08)","text":"nl (term names) component added output list mkReTrms (GH #679) eliminate partial-matching eta (etastart) (GH #686: actually “user-visible” unless getOption(“warnPartialMatchDollar”) TRUE) summary method doesn’t break GLMMs binomial/Poisson merDeriv’s vcov.glmerMod method attached (GH #688)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-30","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-30 (2022-07-08)","text":"better handling simulate(., re.form = NULL) model frame contains derived components (e.g. offset(), log(x)) (https://github.com/florianhartig/DHARMa/issues/335) bootMer works glmmTMB (broken 1.1-29) maxfun argument allFit controls max function evaluations every optimizer type (GH#685)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-29-2022-04-07","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-29 (2022-04-07)","title":"CHANGES IN lme4 VERSION 1.1-29 (2022-04-07)","text":"CRAN release: 2022-04-07","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-29","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-29 (2022-04-07)","text":"prediction new levels (allowed) returns informative error message (displays list unobserved levels)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-29","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-29 (2022-04-07)","text":"glmer.nb now works lme4 loaded (GH #658, @brgew) tests singularity (check.conv.singular) now run independently derivative computation (e.g., calc.derivs=FALSE) (GH #660, @palday) influence.merMod now works data originally specified tibble fixed bug cooks.distance method influence.merMod (.e., objects created via influence(fitted_model)) (John Fox) (GH #672) predict works formulas containing . newdata specified (GH #653) bootMer now correctly inherits control settings original fit","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-28-2022-02-04","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-28 (2022-02-04)","title":"CHANGES IN lme4 VERSION 1.1-28 (2022-02-04)","text":"CRAN release: 2022-02-04","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-28","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-28 (2022-02-04)","text":"construction interacting factors (e.g. f1:f2 f1/f2 occur random effects terms) now efficient partially crossed designs (doesn’t try create combinations f1 f2) (GH #635 #636) mkNewReTrms exported singular-fit message now refers help(“isSingular”) rather ?isSingular","code":""},{"path":"/news/index.html","id":"tests-1-1-28","dir":"Changelog","previous_headings":"","what":"TESTS","title":"CHANGES IN lme4 VERSION 1.1-28 (2022-02-04)","text":"fix .equal(p1,p2,p3) similar expect_equal() thinkos fix tests run lme4:::testLevel() > 1; adapt tests upcoming Matrix 1.4-1 names(diag())","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-28","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-28 (2022-02-04)","text":"reOnly preserves environment (GH #654, Mikael Jagan) backward-compatibility hooks changed evaluate run-time (.e., .onLoad()) rather build time (GH #649) lmList longer warns data tibble (GH #645)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-271-2021-06-22","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-27.1 (2021-06-22)","title":"CHANGES IN lme4 VERSION 1.1-27.1 (2021-06-22)","text":"CRAN release: 2021-06-22","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-27-1","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-27.1 (2021-06-22)","text":"influence.merMod allows user-specified starting parameters cleaned performance vignette","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-27-1","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-27.1 (2021-06-22)","text":"cooks.distance now works objects computed influence method influence.merMod now works glmer models using nAGQ=0 predict (new data) simulate methods now work models >100 levels random effect grouping variable (GH #631)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-27-2021-05-15","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-27 (2021-05-15)","title":"CHANGES IN lme4 VERSION 1.1-27 (2021-05-15)","text":"CRAN release: 2021-05-15","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-27","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-27 (2021-05-15)","text":"improvements Lionel Henry (via https://github.com/lme4/lme4/pull/587) fix corner cases data checking; also resolves GH #601 (allFit scoping) getME(., “lower”) now names (request GH #609) improved detection NaN internal calculations (typically due underflow/overflow --bounds linear predictors non-constraining link functions identity-link Gamma models) influence.merMod allows parallel computation statmod package longer required unless attempting simulate results model inverse Gaussian response","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-27","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-27 (2021-05-15)","text":"long formulas work better anova headings (GH #611)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-26-2020-11-30","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-26 (2020-11-30)","title":"CHANGES IN lme4 VERSION 1.1-26 (2020-11-30)","text":"CRAN release: 2020-11-30","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-26","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-26 (2020-11-30)","text":"predict, model.frame(.,fixed.=TRUE) work variable names containing spaces (GH #605) simulate works original response variable logical densityplot handles partly broken profiles robustly","code":""},{"path":"/news/index.html","id":"new-features-1-1-26","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-26 (2020-11-30)","text":"thpr method densityplot() (plotting profiles scaled densities) gets new arguments","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-25-2020-10-23","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-25 (2020-10-23)","title":"CHANGES IN lme4 VERSION 1.1-25 (2020-10-23)","text":"CRAN release: 2020-10-23 Set tests run environment variable LME4_TEST_LEVEL>1","code":""},{"path":[]},{"path":"/news/index.html","id":"user-visible-changes-1-1-24","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-24","text":"anova() now returns p-value NA df difference two models 0 (implying equivalent models) (GH#583, @MetaEntropy) speedup coef() large models, skipping conditional variance calculation (Alexander Bauer) simulate.formula machinery changed slightly, compatibility ergm package (Pavel Krivitsky) informational messages (non-)convergence improved (GH #599) improved error messages 0 non-NA cases data (GH #533)","code":""},{"path":"/news/index.html","id":"new-features-1-1-24","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-24","text":"getME(.,“devfun”) now works glmer objects. Additionally, profile/confint GLMMs longer depend objects fitting environment remaining unchanged (GH #589). change also affects likelihood profiling machinery; results glmer profiling/CIs may match results previous versions exactly.","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-24","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-24","text":"improved handling/documentation glmer.nb controls (GH #556) predict works better gamm4 objects (GH #575) resolved long-standing UBSAN issues (GH #561)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-23-2020-03-06","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-23 (2020-03-06)","title":"CHANGES IN lme4 VERSION 1.1-23 (2020-03-06)","text":"CRAN release: 2020-04-07 PROTECT/UNPROTECT fixes","code":""},{"path":[]},{"path":"/news/index.html","id":"user-visible-changes-1-1-22","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-22","text":"prediction now works better factors many levels (GH#467, solution @sihoward) minor changes argument order [g]lmerControl; default tolerance convergence checks increased 0.001 0.002 glmerControl (now consistent lmerControl) lmer(*, family=“”) longer valid; deprecated since 2013-06. lmer(), glmer(), nlmer() longer formal … argument. defunctifies use sparseX = . argument reveal user errors, extraneous arguments previously disregarded. isSingular(x, tol), default tolerance (tol) increased 1e-5 1e-4, default check.conv.singular g?lmerControl(). clarity consistency base R methods, column names anova() output changed: “Df” becomes “npar”, “Chi Df” becomes “Df” (GH #528) simulate() now works inverse-Gaussian models (GH #284 revisited, @nahorp/Florian Hartig) single-model mode anova() now warns unused arguments … (e.g. type=“III”) default tolerances nloptwrap/BOBYQA optimizer tightened (xtol_abs ftol_abs 1e-6, now 1e-8). (revert former tolerances, use control=lmerControl(optimizer=“nloptwrap”, optCtrl=list(xtol_abs=1e-6, ftol_abs=1e-6)).)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-22","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-22","text":"improved checking missing data (@lionel-) internal checkZrank() able deal (Matrix package) rankMatrix() returning NA. allFit(fm) now works model explicit control = lmerControl(..) call. internal getStart() now works model’s start specified list, called drop1() submodel, fixing GH #521. internal function mkdevfun now works even extraneous getCall function defined global environment (GH #535) allFit() works even variable symbol used somewhere original model call (GH #538, reported Don Cohen); generally robust glmer.nb works even alternative version negative.binomial (one MASS) loaded workspace (e.g. GLMMadaptive package) (GH#516) level argument now honoured confint(…, type=“boot”, level=…) (GH #543)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-21-2019-03-05","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-21 (2019-03-05)","title":"CHANGES IN lme4 VERSION 1.1-21 (2019-03-05)","text":"CRAN release: 2019-03-05","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-21","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-21 (2019-03-05)","text":"bootMer now traps stores messages, warnings, errors bootMer returns object class c(“bootMer”,“boot”); new print confint methods class bootMer small changes wording singular-fit messages","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-20-2019-02-04","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-20 (2019-02-04)","title":"CHANGES IN lme4 VERSION 1.1-20 (2019-02-04)","text":"CRAN release: 2019-02-04","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-20","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-20 (2019-02-04)","text":"default value condVar (whether return conditional variances part ranef.merMod object) now TRUE changed default optimizer “nloptwrap” (BOBYQA implementation nloptr package) lmer models. revert old default, use control=lmerControl(optimizer=“bobyqa”)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-20","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-20 (2019-02-04)","text":"adapted tests work R-devel’s consistent formula(model.frame(.)) behavior.","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-19-2018-11-10","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-19 (2018-11-10)","title":"CHANGES IN lme4 VERSION 1.1-19 (2018-11-10)","text":"CRAN release: 2018-11-10","code":""},{"path":"/news/index.html","id":"new-features-1-1-19","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-19 (2018-11-10)","text":"influence measure code car rolled (see ?influence.merMod) mkReTrm gets new arguments reorder.terms, reorder.vars control arrangement RE terms individual effects RE terms within model structures adding material RePsychLing package (GitHub; see Bates et al 2015 arXiv:1506.04967) show orthogonal variance components. new utility isSingular() function detecting singular fits allFit function/methods moved main package, rather included auxiliary source file; computations can (principle) done parallel","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-19","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-19 (2018-11-10)","text":"default message now printed singular fits (.e., fits linear combinations variance components exactly zero) .data.frame.merMod finds conditional variance information stored either attr(.,“postVar”) attr(.,“condVar”) (glmmTMB compatibility) change defaults [g]lmerControl print message fits singular post-fitting convergence checks based estimated gradient Hessian (see troubleshooting) longer performed (nearly-)singular fits (see isSingular)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-18-1-2018-08-17","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-18-1 (2018-08-17)","title":"CHANGES IN lme4 VERSION 1.1-18-1 (2018-08-17)","text":"CRAN release: 2018-08-17 minor release; change roll back (unexport) influence.merMod method, pending resolution conflicts car package","code":""},{"path":[]},{"path":"/news/index.html","id":"user-visible-changes-1-1-18","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-18 (2018-08-16)","text":"ranef(.,condVar=TRUE) now works multiple random effects terms per factor","code":""},{"path":"/news/index.html","id":"new-features-1-1-18","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-18 (2018-08-16)","text":"rstudent influence methods available merMod objects devfun2 function (generating deviance function works standard deviation/correlation scale) now exported","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-18","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-18 (2018-08-16)","text":"lmList now obeys pool argument (instead always using currently default, GH #476)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-17-2018-04-03","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-17 (2018-04-03)","title":"CHANGES IN lme4 VERSION 1.1-17 (2018-04-03)","text":"CRAN release: 2018-04-03 maintenance release (fixes CRAN problems cross-platform tests examples)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-16-2018-03-28","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-16 (2018-03-28)","title":"CHANGES IN lme4 VERSION 1.1-16 (2018-03-28)","text":"CRAN release: 2018-03-28","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-16","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-16 (2018-03-28)","text":"lmList longer ignores subset argument (John Fox) fixed several minor issues predicting (1) grouping variables different levels original model (e.g. missing levels/factor levels explicitly specified newdata) (2) re.form subset original RE formula (unused) grouping variables omitted newdata (GH #452, #457)","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-16","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-16 (2018-03-28)","text":"lmList tries harder collect errors pass warnings documented .function method (given merMod object, returns function computes deviance/REML criterion specified parameters) print method summary.merMod objects longer collapses small values t-statistic zero","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-15-2017-12-21","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-15 (2017-12-21)","title":"CHANGES IN lme4 VERSION 1.1-15 (2017-12-21)","text":"CRAN release: 2017-12-21","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-15","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-15 (2017-12-21)","text":"model.frame(., fixed.=TRUE) now handles models “non-syntactic” (e.g. space-containing/backtick-delimited) variables formula. confint() now works default method “profile”.","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-15","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-15 (2017-12-21)","text":"exported dotplot.ranef.mer","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-14-2017-09-27","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-14 (2017-09-27)","title":"CHANGES IN lme4 VERSION 1.1-14 (2017-09-27)","text":"CRAN release: 2017-09-27","code":""},{"path":"/news/index.html","id":"new-features-1-1-14","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-14 (2017-09-27)","text":"added transf argument dotplot.ranef.mer allow back-transformation (Ferenci Tamás, GH #134) added .data.frame.ranef.mer convenience method user can specify initial value overdispersion parameter glmer.nb (Timothy Lau, GH #423)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-14","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-14 (2017-09-27)","text":"fix bug NAs fitting data carried predictions new data (!) (lmwang9527, GH #420) fix bug long terms models || notation nlmer now respects user-specified lower/upper bounds (GH #432) confint.thpr (confint method applied already-computed profile now respects “theta_”/“beta_” specifications return random-effect fixed-effect confidence intervals, respectively.","code":""},{"path":"/news/index.html","id":"documentation-improvements-1-1-14","dir":"Changelog","previous_headings":"","what":"DOCUMENTATION IMPROVEMENTS","title":"CHANGES IN lme4 VERSION 1.1-14 (2017-09-27)","text":"document need export packages objects workers using bootMer snow","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-14","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-14 (2017-09-27)","text":"improved warning message using lmerControl() glmer (GH #415) avoid deparsing big data frames checking data (GH #410) pass verbose options nloptr optimizers using nloptwrap (previously ignored, warning) fl (factor list) component mkReTrms objects now returned list rather data frame","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-13-2017-04-18","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-13 (2017-04-18)","title":"CHANGES IN lme4 VERSION 1.1-13 (2017-04-18)","text":"CRAN release: 2017-04-19","code":""},{"path":"/news/index.html","id":"new-features-1-1-13","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-13 (2017-04-18)","text":"added prof.scale argument profile.merMod, documented caveats using varianceProf/logProf transformation methods correlation parameters","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-13","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-13 (2017-04-18)","text":"suppressed spurious contrast-dropping warning (GH #414) fixed bug confint.lmList4 (GH #26) fixed bug FUN returned unnamed vector confint(.,FUN=FUN,method=“boot”) fixed small bug relating nAGQ0initStep=FALSE","code":""},{"path":"/news/index.html","id":"cran-compatibility-updates-1-1-13","dir":"Changelog","previous_headings":"","what":"CRAN-COMPATIBILITY UPDATES","title":"CHANGES IN lme4 VERSION 1.1-13 (2017-04-18)","text":"fixed time stamps compiled versions vignettes","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-12-2016-04-15","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-12 (2016-04-15)","title":"CHANGES IN lme4 VERSION 1.1-12 (2016-04-15)","text":"CRAN release: 2016-04-16","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-12","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-12 (2016-04-15)","text":"reduced default print precision fixed-effect correlation matrix summary.merMod (related GH #300)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-12","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-12 (2016-04-15)","text":"fixed bug de novo Gamma-response simulations","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-11-2016-02-11","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-11 (2016-02-11)","title":"CHANGES IN lme4 VERSION 1.1-11 (2016-02-11)","text":"CRAN release: 2016-02-12","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-11","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-11 (2016-02-11)","text":"change VarCorr method signature (compatibility upstream nlme changes)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-11","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-11 (2016-02-11)","text":"several glmer.nb bugs fixed (generally changing results, causing warnings errors e.g. bootstrapping) fixes lmList bugs (Github #320) minor documentation, vignette updates minor fix plot.merMod id specified bootMer now handles separate offset term properly (Github #250)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-10-2015-10-05","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-10 (2015-10-05)","title":"CHANGES IN lme4 VERSION 1.1-10 (2015-10-05)","text":"CRAN release: 2015-10-06","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-10","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-10 (2015-10-05)","text":"updated CITATION file.","code":""},{"path":"/news/index.html","id":"new-features-1-1-10","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-10 (2015-10-05)","text":"export set dozen printing utility functions used print methods. bootMer now allows use re.form.","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-10","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-10 (2015-10-05)","text":"fixed reordering bug names getME(.,“Ztlist”) (terms reordered decreasing order number levels grouping variable, names reordered) fixed issue simulation complex forms (nested random effects terms) included model (Github #335)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-9-2015-08-20","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-9 (2015-08-20)","title":"CHANGES IN lme4 VERSION 1.1-9 (2015-08-20)","text":"CRAN release: 2015-08-20","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-9","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-9 (2015-08-20)","text":"explicit maxit arguments various functions (refit, mkGlmerDevfun, …)","code":""},{"path":"/news/index.html","id":"new-features-1-1-9","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-9 (2015-08-20)","text":"terms formula methods now random.options getME gains glmer.nb.theta option. now (S3) generic “merMod” method lme4 potentially methods dependent packages. simulate now works glmer.nb models (Github #284: idea @aosmith16)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-9","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-9 (2015-08-20)","text":"prediction simulation now work random-effects terms data-dependent bases (e.g., poly(.) ns(.) terms) (Github #313, Edgar Gonzalez) logLik glmer.nb models now includes overdispersion parameter parameter count (df attribute) lmList handles offsets weights better lots fixes glmer.nb (Github #176, #266, #287, #318). Please note glmer.nb still somewhat unstable/construction.","code":""},{"path":"/news/index.html","id":"cran-compatibility-updates-1-1-9","dir":"Changelog","previous_headings":"","what":"CRAN-COMPATIBILITY UPDATES","title":"CHANGES IN lme4 VERSION 1.1-9 (2015-08-20)","text":"import functions base packages pass CRAN checks tweak failing tests Windows","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-8-2015-06-22","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-8 (2015-06-22)","title":"CHANGES IN lme4 VERSION 1.1-8 (2015-06-22)","text":"CRAN release: 2015-06-22","code":""},{"path":"/news/index.html","id":"new-features-1-1-8","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-8 (2015-06-22)","text":"getME gains “Tlist” option (returns vector template matrices blocks Lambda generated) hatvalues method returns diagonal hat matrix LMMs nlminbwrap convenience function allows use nlminb without going optimx package .data.frame.VarCorr.merMod gains order option allows results sorted variances first covariances last (default) lower-triangle order allow flexibility scales xyplot.thpr method (John Maindonald) models random effects form 1|f better starting values lmer optimization (Gabor Grothendieck) glmer now allows logical vector response binomial models anova now (sequential) likelihood ratio tests two models including merMod glm lm models (present, GLMMs fitted Laplace approximation)","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-8","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-8 (2015-06-22)","text":"deviance() now returns deviance, rather half negative log-likelihood, GLMMs fitted Laplace (behaviour LMMs GLMMs fitted nAGQ>1 changed) convergence warning diagnostic test issues now reported print summary methods update now (attempts ) re-evaluate original fit environment formula (done drop1) refit nonlinear mixed model fit now throws error, hopefully change future releases (related bug fixes Github #231) lmList now returns objects class lmList4, avoid overwriting lmList methods recommended nlme package names random effects parameters confint changed (modified consistency across methods); oldNames=TRUE (default) gives “.sig01”-style names, oldNames=FALSE gives “sd_(Intercept)|Subject”-style names confint(.,method=“Wald”) result now contains rows random effects parameters (values set NA) well fixed-effect parameters","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-8","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-8 (2015-06-22)","text":"simulate predict now work consistently different-length data, differing factor levels, NA values (Github #153, #197, #246, #275) refit now works correctly glmer fits (Github #231) fixed bug family.merMod; non-default links retrieved correctly (Alessandro Moscatelli) fixed bootMer bug type==“parametric”, use.u=TRUE (Mark Lai) gradient scaling convergence checks now uses Cholesky factor Hessian; correct, lead additional (probably false-positive) convergence warnings lm(), users now get error non-finite (Inf, NA, NaN) values response unless na.action set exclude omit (Github #310)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-7-2014-07-19","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-7 (2014-07-19)","title":"CHANGES IN lme4 VERSION 1.1-7 (2014-07-19)","text":"CRAN release: 2014-07-19","code":""},{"path":"/news/index.html","id":"new-features-1-1-7","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-7 (2014-07-19)","text":"nloptr package now imported; wrapper function (nloptwrap) provided lmerControl(optimizer=“nloptwrap”) ’s necessary use nloptr optimizers nonlinear optimization stage (default algorithm NLopt’s implementation BOBYQA: see ?nloptwrap examples) preliminary implementation checks scaling model matrix columns (see check.scaleX ?lmerControl) beta now allowed synonym fixef specifying starting parameters (Github #194)","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-1-7","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-7 (2014-07-19)","text":"use deviance return REML criterion now deprecated; users use REMLcrit() instead (Github #211) changed default value check.nobs.vs.rankZ “ignore” (Github #214)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-7","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-7 (2014-07-19)","text":"change gradient testing absolute relative fix confint(.,method=“boot”) allow/work properly boot.type values “perc” (reported Alan Zaslavsky) allow plot() work data specified different environment (reported Dieter Menne) predict simulate work matrix-valued predictors (Github #201) simulate bugs (Github #212) predict longer warns spuriously original response factor (Github #205) fix memory access issues (Github #200)","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-6-2014-04-13","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-6 (2014-04-13)","title":"CHANGES IN lme4 VERSION 1.1-6 (2014-04-13)","text":"CRAN release: 2014-04-13","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-6","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-6 (2014-04-13)","text":"change drop1 example prevent use old/incompatible pbkrtest versions, 2.15.3 compatibility explicitly require(mlmRev) tests prevent cyclic dependency bump RcppEigen Imports: requirement >0.3.1.2.3 >=0.3.2.0; Rcpp dependency >= 0.10.5","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-11-5-2014-03-14","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.1-5 (2014-03-14)","title":"CHANGES IN lme4 VERSION 1.1-5 (2014-03-14)","text":"CRAN release: 2014-03-14","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-5","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-5 (2014-03-14)","text":"improved NA handling simulate refit made internal handling weights/offset arguments slightly robust (Github #191) handle non-positive-definite estimated fixed effect variance-covariance matrices slightly generally/robustly (fall back RX approximation, warning, finite-difference Hessian non-PD; return NA matrix RX approximation also bad)","code":""},{"path":"/news/index.html","id":"minor-user-visible-changes-1-1-5","dir":"Changelog","previous_headings":"","what":"MINOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-5 (2014-03-14)","text":"Added output specifying Gauss-Hermite quadrature used fit model, specifying number GHQ points (Github #190)","code":""},{"path":[]},{"path":"/news/index.html","id":"bug-fixes-1-1-4","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-4","text":"Models prior weights returned incorrect sigma deviance (Github issue #155). deviance bug practical issue model comparisons, inferences given particular model. bugs now fixed. Profiling failed cases models vector random effects (Github issue #172) Standard errors fixed effects now computed approximate Hessian default (see use.hessian argument vcov.merMod); gives better (correct) answers estimates random- fixed-effect parameters correlated (Github #47)","code":""},{"path":"/news/index.html","id":"major-user-visible-changes-1-1-4","dir":"Changelog","previous_headings":"","what":"MAJOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-4","text":"default optimizer lmer fits switched “Nelder_Mead” “bobyqa” generally found latter reliable. switch back old behaviour, use control=lmerControl(optimizer=“Nelder_Mead”). Better handling rank-deficient/overparameterized fixed-effect model matrices; see check.rankX option [g]lmerControl. default value “message+drop.cols”, automatically drops redundant columns issues message (warning). (Github #144)","code":""},{"path":"/news/index.html","id":"minor-user-visible-changes-1-1-4","dir":"Changelog","previous_headings":"","what":"MINOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-4","text":"slight changes convergence checking; tolerances can specified appropriate, default tolerances changed (e.g., check.conv.grad) improved warning messages rank-deficiency X Z etc. (warnings now try indicate whether unidentifiability fixed- random-effects part model) predict simulate now prefer re.form argument specify random effects condition , allow ReForm, REForm, REform, giving message (warning) deprecated (addresses Github #170) small fixes printing consistency models fixed effects previously exported fortify function identical one found ggplot2 order able define fortify.merMod S3 method without inducing dependency ggplot2. now unexported avoid masking ggplot2’s fortify methods; want add diagnostic information results model, use fortify.merMod explicitly. simulate.formula now checks names associated theta beta parameter vectors. missing, prints message (warning); otherwise, re-orders parameter vectors match internal representation. preliminary implementation check.scaleX argument [g]lmerControl warns scaling columns fixed-effect model matrix large standard deviations (relative 1, )","code":""},{"path":[]},{"path":"/news/index.html","id":"new-features-1-1-3","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.1-3","text":"gradient Hessian now computed via finite differencing nonlinear fit done, results used additional convergence tests. Control behaviour available check.conv.* options [g]lmerControl. Singular fits (fits estimated variances zero correlations +/- 1) can also tested , although current default value check.conv.singular option “ignore”; may changed “warning” future. results stored @optinfo$derivs. (Github issue #120; based code Rune Christensen.) simulate method now work generate simulations “scratch” providing model formula, data frame holding predictor variables, list containing values model parameters: see ?simulate.merMod. (Github issue #115) VarCorr.merMod objects now .data.frame method, converting list matrices convenient form reporting post-processing. (Github issue #129)","code":""},{"path":"/news/index.html","id":"minor-user-visible-changes-1-1-3","dir":"Changelog","previous_headings":"","what":"MINOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-3","text":"results fitted(), predict(), residuals() now names cases (previously results unnamed, named predicting new data) anova method now refit argument controls whether objects class lmerMod refitted ML producing anova table. (Github issues #141, #165; contributed Henrik Singmann.) print method VarCorr objects now formatter argument finer control standard deviation variance formats optinfo slot now stores slightly information, including number function evaluations ($feval). dotplot.ranef.mer now adds titles sub-plots default, like qqmath.ranef.mer","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-3","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-3","text":"fitted now respects na.action settings (Github issue #149) confint(.,method=“boot”) now works NA values original data set (Github issue #158) previously, code stored results (parameter values, residuals, etc.) based last set parameters evaluated, rather optimal parameters. always , almost always close, previous results change slightly (Github issue #166)","code":""},{"path":[]},{"path":"/news/index.html","id":"minor-user-visible-changes-1-1-0","dir":"Changelog","previous_headings":"","what":"MINOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.1-0","text":"using default method=“profile”, confint now returns appropriate upper/lower bounds (-1/1 correlations, 0/Inf standard deviations) rather NA appropriate","code":""},{"path":"/news/index.html","id":"bug-fixes-1-1-0","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.1-0","text":"previous development version, ranef returned incorrect conditional variances (github issue #148). now fixed","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-10-6-2014-02-02","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.0-6 (2014-02-02)","title":"CHANGES IN lme4 VERSION 1.0-6 (2014-02-02)","text":"CRAN release: 2014-02-02","code":""},{"path":"/news/index.html","id":"bug-fixes-1-0-6","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.0-6 (2014-02-02)","text":"prediction now works new data fewer factor levels present original data (Github issue #143, reported Rune Haubo) existence variable “new” global environment mess lme4 : reported http://stackoverflow.com/questions/19801070/error-message-glmer-using-r--must---character-string---function","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-10-5-2013-10-24","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.0-5 (2013-10-24)","title":"CHANGES IN lme4 VERSION 1.0-5 (2013-10-24)","text":"CRAN release: 2013-10-25","code":""},{"path":"/news/index.html","id":"user-visible-changes-1-0-5","dir":"Changelog","previous_headings":"","what":"USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.0-5 (2013-10-24)","text":"confint.merMod vcov.merMod now exported, downstream package-author convenience package now depends Matrix >=1.1-0 RcppEigen >=0.3.1.2.3 new rename.response option refit (see BUG FIXES section)","code":""},{"path":"/news/index.html","id":"bug-fixes-1-0-5","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.0-5 (2013-10-24)","text":"eliminated redundant messages suppressed fixed-effect correlation matrices p>20 inverse-link functions now bounded appropriate .Machine$double.eps, allowing fitting GLMMs extreme parameter values merMod objects created refit work update: optional rename.response option added refit.merMod, allow (default still FALSE, back-compatibility) (reported . Kuznetsova) fixed buglet preventing --fly creation index variables, e.g. y~1+(1|rownames(data)) (reported J. Dushoff) predict now works properly glmer models basis-creating terms (e.g. poly, ns) step sizes determined fixed effect coefficient standard errors first state glmer fitting now bounded, allowing additional models fitted","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-10-4-2013-09-08","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 1.0-4 (2013-09-08)","title":"CHANGES IN lme4 VERSION 1.0-4 (2013-09-08)","text":"CRAN release: 2013-09-21","code":""},{"path":"/news/index.html","id":"bug-fixes-1-0-4","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.0-4 (2013-09-08)","text":"refit() now works, , lists length 1, e.g. refit(.,simulate(.)) works. (Reported Gustaf Granath) getME(.,“ST”) returning list containing Cholesky factorizations get repeated Lambda. inconsistent ST represents lme4.0. inconsistency now fixed getME(.,“ST”) now consistent definition ST matrix lme4.0. See https://github.com/lme4/lme4/issues/111 detail. Thanks Vince Dorie. Corrected order unpacking standard deviation/correlation components, affected results confint(.,method=“boot”). (Reported Reinhold Kliegl) fixed copying bug made refitML() modify original model","code":""},{"path":[]},{"path":"/news/index.html","id":"minor-user-visible-changes-1-0-1","dir":"Changelog","previous_headings":"","what":"MINOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.0-1 (2013-08-17)","text":"check.numobs.* check.numlev.* (g)lmerControl changed (recent development versions) check.nobs.* check.nlev.* respectively, default values check.nlev.gtreq.5 check.nobs.vs.rankZ changed “ignore” “warningSmall” respectively (g)lmerControl, arguments optimizer passed list called optCtrl, rather specified additional (ungrouped) arguments postVar argument ranef changed (sensible) condVar (“posterior variance” misnomer, “conditional variance” - short “variance conditional mode” - preferred) REform argument predict changed ReForm consistency tnames function, briefly exported, unexported getME(.,“cnms”) added print method merMod objects now terse, different summary.merMod objective method respMod reference class now takes optional sigma.sq parameter (defaulting NULL) allow calculation objective function residual variance different profiled value (Vince Dorie)","code":""},{"path":[]},{"path":"/news/index.html","id":"major-user-visible-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"MAJOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.0-0 (2013-08-01)","text":"internal computational machinery changed, results newest version lme4 numerically identical previous versions. reasonably well- defined fits, extremely close (within numerical tolerances 1e-4 ), unstable poorly-defined fits results may change, unstable fits may fail (apparently) succeeded previous versions. Similarly, fits may slower new version, although average new version faster stable. numerical tuning options now available (see ); non-default settings may restore speed /ability fit particular model without error. notice significant disturbing changes fitting model new version lme4, please notify maintainers. VarCorr returns results format (list variance-covariance matrices correlation stddev attributes, plus sc attribute giving residual standard deviation/scale parameter appropriate), prints different (nicer) way. default residuals gives deviance (rather Pearson) residuals applied glmer fits (side effect matching glm behaviour closely). another side effect matching glm behaviour, reported log-likelihoods glmer models longer consistent pre-1.0 lme4, consistent glm; see glmer examples.","code":""},{"path":"/news/index.html","id":"minor-user-visible-changes-1-0-0","dir":"Changelog","previous_headings":"","what":"MINOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 1.0-0 (2013-08-01)","text":"use made S3 rather S4 classes methods: one side effect nlme lme4 packages now much compatible; methods fixef longer conflict. internal optimizer changed. [gn]lmer now optimizer argument; “Nelder_Mead” default [n]lmer, combination “bobyqa” (alternative derivative-free method) “Nelder_Mead” default glmer. use nlminb optimizer old version lme4, can use optimizer=“optimx” control=list(method=“nlminb”) (need optimx package installed loaded). See lmerControl details. Families GLMMs longer restricted built-/hard- coded families; family described family, following design, usable (although hard-coded families, faster). [gn]lmer now produces objects class merMod rather class mer . structure Zt (transposed random effect design matrix) returned getME(.,“Zt”), corresponding order random effects vector (getME(.,“u”)) changed. retrieve Zt old format, use .call(Matrix::rBind,getME(.,“Ztlist”)). package checks input thoroughly non-identifiable otherwise problematic cases: see lmerControl fine control test behaviour.","code":""},{"path":"/news/index.html","id":"new-features-1-0-0","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 1.0-0 (2013-08-01)","text":"general-purpose getME accessor method allows extraction wide variety components mixed-model fit. getME also allows vector objects returned list mixed-model components. backported compatible older versions lme4 still produce mer objects rather merMod objects. However, backporting incomplete; objects extractable newer versions lme4. Optimization information (convergence codes, warnings, etc.) now stored @optinfo slot. bootMer provides framework obtaining parameter confidence intervals parametric bootstrapping. plot.merMod provides diagnostic plotting methods similar nlme package (although missing augPred). predict.merMod method gives predictions; allows effect-specific choice conditional prediction prediction population level (.e., random effects set zero). Likelihood profiling lmer glmer results (see link{profile-methods}). Confidence intervals likelihood profiling (default), parametric bootstrap, Wald approximation (fixed effects ): see confint.merMod nAGQ=0, option fast (inaccurate) fitting GLMMs. Using devFunOnly=TRUE allows user extract deviance function model, allowing diagnostics/customization model results. internal structure [gn]lmer now modular, allowing finer control different steps argument checking; construction design matrices data structures; parameter estimation; construction final merMod object (see ?modular). formula, model.frame, terms methods return full versions (including random effect terms input variables) default, fixed.argument allows access fixed effect submodel.","code":""},{"path":"/news/index.html","id":"experimental-features-1-0-0","dir":"Changelog","previous_headings":"","what":"EXPERIMENTAL FEATURES","title":"CHANGES IN lme4 VERSION 1.0-0 (2013-08-01)","text":"glmer.nb provides embryonic negative binomial fitting capability.","code":""},{"path":"/news/index.html","id":"still-non-existent-features-1-0-0","dir":"Changelog","previous_headings":"","what":"STILL NON-EXISTENT FEATURES","title":"CHANGES IN lme4 VERSION 1.0-0 (2013-08-01)","text":"Adaptive Gaussian quadrature (AGQ) available multiple /non-scalar random effects. Posterior variances conditional models non-scalar random effects. Standard errors predict.merMod results. Automatic MCMC sampling based fit turns difficult implement way really broadly reliable robust; mcmcsamp implemented near future. See pvalues alternatives. “R-side” structures (within-block correlation heteroscedasticity) current timetable.","code":""},{"path":"/news/index.html","id":"bug-fixes-1-0-0","dir":"Changelog","previous_headings":"","what":"BUG FIXES","title":"CHANGES IN lme4 VERSION 1.0-0 (2013-08-01)","text":"development version, prior weights used properly calculation residual standard deviation, fixed. Thanks Simon Wood pointing . development version, step-halving component penalized iteratively reweighted least squares algorithm working, now fixed. development version, square RZX matrices lead pwrssUpdate converge 30 iterations error. fixed adding extra column zeros RZX.","code":""},{"path":"/news/index.html","id":"deprecated-and-defunct-1-0-0","dir":"Changelog","previous_headings":"","what":"DEPRECATED AND DEFUNCT","title":"CHANGES IN lme4 VERSION 1.0-0 (2013-08-01)","text":"Previous versions lme4 provided mcmcsamp function, efficiently generated Markov chain Monte Carlo sample posterior distribution parameters, assuming flat (scaled likelihood) priors. Due difficulty constructing version mcmcsamp reliable even cases estimated random effect variances near zero (e.g. https://stat.ethz.ch/pipermail/r-sig-mixed-models/2009q4/003115.html), mcmcsamp withdrawn (precisely, updated work lme4 versions >=1.0). Calling glmer default gaussian family redirects lmer, deprecated (future glmer(…,family=“gaussian”) may fit LMM using penalized iteratively reweighted least squares algorithm). Please call lmer directly. Calling lmer family argument redirects glmer; deprecated. Please call glmer directly.","code":""},{"path":"/news/index.html","id":"changes-in-lme4-version-0999375-16-2008-06-23","dir":"Changelog","previous_headings":"","what":"CHANGES IN lme4 VERSION 0.999375-16 (2008-06-23)","title":"CHANGES IN lme4 VERSION 0.999375-16 (2008-06-23)","text":"CRAN release: 2008-06-22","code":""},{"path":"/news/index.html","id":"major-user-visible-changes-0-999375-16","dir":"Changelog","previous_headings":"","what":"MAJOR USER-VISIBLE CHANGES","title":"CHANGES IN lme4 VERSION 0.999375-16 (2008-06-23)","text":"underlying algorithms representations mixed-effects models fit package changed - better, hope. class “mer” common mixed-effects model representation linear, generalized linear, nonlinear generalized nonlinear mixed-effects models. ECME iterations longer used , analytic gradients. Components named ‘niterEM’, ‘EMverbose’, ‘gradient’ can included ‘control’ argument lmer(), glmer() nlmer() effect. PQL iterations longer used glmer() nlmer(). Laplace approximation currently available. AGQ, certain classes GLMMs NLMMs, added. ‘method’ argument lmer(), glmer() nlmer() deprecated. Use ‘REML = FALSE’ lmer() obtain ML estimates. Selection AGQ glmer() nlmer() controlled argument ‘nAGQ’, completed.","code":""},{"path":"/news/index.html","id":"new-features-0-999375-16","dir":"Changelog","previous_headings":"","what":"NEW FEATURES","title":"CHANGES IN lme4 VERSION 0.999375-16 (2008-06-23)","text":"representation mixed-effects models dramatically changed allow smooth evaluation objective variance-covariance matrices random effects approach singularity. Beta testers found representation robust usually faster previous versions lme4. mcmcsamp function uses new sampling method variance-covariance parameters allows recovery singularity. update based sample Wishart distribution. uses redundant parameter representation linear least squares update. CAUTION: Currently results mcmcsamp look peculiar probably incorrect. hope just matter omitting scaling factor seen patterns parameter estimate variance-covariance parameters maximum value chain, highly unlikely. ‘verbose’ argument lmer(), glmer() nlmer() can used instead ‘control = list(msVerbose = TRUE)’.","code":""}]
